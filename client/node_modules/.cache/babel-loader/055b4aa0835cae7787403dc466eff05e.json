{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./Token');\n\nconst {\n  ConsoleErrorListener\n} = require('./error/ErrorListener');\n\nconst {\n  ProxyErrorListener\n} = require('./error/ErrorListener');\n\nclass Recognizer {\n  constructor() {\n    this._listeners = [ConsoleErrorListener.INSTANCE];\n    this._interp = null;\n    this._stateNumber = -1;\n  }\n\n  checkVersion(toolVersion) {\n    const runtimeVersion = \"4.9.3\";\n\n    if (runtimeVersion !== toolVersion) {\n      console.log(\"ANTLR runtime and generated code versions disagree: \" + runtimeVersion + \"!=\" + toolVersion);\n    }\n  }\n\n  addErrorListener(listener) {\n    this._listeners.push(listener);\n  }\n\n  removeErrorListeners() {\n    this._listeners = [];\n  }\n\n  getLiteralNames() {\n    return Object.getPrototypeOf(this).constructor.literalNames || [];\n  }\n\n  getSymbolicNames() {\n    return Object.getPrototypeOf(this).constructor.symbolicNames || [];\n  }\n\n  getTokenNames() {\n    if (!this.tokenNames) {\n      const literalNames = this.getLiteralNames();\n      const symbolicNames = this.getSymbolicNames();\n      const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;\n      this.tokenNames = [];\n\n      for (let i = 0; i < length; i++) {\n        this.tokenNames[i] = literalNames[i] || symbolicNames[i] || \"<INVALID\";\n      }\n    }\n\n    return this.tokenNames;\n  }\n\n  getTokenTypeMap() {\n    const tokenNames = this.getTokenNames();\n\n    if (tokenNames === null) {\n      throw \"The current recognizer does not provide a list of token names.\";\n    }\n\n    let result = this.tokenTypeMapCache[tokenNames];\n\n    if (result === undefined) {\n      result = tokenNames.reduce(function (o, k, i) {\n        o[k] = i;\n      });\n      result.EOF = Token.EOF;\n      this.tokenTypeMapCache[tokenNames] = result;\n    }\n\n    return result;\n  }\n  /**\n   * Get a map from rule names to rule indexes.\n   * <p>Used for XPath and tree pattern compilation.</p>\n   */\n\n\n  getRuleIndexMap() {\n    const ruleNames = this.ruleNames;\n\n    if (ruleNames === null) {\n      throw \"The current recognizer does not provide a list of rule names.\";\n    }\n\n    let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n\n    if (result === undefined) {\n      result = ruleNames.reduce(function (o, k, i) {\n        o[k] = i;\n      });\n      this.ruleIndexMapCache[ruleNames] = result;\n    }\n\n    return result;\n  }\n\n  getTokenType(tokenName) {\n    const ttype = this.getTokenTypeMap()[tokenName];\n\n    if (ttype !== undefined) {\n      return ttype;\n    } else {\n      return Token.INVALID_TYPE;\n    }\n  } // What is the error header, normally line/character position information?\n\n\n  getErrorHeader(e) {\n    const line = e.getOffendingToken().line;\n    const column = e.getOffendingToken().column;\n    return \"line \" + line + \":\" + column;\n  }\n  /**\n   * How should a token be displayed in an error message? The default\n   * is to display just the text, but during development you might\n   * want to have a lot of information spit out.  Override in that case\n   * to use t.toString() (which, for CommonToken, dumps everything about\n   * the token). This is better than forcing you to override a method in\n   * your token objects because you don't have to go modify your lexer\n   * so that it creates a new Java type.\n   *\n   * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n   * implementations of {@link ANTLRErrorStrategy} may provide a similar\n   * feature when necessary. For example, see\n   * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n\n\n  getTokenErrorDisplay(t) {\n    if (t === null) {\n      return \"<no token>\";\n    }\n\n    let s = t.text;\n\n    if (s === null) {\n      if (t.type === Token.EOF) {\n        s = \"<EOF>\";\n      } else {\n        s = \"<\" + t.type + \">\";\n      }\n    }\n\n    s = s.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\n    return \"'\" + s + \"'\";\n  }\n\n  getErrorListenerDispatch() {\n    return new ProxyErrorListener(this._listeners);\n  }\n  /**\n   * subclass needs to override these if there are sempreds or actions\n   * that the ATN interp needs to execute\n   */\n\n\n  sempred(localctx, ruleIndex, actionIndex) {\n    return true;\n  }\n\n  precpred(localctx, precedence) {\n    return true;\n  }\n\n  get state() {\n    return this._stateNumber;\n  }\n\n  set state(state) {\n    this._stateNumber = state;\n  }\n\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\nmodule.exports = Recognizer;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/Recognizer.js"],"names":["Token","require","ConsoleErrorListener","ProxyErrorListener","Recognizer","constructor","_listeners","INSTANCE","_interp","_stateNumber","checkVersion","toolVersion","runtimeVersion","console","log","addErrorListener","listener","push","removeErrorListeners","getLiteralNames","Object","getPrototypeOf","literalNames","getSymbolicNames","symbolicNames","getTokenNames","tokenNames","length","i","getTokenTypeMap","result","tokenTypeMapCache","undefined","reduce","o","k","EOF","getRuleIndexMap","ruleNames","ruleIndexMapCache","getTokenType","tokenName","ttype","INVALID_TYPE","getErrorHeader","e","line","getOffendingToken","column","getTokenErrorDisplay","t","s","text","type","replace","getErrorListenerDispatch","sempred","localctx","ruleIndex","actionIndex","precpred","precedence","state","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ConsoleErrorListener} = require('./error/ErrorListener');\nconst {ProxyErrorListener} = require('./error/ErrorListener');\n\nclass Recognizer {\n    constructor() {\n        this._listeners = [ ConsoleErrorListener.INSTANCE ];\n        this._interp = null;\n        this._stateNumber = -1;\n    }\n\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.9.3\";\n        if (runtimeVersion!==toolVersion) {\n            console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n        }\n    }\n\n    addErrorListener(listener) {\n        this._listeners.push(listener);\n    }\n\n    removeErrorListeners() {\n        this._listeners = [];\n    }\n\n    getLiteralNames() {\n        return Object.getPrototypeOf(this).constructor.literalNames || [];\n    }\n\n    getSymbolicNames() {\n        return Object.getPrototypeOf(this).constructor.symbolicNames || [];\n    }\n\n    getTokenNames() {\n        if(!this.tokenNames) {\n            const literalNames = this.getLiteralNames();\n            const symbolicNames = this.getSymbolicNames();\n            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;\n            this.tokenNames = [];\n            for(let i=0; i<length; i++) {\n                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || \"<INVALID\";\n            }\n        }\n        return this.tokenNames;\n    }\n\n    getTokenTypeMap() {\n        const tokenNames = this.getTokenNames();\n        if (tokenNames===null) {\n            throw(\"The current recognizer does not provide a list of token names.\");\n        }\n        let result = this.tokenTypeMapCache[tokenNames];\n        if(result===undefined) {\n            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n            result.EOF = Token.EOF;\n            this.tokenTypeMapCache[tokenNames] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Get a map from rule names to rule indexes.\n     * <p>Used for XPath and tree pattern compilation.</p>\n     */\n    getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        if (ruleNames===null) {\n            throw(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n        if(result===undefined) {\n            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n            this.ruleIndexMapCache[ruleNames] = result;\n        }\n        return result;\n    }\n\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap()[tokenName];\n        if (ttype !==undefined) {\n            return ttype;\n        } else {\n            return Token.INVALID_TYPE;\n        }\n    }\n\n    // What is the error header, normally line/character position information?\n    getErrorHeader(e) {\n        const line = e.getOffendingToken().line;\n        const column = e.getOffendingToken().column;\n        return \"line \" + line + \":\" + column;\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out.  Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     *\n     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n     * implementations of {@link ANTLRErrorStrategy} may provide a similar\n     * feature when necessary. For example, see\n     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n    getTokenErrorDisplay(t) {\n        if (t===null) {\n            return \"<no token>\";\n        }\n        let s = t.text;\n        if (s===null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener(this._listeners);\n    }\n\n    /**\n     * subclass needs to override these if there are sempreds or actions\n     * that the ATN interp needs to execute\n     */\n    sempred(localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n\n    precpred(localctx , precedence) {\n        return true;\n    }\n\n    get state(){\n        return this._stateNumber;\n    }\n\n    set state(state) {\n        this._stateNumber = state;\n    }\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\nmodule.exports = Recognizer;\n"]},"metadata":{},"sourceType":"script"}