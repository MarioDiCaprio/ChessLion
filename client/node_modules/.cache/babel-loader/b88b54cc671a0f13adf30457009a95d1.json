{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Set,\n  Hash,\n  equalArrays\n} = require('./../Utils');\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\n\n\nclass SemanticContext {\n  hashCode() {\n    const hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n  }\n  /**\n   * For context independent predicates, we evaluate them without a local\n   * context (i.e., null context). That way, we can evaluate them without\n   * having to create proper rule-specific context during prediction (as\n   * opposed to the parser, which creates them naturally). In a practical\n   * sense, this avoids a cast exception from RuleContext to myruleContext.\n   *\n   * <p>For context dependent predicates, we must pass in a local context so that\n   * references such as $arg evaluate properly as _localctx.arg. We only\n   * capture context dependent predicates in the context in which we begin\n   * prediction, so we passed in the outer context here in case of context\n   * dependent predicate evaluation.</p>\n   */\n\n\n  evaluate(parser, outerContext) {}\n  /**\n   * Evaluate the precedence predicates for the context and reduce the result.\n   *\n   * @param parser The parser instance.\n   * @param outerContext The current parser context object.\n   * @return The simplified semantic context after precedence predicates are\n   * evaluated, which will be one of the following values.\n   * <ul>\n   * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n   * precedence predicates are evaluated.</li>\n   * <li>{@code null}: if the predicate simplifies to {@code false} after\n   * precedence predicates are evaluated.</li>\n   * <li>{@code this}: if the semantic context is not changed as a result of\n   * precedence predicate evaluation.</li>\n   * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n   * semantic context after precedence predicates are evaluated.</li>\n   * </ul>\n   */\n\n\n  evalPrecedence(parser, outerContext) {\n    return this;\n  }\n\n  static andContext(a, b) {\n    if (a === null || a === SemanticContext.NONE) {\n      return b;\n    }\n\n    if (b === null || b === SemanticContext.NONE) {\n      return a;\n    }\n\n    const result = new AND(a, b);\n\n    if (result.opnds.length === 1) {\n      return result.opnds[0];\n    } else {\n      return result;\n    }\n  }\n\n  static orContext(a, b) {\n    if (a === null) {\n      return b;\n    }\n\n    if (b === null) {\n      return a;\n    }\n\n    if (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n      return SemanticContext.NONE;\n    }\n\n    const result = new OR(a, b);\n\n    if (result.opnds.length === 1) {\n      return result.opnds[0];\n    } else {\n      return result;\n    }\n  }\n\n}\n\nclass Predicate extends SemanticContext {\n  constructor(ruleIndex, predIndex, isCtxDependent) {\n    super();\n    this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n    this.predIndex = predIndex === undefined ? -1 : predIndex;\n    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n  }\n\n  evaluate(parser, outerContext) {\n    const localctx = this.isCtxDependent ? outerContext : null;\n    return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof Predicate)) {\n      return false;\n    } else {\n      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;\n    }\n  }\n\n  toString() {\n    return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n  }\n\n}\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\n\n\nSemanticContext.NONE = new Predicate();\n\nclass PrecedencePredicate extends SemanticContext {\n  constructor(precedence) {\n    super();\n    this.precedence = precedence === undefined ? 0 : precedence;\n  }\n\n  evaluate(parser, outerContext) {\n    return parser.precpred(outerContext, this.precedence);\n  }\n\n  evalPrecedence(parser, outerContext) {\n    if (parser.precpred(outerContext, this.precedence)) {\n      return SemanticContext.NONE;\n    } else {\n      return null;\n    }\n  }\n\n  compareTo(other) {\n    return this.precedence - other.precedence;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.precedence);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof PrecedencePredicate)) {\n      return false;\n    } else {\n      return this.precedence === other.precedence;\n    }\n  }\n\n  toString() {\n    return \"{\" + this.precedence + \">=prec}?\";\n  }\n\n  static filterPrecedencePredicates(set) {\n    const result = [];\n    set.values().map(function (context) {\n      if (context instanceof PrecedencePredicate) {\n        result.push(context);\n      }\n    });\n    return result;\n  }\n\n}\n\nclass AND extends SemanticContext {\n  /**\n   * A semantic context which is true whenever none of the contained contexts\n   * is false\n   */\n  constructor(a, b) {\n    super();\n    const operands = new Set();\n\n    if (a instanceof AND) {\n      a.opnds.map(function (o) {\n        operands.add(o);\n      });\n    } else {\n      operands.add(a);\n    }\n\n    if (b instanceof AND) {\n      b.opnds.map(function (o) {\n        operands.add(o);\n      });\n    } else {\n      operands.add(b);\n    }\n\n    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\n    if (precedencePredicates.length > 0) {\n      // interested in the transition with the lowest precedence\n      let reduced = null;\n      precedencePredicates.map(function (p) {\n        if (reduced === null || p.precedence < reduced.precedence) {\n          reduced = p;\n        }\n      });\n      operands.add(reduced);\n    }\n\n    this.opnds = Array.from(operands.values());\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof AND)) {\n      return false;\n    } else {\n      return equalArrays(this.opnds, other.opnds);\n    }\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.opnds, \"AND\");\n  }\n  /**\n   * {@inheritDoc}\n   *\n   * <p>\n   * The evaluation of predicates by this context is short-circuiting, but\n   * unordered.</p>\n   */\n\n\n  evaluate(parser, outerContext) {\n    for (let i = 0; i < this.opnds.length; i++) {\n      if (!this.opnds[i].evaluate(parser, outerContext)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  evalPrecedence(parser, outerContext) {\n    let differs = false;\n    const operands = [];\n\n    for (let i = 0; i < this.opnds.length; i++) {\n      const context = this.opnds[i];\n      const evaluated = context.evalPrecedence(parser, outerContext);\n      differs |= evaluated !== context;\n\n      if (evaluated === null) {\n        // The AND context is false if any element is false\n        return null;\n      } else if (evaluated !== SemanticContext.NONE) {\n        // Reduce the result by skipping true elements\n        operands.push(evaluated);\n      }\n    }\n\n    if (!differs) {\n      return this;\n    }\n\n    if (operands.length === 0) {\n      // all elements were true, so the AND context is true\n      return SemanticContext.NONE;\n    }\n\n    let result = null;\n    operands.map(function (o) {\n      result = result === null ? o : SemanticContext.andContext(result, o);\n    });\n    return result;\n  }\n\n  toString() {\n    const s = this.opnds.map(o => o.toString());\n    return (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n  }\n\n}\n\nclass OR extends SemanticContext {\n  /**\n   * A semantic context which is true whenever at least one of the contained\n   * contexts is true\n   */\n  constructor(a, b) {\n    super();\n    const operands = new Set();\n\n    if (a instanceof OR) {\n      a.opnds.map(function (o) {\n        operands.add(o);\n      });\n    } else {\n      operands.add(a);\n    }\n\n    if (b instanceof OR) {\n      b.opnds.map(function (o) {\n        operands.add(o);\n      });\n    } else {\n      operands.add(b);\n    }\n\n    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\n    if (precedencePredicates.length > 0) {\n      // interested in the transition with the highest precedence\n      const s = precedencePredicates.sort(function (a, b) {\n        return a.compareTo(b);\n      });\n      const reduced = s[s.length - 1];\n      operands.add(reduced);\n    }\n\n    this.opnds = Array.from(operands.values());\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof OR)) {\n      return false;\n    } else {\n      return equalArrays(this.opnds, other.opnds);\n    }\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.opnds, \"OR\");\n  }\n  /**\n   * <p>\n   * The evaluation of predicates by this context is short-circuiting, but\n   * unordered.</p>\n   */\n\n\n  evaluate(parser, outerContext) {\n    for (let i = 0; i < this.opnds.length; i++) {\n      if (this.opnds[i].evaluate(parser, outerContext)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  evalPrecedence(parser, outerContext) {\n    let differs = false;\n    const operands = [];\n\n    for (let i = 0; i < this.opnds.length; i++) {\n      const context = this.opnds[i];\n      const evaluated = context.evalPrecedence(parser, outerContext);\n      differs |= evaluated !== context;\n\n      if (evaluated === SemanticContext.NONE) {\n        // The OR context is true if any element is true\n        return SemanticContext.NONE;\n      } else if (evaluated !== null) {\n        // Reduce the result by skipping false elements\n        operands.push(evaluated);\n      }\n    }\n\n    if (!differs) {\n      return this;\n    }\n\n    if (operands.length === 0) {\n      // all elements were false, so the OR context is false\n      return null;\n    }\n\n    const result = null;\n    operands.map(function (o) {\n      return result === null ? o : SemanticContext.orContext(result, o);\n    });\n    return result;\n  }\n\n  toString() {\n    const s = this.opnds.map(o => o.toString());\n    return (s.length > 3 ? s.slice(3) : s).join(\"||\");\n  }\n\n}\n\nmodule.exports = {\n  SemanticContext,\n  PrecedencePredicate,\n  Predicate\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/SemanticContext.js"],"names":["Set","Hash","equalArrays","require","SemanticContext","hashCode","hash","updateHashCode","finish","evaluate","parser","outerContext","evalPrecedence","andContext","a","b","NONE","result","AND","opnds","length","orContext","OR","Predicate","constructor","ruleIndex","predIndex","isCtxDependent","undefined","localctx","sempred","update","equals","other","toString","PrecedencePredicate","precedence","precpred","compareTo","filterPrecedencePredicates","set","values","map","context","push","operands","o","add","precedencePredicates","reduced","p","Array","from","i","differs","evaluated","s","slice","join","sort","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst { Set, Hash, equalArrays } = require('./../Utils');\n\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\nclass SemanticContext {\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\tthis.updateHashCode(hash);\n\t\treturn hash.finish();\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., null context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * <p>For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.</p>\n\t */\n\tevaluate(parser, outerContext) {}\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param outerContext The current parser context object.\n\t * @return The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t * <ul>\n\t * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code null}: if the predicate simplifies to {@code false} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code this}: if the semantic context is not changed as a result of\n\t * precedence predicate evaluation.</li>\n\t * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n\t * semantic context after precedence predicates are evaluated.</li>\n\t * </ul>\n\t */\n\tevalPrecedence(parser, outerContext) {\n\t\treturn this;\n\t}\n\n\tstatic andContext(a, b) {\n\t\tif (a === null || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null || b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tconst result = new AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic orContext(a, b) {\n\t\tif (a === null) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tconst result = new OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\nclass Predicate extends SemanticContext {\n\n\tconstructor(ruleIndex, predIndex, isCtxDependent) {\n\t\tsuper();\n\t\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\t\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\t\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\tconst localctx = this.isCtxDependent ? outerContext : null;\n\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof Predicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t}\n}\n\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\nSemanticContext.NONE = new Predicate();\n\n\nclass PrecedencePredicate extends SemanticContext {\n\n\tconstructor(precedence) {\n\t\tsuper();\n\t\tthis.precedence = precedence === undefined ? 0 : precedence;\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\treturn parser.precpred(outerContext, this.precedence);\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tif (parser.precpred(outerContext, this.precedence)) {\n\t\t\treturn SemanticContext.NONE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcompareTo(other) {\n\t\treturn this.precedence - other.precedence;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.precedence);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.precedence === other.precedence;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t}\n\n\tstatic filterPrecedencePredicates(set) {\n\t\tconst result = [];\n\t\tset.values().map( function(context) {\n\t\t\tif (context instanceof PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nclass AND extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof AND) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof AND) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = null;\n\t\t\tprecedencePredicates.map( function(p) {\n\t\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\t\treduced = p;\n\t\t\t\t}\n\t\t\t});\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof AND)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"AND\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === null) {\n\t\t\t\t// The AND context is false if any element is false\n\t\t\t\treturn null;\n\t\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were true, so the AND context is true\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result = null;\n\t\toperands.map(function(o) {\n\t\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n\t}\n}\n\n\nclass OR extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof OR) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof OR) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tconst s = precedencePredicates.sort(function(a, b) {\n\t\t\t\treturn a.compareTo(b);\n\t\t\t});\n\t\t\tconst reduced = s[s.length-1];\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof OR)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"OR\");\n\t}\n\n\t/**\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t// The OR context is true if any element is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t} else if (evaluated !== null) {\n\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were false, so the OR context is false\n\t\t\treturn null;\n\t\t}\n\t\tconst result = null;\n\t\toperands.map(function(o) {\n\t\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"||\");\n\t}\n}\n\nmodule.exports = {\n\tSemanticContext,\n\tPrecedencePredicate,\n\tPredicate\n}\n"]},"metadata":{},"sourceType":"script"}