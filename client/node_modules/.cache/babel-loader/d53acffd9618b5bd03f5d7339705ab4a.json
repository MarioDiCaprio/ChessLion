{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\nconst {\n  Token\n} = require('./../Token');\n\nconst {\n  ErrorNode,\n  TerminalNode,\n  RuleNode\n} = require('./Tree');\n/** A set of utility routines useful for all kinds of ANTLR trees. */\n\n\nconst Trees = {\n  /**\n   * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n   *  node payloads to get the text for the nodes.  Detect\n   *  parse trees and extract data appropriately.\n   */\n  toStringTree: function (tree, ruleNames, recog) {\n    ruleNames = ruleNames || null;\n    recog = recog || null;\n\n    if (recog !== null) {\n      ruleNames = recog.ruleNames;\n    }\n\n    let s = Trees.getNodeText(tree, ruleNames);\n    s = Utils.escapeWhitespace(s, false);\n    const c = tree.getChildCount();\n\n    if (c === 0) {\n      return s;\n    }\n\n    let res = \"(\" + s + ' ';\n\n    if (c > 0) {\n      s = Trees.toStringTree(tree.getChild(0), ruleNames);\n      res = res.concat(s);\n    }\n\n    for (let i = 1; i < c; i++) {\n      s = Trees.toStringTree(tree.getChild(i), ruleNames);\n      res = res.concat(' ' + s);\n    }\n\n    res = res.concat(\")\");\n    return res;\n  },\n  getNodeText: function (t, ruleNames, recog) {\n    ruleNames = ruleNames || null;\n    recog = recog || null;\n\n    if (recog !== null) {\n      ruleNames = recog.ruleNames;\n    }\n\n    if (ruleNames !== null) {\n      if (t instanceof RuleNode) {\n        const context = t.getRuleContext();\n        const altNumber = context.getAltNumber(); // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\n        if (altNumber != 0) {\n          return ruleNames[t.ruleIndex] + \":\" + altNumber;\n        }\n\n        return ruleNames[t.ruleIndex];\n      } else if (t instanceof ErrorNode) {\n        return t.toString();\n      } else if (t instanceof TerminalNode) {\n        if (t.symbol !== null) {\n          return t.symbol.text;\n        }\n      }\n    } // no recog for rule names\n\n\n    const payload = t.getPayload();\n\n    if (payload instanceof Token) {\n      return payload.text;\n    }\n\n    return t.getPayload().toString();\n  },\n\n  /**\n   * Return ordered list of all children of this node\n   */\n  getChildren: function (t) {\n    const list = [];\n\n    for (let i = 0; i < t.getChildCount(); i++) {\n      list.push(t.getChild(i));\n    }\n\n    return list;\n  },\n\n  /**\n   * Return a list of all ancestors of this node.  The first node of\n   * list is the root and the last is the parent of this node.\n   */\n  getAncestors: function (t) {\n    let ancestors = [];\n    t = t.getParent();\n\n    while (t !== null) {\n      ancestors = [t].concat(ancestors);\n      t = t.getParent();\n    }\n\n    return ancestors;\n  },\n  findAllTokenNodes: function (t, ttype) {\n    return Trees.findAllNodes(t, ttype, true);\n  },\n  findAllRuleNodes: function (t, ruleIndex) {\n    return Trees.findAllNodes(t, ruleIndex, false);\n  },\n  findAllNodes: function (t, index, findTokens) {\n    const nodes = [];\n\n    Trees._findAllNodes(t, index, findTokens, nodes);\n\n    return nodes;\n  },\n  _findAllNodes: function (t, index, findTokens, nodes) {\n    // check this node (the root) first\n    if (findTokens && t instanceof TerminalNode) {\n      if (t.symbol.type === index) {\n        nodes.push(t);\n      }\n    } else if (!findTokens && t instanceof RuleNode) {\n      if (t.ruleIndex === index) {\n        nodes.push(t);\n      }\n    } // check children\n\n\n    for (let i = 0; i < t.getChildCount(); i++) {\n      Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n    }\n  },\n  descendants: function (t) {\n    let nodes = [t];\n\n    for (let i = 0; i < t.getChildCount(); i++) {\n      nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n    }\n\n    return nodes;\n  }\n};\nmodule.exports = Trees;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/tree/Trees.js"],"names":["Utils","require","Token","ErrorNode","TerminalNode","RuleNode","Trees","toStringTree","tree","ruleNames","recog","s","getNodeText","escapeWhitespace","c","getChildCount","res","getChild","concat","i","t","context","getRuleContext","altNumber","getAltNumber","ruleIndex","toString","symbol","text","payload","getPayload","getChildren","list","push","getAncestors","ancestors","getParent","findAllTokenNodes","ttype","findAllNodes","findAllRuleNodes","index","findTokens","nodes","_findAllNodes","type","descendants","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Token} = require('./../Token');\nconst {ErrorNode, TerminalNode, RuleNode} = require('./Tree');\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nconst Trees = {\n    /**\n     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n     *  node payloads to get the text for the nodes.  Detect\n     *  parse trees and extract data appropriately.\n     */\n    toStringTree: function(tree, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        let s = Trees.getNodeText(tree, ruleNames);\n        s = Utils.escapeWhitespace(s, false);\n        const c = tree.getChildCount();\n        if(c===0) {\n            return s;\n        }\n        let res = \"(\" + s + ' ';\n        if(c>0) {\n            s = Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i=1;i<c;i++) {\n            s = Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(' ' + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    },\n\n    getNodeText: function(t, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        if(ruleNames!==null) {\n            if (t instanceof RuleNode) {\n                const context = t.getRuleContext()\n                const altNumber = context.getAltNumber();\n                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n                if ( altNumber != 0 ) {\n                    return ruleNames[t.ruleIndex]+\":\"+altNumber;\n                }\n                return ruleNames[t.ruleIndex];\n            } else if ( t instanceof ErrorNode) {\n                return t.toString();\n            } else if(t instanceof TerminalNode) {\n                if(t.symbol!==null) {\n                    return t.symbol.text;\n                }\n            }\n        }\n        // no recog for rule names\n        const payload = t.getPayload();\n        if (payload instanceof Token ) {\n            return payload.text;\n        }\n        return t.getPayload().toString();\n    },\n\n    /**\n     * Return ordered list of all children of this node\n     */\n    getChildren: function(t) {\n        const list = [];\n        for(let i=0;i<t.getChildCount();i++) {\n            list.push(t.getChild(i));\n        }\n        return list;\n    },\n\n    /**\n     * Return a list of all ancestors of this node.  The first node of\n     * list is the root and the last is the parent of this node.\n     */\n    getAncestors: function(t) {\n        let ancestors = [];\n        t = t.getParent();\n        while(t!==null) {\n            ancestors = [t].concat(ancestors);\n            t = t.getParent();\n        }\n        return ancestors;\n    },\n\n    findAllTokenNodes: function(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    },\n\n    findAllRuleNodes: function(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    },\n\n    findAllNodes: function(t, index, findTokens) {\n        const nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    },\n\n    _findAllNodes: function(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if(findTokens && (t instanceof TerminalNode)) {\n            if(t.symbol.type===index) {\n                nodes.push(t);\n            }\n        } else if(!findTokens && (t instanceof RuleNode)) {\n            if(t.ruleIndex===index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for(let i=0;i<t.getChildCount();i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    },\n\n    descendants: function(t) {\n        let nodes = [t];\n        for(let i=0;i<t.getChildCount();i++) {\n            nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n        }\n        return nodes;\n    }\n}\n\nmodule.exports = Trees;\n"]},"metadata":{},"sourceType":"script"}