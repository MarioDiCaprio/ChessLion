{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./Token');\n\nrequire('./polyfills/codepointat');\n\nrequire('./polyfills/fromcodepoint');\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\n\n\nclass InputStream {\n  constructor(data, decodeToUnicodeCodePoints) {\n    this.name = \"<empty>\";\n    this.strdata = data;\n    this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false; // _loadString - Vacuum all input from a string and then treat it like a buffer.\n\n    this._index = 0;\n    this.data = [];\n\n    if (this.decodeToUnicodeCodePoints) {\n      for (let i = 0; i < this.strdata.length;) {\n        const codePoint = this.strdata.codePointAt(i);\n        this.data.push(codePoint);\n        i += codePoint <= 0xFFFF ? 1 : 2;\n      }\n    } else {\n      this.data = new Array(this.strdata.length);\n\n      for (let i = 0; i < this.strdata.length; i++) {\n        const codeUnit = this.strdata.charCodeAt(i);\n        this.data[i] = codeUnit;\n      }\n    }\n\n    this._size = this.data.length;\n  }\n  /**\n   * Reset the stream so that it's in the same state it was\n   * when the object was created *except* the data array is not\n   * touched.\n   */\n\n\n  reset() {\n    this._index = 0;\n  }\n\n  consume() {\n    if (this._index >= this._size) {\n      // assert this.LA(1) == Token.EOF\n      throw \"cannot consume EOF\";\n    }\n\n    this._index += 1;\n  }\n\n  LA(offset) {\n    if (offset === 0) {\n      return 0; // undefined\n    }\n\n    if (offset < 0) {\n      offset += 1; // e.g., translate LA(-1) to use offset=0\n    }\n\n    const pos = this._index + offset - 1;\n\n    if (pos < 0 || pos >= this._size) {\n      // invalid\n      return Token.EOF;\n    }\n\n    return this.data[pos];\n  }\n\n  LT(offset) {\n    return this.LA(offset);\n  } // mark/release do nothing; we have entire buffer\n\n\n  mark() {\n    return -1;\n  }\n\n  release(marker) {}\n  /**\n   * consume() ahead until p==_index; can't just set p=_index as we must\n   * update line and column. If we seek backwards, just set p\n   */\n\n\n  seek(_index) {\n    if (_index <= this._index) {\n      this._index = _index; // just jump; don't update stream state (line,\n      // ...)\n\n      return;\n    } // seek forward\n\n\n    this._index = Math.min(_index, this._size);\n  }\n\n  getText(start, stop) {\n    if (stop >= this._size) {\n      stop = this._size - 1;\n    }\n\n    if (start >= this._size) {\n      return \"\";\n    } else {\n      if (this.decodeToUnicodeCodePoints) {\n        let result = \"\";\n\n        for (let i = start; i <= stop; i++) {\n          result += String.fromCodePoint(this.data[i]);\n        }\n\n        return result;\n      } else {\n        return this.strdata.slice(start, stop + 1);\n      }\n    }\n  }\n\n  toString() {\n    return this.strdata;\n  }\n\n  get index() {\n    return this._index;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n}\n\nmodule.exports = InputStream;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/InputStream.js"],"names":["Token","require","InputStream","constructor","data","decodeToUnicodeCodePoints","name","strdata","_index","i","length","codePoint","codePointAt","push","Array","codeUnit","charCodeAt","_size","reset","consume","LA","offset","pos","EOF","LT","mark","release","marker","seek","Math","min","getText","start","stop","result","String","fromCodePoint","slice","toString","index","size","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nrequire('./polyfills/codepointat');\nrequire('./polyfills/fromcodepoint');\n\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\nclass InputStream {\n\tconstructor(data, decodeToUnicodeCodePoints) {\n\t\tthis.name = \"<empty>\";\n\t\tthis.strdata = data;\n\t\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t\t// _loadString - Vacuum all input from a string and then treat it like a buffer.\n\t\tthis._index = 0;\n\t\tthis.data = [];\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tfor (let i = 0; i < this.strdata.length; ) {\n\t\t\t\tconst codePoint = this.strdata.codePointAt(i);\n\t\t\t\tthis.data.push(codePoint);\n\t\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.data = new Array(this.strdata.length);\n\t\t\tfor (let i = 0; i < this.strdata.length; i++) {\n\t\t\t\tconst codeUnit = this.strdata.charCodeAt(i);\n\t\t\t\tthis.data[i] = codeUnit;\n\t\t\t}\n\t\t}\n\t\tthis._size = this.data.length;\n\t}\n\n\t/**\n\t * Reset the stream so that it's in the same state it was\n\t * when the object was created *except* the data array is not\n\t * touched.\n\t */\n\treset() {\n\t\tthis._index = 0;\n\t}\n\n\tconsume() {\n\t\tif (this._index >= this._size) {\n\t\t\t// assert this.LA(1) == Token.EOF\n\t\t\tthrow (\"cannot consume EOF\");\n\t\t}\n\t\tthis._index += 1;\n\t}\n\n\tLA(offset) {\n\t\tif (offset === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (offset < 0) {\n\t\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t\t}\n\t\tconst pos = this._index + offset - 1;\n\t\tif (pos < 0 || pos >= this._size) { // invalid\n\t\t\treturn Token.EOF;\n\t\t}\n\t\treturn this.data[pos];\n\t}\n\n\tLT(offset) {\n\t\treturn this.LA(offset);\n\t}\n\n// mark/release do nothing; we have entire buffer\n\tmark() {\n\t\treturn -1;\n\t}\n\n\trelease(marker) {\n\t}\n\n\t/**\n\t * consume() ahead until p==_index; can't just set p=_index as we must\n\t * update line and column. If we seek backwards, just set p\n\t */\n\tseek(_index) {\n\t\tif (_index <= this._index) {\n\t\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t\t// ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward\n\t\tthis._index = Math.min(_index, this._size);\n\t}\n\n\tgetText(start, stop) {\n\t\tif (stop >= this._size) {\n\t\t\tstop = this._size - 1;\n\t\t}\n\t\tif (start >= this._size) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\t\tlet result = \"\";\n\t\t\t\tfor (let i = start; i <= stop; i++) {\n\t\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.strdata;\n\t}\n\n\tget index(){\n\t\treturn this._index;\n\t}\n\n\tget size(){\n\t\treturn this._size;\n\t}\n}\n\n\nmodule.exports = InputStream;\n"]},"metadata":{},"sourceType":"script"}