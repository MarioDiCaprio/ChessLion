{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Set,\n  BitSet\n} = require('./Utils');\n\nconst {\n  Token\n} = require('./Token');\n\nconst {\n  ATNConfig\n} = require('./atn/ATNConfig');\n\nconst {\n  IntervalSet\n} = require('./IntervalSet');\n\nconst {\n  RuleStopState\n} = require('./atn/ATNState');\n\nconst {\n  RuleTransition,\n  NotSetTransition,\n  WildcardTransition,\n  AbstractPredicateTransition\n} = require('./atn/Transition');\n\nconst {\n  predictionContextFromRuleContext,\n  PredictionContext,\n  SingletonPredictionContext\n} = require('./PredictionContext');\n\nclass LL1Analyzer {\n  constructor(atn) {\n    this.atn = atn;\n  }\n  /**\n   * Calculates the SLL(1) expected lookahead set for each outgoing transition\n   * of an {@link ATNState}. The returned array has one element for each\n   * outgoing transition in {@code s}. If the closure from transition\n   * <em>i</em> leads to a semantic predicate before matching a symbol, the\n   * element at index <em>i</em> of the result will be {@code null}.\n   *\n   * @param s the ATN state\n   * @return the expected symbols for each outgoing transition of {@code s}.\n   */\n\n\n  getDecisionLookahead(s) {\n    if (s === null) {\n      return null;\n    }\n\n    const count = s.transitions.length;\n    const look = [];\n\n    for (let alt = 0; alt < count; alt++) {\n      look[alt] = new IntervalSet();\n      const lookBusy = new Set();\n      const seeThruPreds = false; // fail to get lookahead upon pred\n\n      this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false); // Wipe out lookahead for this alternative if we found nothing\n      // or we had a predicate when we !seeThruPreds\n\n\n      if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n        look[alt] = null;\n      }\n    }\n\n    return look;\n  }\n  /**\n   * Compute set of tokens that can follow {@code s} in the ATN in the\n   * specified {@code ctx}.\n   *\n   * <p>If {@code ctx} is {@code null} and the end of the rule containing\n   * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n   * If {@code ctx} is not {@code null} and the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.</p>\n   *\n   * @param s the ATN state\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx the complete parser context, or {@code null} if the context\n   * should be ignored\n   *\n   * @return The set of tokens that can follow {@code s} in the ATN in the\n   * specified {@code ctx}.\n   */\n\n\n  LOOK(s, stopState, ctx) {\n    const r = new IntervalSet();\n    const seeThruPreds = true; // ignore preds; get all lookahead\n\n    ctx = ctx || null;\n    const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n\n    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n\n    return r;\n  }\n  /**\n   * Compute set of tokens that can follow {@code s} in the ATN in the\n   * specified {@code ctx}.\n   *\n   * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n   * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n   * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n   * {@code true} and {@code stopState} or the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.</p>\n   *\n   * @param s the ATN state.\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx The outer context, or {@code null} if the outer context should\n   * not be used.\n   * @param look The result lookahead set.\n   * @param lookBusy A set used for preventing epsilon closures in the ATN\n   * from causing a stack overflow. Outside code should pass\n   * {@code new Set<ATNConfig>} for this argument.\n   * @param calledRuleStack A set used for preventing left recursion in the\n   * ATN from causing a stack overflow. Outside code should pass\n   * {@code new BitSet()} for this argument.\n   * @param seeThruPreds {@code true} to true semantic predicates as\n   * implicitly {@code true} and \"see through them\", otherwise {@code false}\n   * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n   * result if one is encountered.\n   * @param addEOF Add {@link Token//EOF} to the result if the end of the\n   * outermost context is reached. This parameter has no effect if {@code ctx}\n   * is {@code null}.\n   */\n\n\n  _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n    const c = new ATNConfig({\n      state: s,\n      alt: 0,\n      context: ctx\n    }, null);\n\n    if (lookBusy.contains(c)) {\n      return;\n    }\n\n    lookBusy.add(c);\n\n    if (s === stopState) {\n      if (ctx === null) {\n        look.addOne(Token.EPSILON);\n        return;\n      } else if (ctx.isEmpty() && addEOF) {\n        look.addOne(Token.EOF);\n        return;\n      }\n    }\n\n    if (s instanceof RuleStopState) {\n      if (ctx === null) {\n        look.addOne(Token.EPSILON);\n        return;\n      } else if (ctx.isEmpty() && addEOF) {\n        look.addOne(Token.EOF);\n        return;\n      }\n\n      if (ctx !== PredictionContext.EMPTY) {\n        const removed = calledRuleStack.contains(s.ruleIndex);\n\n        try {\n          calledRuleStack.remove(s.ruleIndex); // run thru all possible stack tops in ctx\n\n          for (let i = 0; i < ctx.length; i++) {\n            const returnState = this.atn.states[ctx.getReturnState(i)];\n\n            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          }\n        } finally {\n          if (removed) {\n            calledRuleStack.add(s.ruleIndex);\n          }\n        }\n\n        return;\n      }\n    }\n\n    for (let j = 0; j < s.transitions.length; j++) {\n      const t = s.transitions[j];\n\n      if (t.constructor === RuleTransition) {\n        if (calledRuleStack.contains(t.target.ruleIndex)) {\n          continue;\n        }\n\n        const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n\n        try {\n          calledRuleStack.add(t.target.ruleIndex);\n\n          this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } finally {\n          calledRuleStack.remove(t.target.ruleIndex);\n        }\n      } else if (t instanceof AbstractPredicateTransition) {\n        if (seeThruPreds) {\n          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else {\n          look.addOne(LL1Analyzer.HIT_PRED);\n        }\n      } else if (t.isEpsilon) {\n        this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n      } else if (t.constructor === WildcardTransition) {\n        look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n      } else {\n        let set = t.label;\n\n        if (set !== null) {\n          if (t instanceof NotSetTransition) {\n            set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n          }\n\n          look.addSet(set);\n        }\n      }\n    }\n  }\n\n}\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\n\n\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\nmodule.exports = LL1Analyzer;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/LL1Analyzer.js"],"names":["Set","BitSet","require","Token","ATNConfig","IntervalSet","RuleStopState","RuleTransition","NotSetTransition","WildcardTransition","AbstractPredicateTransition","predictionContextFromRuleContext","PredictionContext","SingletonPredictionContext","LL1Analyzer","constructor","atn","getDecisionLookahead","s","count","transitions","length","look","alt","lookBusy","seeThruPreds","_LOOK","transition","target","EMPTY","contains","HIT_PRED","LOOK","stopState","ctx","r","lookContext","calledRuleStack","addEOF","c","state","context","add","addOne","EPSILON","isEmpty","EOF","removed","ruleIndex","remove","i","returnState","states","getReturnState","getParent","j","t","newContext","create","followState","stateNumber","isEpsilon","addRange","MIN_USER_TOKEN_TYPE","maxTokenType","set","label","complement","addSet","INVALID_TYPE","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set, BitSet} = require('./Utils');\nconst {Token} = require('./Token');\nconst {ATNConfig} = require('./atn/ATNConfig');\nconst {IntervalSet} = require('./IntervalSet');\nconst {RuleStopState} = require('./atn/ATNState');\nconst {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require('./atn/Transition');\nconst {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require('./PredictionContext');\n\nclass LL1Analyzer {\n    constructor(atn) {\n        this.atn = atn;\n    }\n\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in {@code s}. If the closure from transition\n     * <em>i</em> leads to a semantic predicate before matching a symbol, the\n     * element at index <em>i</em> of the result will be {@code null}.\n     *\n     * @param s the ATN state\n     * @return the expected symbols for each outgoing transition of {@code s}.\n     */\n    getDecisionLookahead(s) {\n        if (s === null) {\n            return null;\n        }\n        const count = s.transitions.length;\n        const look = [];\n        for(let alt=0; alt< count; alt++) {\n            look[alt] = new IntervalSet();\n            const lookBusy = new Set();\n            const seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n                look[alt] = null;\n            }\n        }\n        return look;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and the end of the rule containing\n     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n     * If {@code ctx} is not {@code null} and the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx the complete parser context, or {@code null} if the context\n     * should be ignored\n     *\n     * @return The set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     */\n    LOOK(s, stopState, ctx) {\n        const r = new IntervalSet();\n        const seeThruPreds = true; // ignore preds; get all lookahead\n        ctx = ctx || null;\n        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n        this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n        return r;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n     * {@code true} and {@code stopState} or the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@code null} if the outer context should\n     * not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * {@code new Set<ATNConfig>} for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * {@code new BitSet()} for this argument.\n     * @param seeThruPreds {@code true} to true semantic predicates as\n     * implicitly {@code true} and \"see through them\", otherwise {@code false}\n     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token//EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if {@code ctx}\n     * is {@code null}.\n     */\n    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n        if (lookBusy.contains(c)) {\n            return;\n        }\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n        }\n        if (s instanceof RuleStopState ) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n            if (ctx !== PredictionContext.EMPTY) {\n                const removed = calledRuleStack.contains(s.ruleIndex);\n                try {\n                    calledRuleStack.remove(s.ruleIndex);\n                    // run thru all possible stack tops in ctx\n                    for (let i = 0; i < ctx.length; i++) {\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                }finally {\n                    if (removed) {\n                        calledRuleStack.add(s.ruleIndex);\n                    }\n                }\n                return;\n            }\n        }\n        for(let j=0; j<s.transitions.length; j++) {\n            const t = s.transitions[j];\n            if (t.constructor === RuleTransition) {\n                if (calledRuleStack.contains(t.target.ruleIndex)) {\n                    continue;\n                }\n                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n                try {\n                    calledRuleStack.add(t.target.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    calledRuleStack.remove(t.target.ruleIndex);\n                }\n            } else if (t instanceof AbstractPredicateTransition ) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } else {\n                    look.addOne(LL1Analyzer.HIT_PRED);\n                }\n            } else if( t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else if (t.constructor === WildcardTransition) {\n                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n            } else {\n                let set = t.label;\n                if (set !== null) {\n                    if (t instanceof NotSetTransition) {\n                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                    }\n                    look.addSet(set);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\nmodule.exports = LL1Analyzer;\n\n"]},"metadata":{},"sourceType":"script"}