{"ast":null,"code":"import antlr4 from 'antlr4';\nimport pgnLexer from './.antlr/pgnLexer';\nimport pgnParser from './.antlr/pgnParser';\nexport function parsePgn(input) {\n  const chars = new antlr4.InputStream(input);\n  const lexer = new pgnLexer(chars);\n  const tokens = new antlr4.CommonTokenStream(lexer);\n  const parser = new pgnParser(tokens);\n  parser.game();\n  return {\n    tags: parser.tags,\n    moves: parser.moves\n  };\n}\nexport default class Pgn {\n  constructor(pgn) {\n    this.tags = {};\n    this.moves = [];\n\n    this.parse = input => {\n      const tmp = parsePgn(input);\n      this.tags = tmp.tags;\n      this.moves = tmp.moves;\n    };\n\n    this.addMove = input => {\n      if (typeof input === 'string') {\n        let tmp = parsePgn(input);\n        this.addMove(tmp.moves[0][0]);\n      } else {\n        if (this.moves.length === 0) {\n          this.moves.push([input, {}]);\n          return;\n        }\n\n        let lastMove = this.moves[this.moves.length - 1][1];\n        if (lastMove.move === undefined && lastMove.glyph === undefined && lastMove.comment === undefined) this.moves[this.moves.length - 1][1] = input;else this.moves.push([input, {}]);\n      }\n    };\n\n    this.toString = () => {\n      const tags = [];\n\n      for (let tag in this.tags) {\n        tags.push('[' + tag + ' \"' + this.tags[tag] + '\"');\n      }\n\n      const moves = [];\n\n      for (let i = 0; i < this.moves.length; i++) {\n        let tmp = '' + (i + 1);\n\n        for (let move of this.moves[i]) {\n          if (move.move !== undefined) tmp += ' ' + move.move;\n          if (move.glyph !== undefined) tmp += move.glyph;\n          if (move.comment !== undefined) tmp += ' {' + move.comment + '}';\n        }\n\n        moves.push(tmp);\n      }\n\n      return tags.join('\\n') + '\\n' + moves.join('\\n');\n    };\n\n    if (pgn !== undefined) {\n      if (typeof pgn === 'string') {\n        this.parse(pgn);\n      } else {\n        this.tags = pgn.tags;\n        this.moves = pgn.moves;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/src/utils/pgn/pgnParser.ts"],"names":["antlr4","pgnLexer","pgnParser","parsePgn","input","chars","InputStream","lexer","tokens","CommonTokenStream","parser","game","tags","moves","Pgn","constructor","pgn","parse","tmp","addMove","length","push","lastMove","move","undefined","glyph","comment","toString","tag","i","join"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AAcA,OAAO,SAASC,QAAT,CAAkBC,KAAlB,EAA4C;AAC/C,QAAMC,KAAK,GAAG,IAAIL,MAAM,CAACM,WAAX,CAAuBF,KAAvB,CAAd;AACA,QAAMG,KAAK,GAAG,IAAIN,QAAJ,CAAaI,KAAb,CAAd;AACA,QAAMG,MAAM,GAAG,IAAIR,MAAM,CAACS,iBAAX,CAA6BF,KAA7B,CAAf;AACA,QAAMG,MAAM,GAAG,IAAIR,SAAJ,CAAcM,MAAd,CAAf;AACAE,EAAAA,MAAM,CAACC,IAAP;AAEA,SAAO;AACHC,IAAAA,IAAI,EAAEF,MAAM,CAACE,IADV;AAEHC,IAAAA,KAAK,EAAEH,MAAM,CAACG;AAFX,GAAP;AAIH;AAGD,eAAe,MAAMC,GAAN,CAA+B;AAI1CC,EAAAA,WAAW,CAACC,GAAD,EAA2B;AAAA,SAHtCJ,IAGsC,GAHH,EAGG;AAAA,SAFtCC,KAEsC,GAFd,EAEc;;AAAA,SAWtCI,KAXsC,GAW7Bb,KAAD,IAAyB;AAC7B,YAAMc,GAAG,GAAGf,QAAQ,CAACC,KAAD,CAApB;AACA,WAAKQ,IAAL,GAAYM,GAAG,CAACN,IAAhB;AACA,WAAKC,KAAL,GAAaK,GAAG,CAACL,KAAjB;AACH,KAfqC;;AAAA,SAiBtCM,OAjBsC,GAiB3Bf,KAAD,IAAgC;AACtC,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,YAAIc,GAAG,GAAGf,QAAQ,CAACC,KAAD,CAAlB;AACA,aAAKe,OAAL,CAAaD,GAAG,CAACL,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAb;AACH,OAHD,MAGO;AACH,YAAI,KAAKA,KAAL,CAAWO,MAAX,KAAsB,CAA1B,EAA6B;AACzB,eAAKP,KAAL,CAAWQ,IAAX,CAAgB,CAACjB,KAAD,EAAQ,EAAR,CAAhB;AACA;AACH;;AACD,YAAIkB,QAAQ,GAAG,KAAKT,KAAL,CAAW,KAAKA,KAAL,CAAWO,MAAX,GAAkB,CAA7B,EAAgC,CAAhC,CAAf;AACA,YAAIE,QAAQ,CAACC,IAAT,KAAkBC,SAAlB,IAA+BF,QAAQ,CAACG,KAAT,KAAmBD,SAAlD,IAA+DF,QAAQ,CAACI,OAAT,KAAqBF,SAAxF,EACI,KAAKX,KAAL,CAAW,KAAKA,KAAL,CAAWO,MAAX,GAAkB,CAA7B,EAAgC,CAAhC,IAAqChB,KAArC,CADJ,KAGI,KAAKS,KAAL,CAAWQ,IAAX,CAAgB,CAACjB,KAAD,EAAQ,EAAR,CAAhB;AACP;AACJ,KAhCqC;;AAAA,SAkCtCuB,QAlCsC,GAkC3B,MAAc;AACrB,YAAMf,IAAmB,GAAG,EAA5B;;AACA,WAAK,IAAIgB,GAAT,IAAgB,KAAKhB,IAArB,EAA2B;AACvBA,QAAAA,IAAI,CAACS,IAAL,CAAU,MAAMO,GAAN,GAAY,IAAZ,GAAmB,KAAKhB,IAAL,CAAUgB,GAAV,CAAnB,GAAoC,GAA9C;AACH;;AAED,YAAMf,KAAoB,GAAG,EAA7B;;AACA,WAAK,IAAIgB,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAC,KAAKhB,KAAL,CAAWO,MAA3B,EAAmCS,CAAC,EAApC,EAAwC;AACpC,YAAIX,GAAG,GAAG,MAAMW,CAAC,GAAG,CAAV,CAAV;;AACA,aAAK,IAAIN,IAAT,IAAiB,KAAKV,KAAL,CAAWgB,CAAX,CAAjB,EAAgC;AAC5B,cAAIN,IAAI,CAACA,IAAL,KAAcC,SAAlB,EACIN,GAAG,IAAI,MAAMK,IAAI,CAACA,IAAlB;AACJ,cAAIA,IAAI,CAACE,KAAL,KAAeD,SAAnB,EACIN,GAAG,IAAIK,IAAI,CAACE,KAAZ;AACJ,cAAIF,IAAI,CAACG,OAAL,KAAiBF,SAArB,EACIN,GAAG,IAAI,OAAOK,IAAI,CAACG,OAAZ,GAAsB,GAA7B;AACP;;AACDb,QAAAA,KAAK,CAACQ,IAAN,CAAWH,GAAX;AACH;;AAED,aAAON,IAAI,CAACkB,IAAL,CAAU,IAAV,IAAkB,IAAlB,GAAyBjB,KAAK,CAACiB,IAAN,CAAW,IAAX,CAAhC;AACH,KAvDqC;;AAClC,QAAId,GAAG,KAAKQ,SAAZ,EAAuB;AACnB,UAAI,OAAOR,GAAP,KAAe,QAAnB,EAA6B;AACzB,aAAKC,KAAL,CAAWD,GAAX;AACH,OAFD,MAEO;AACH,aAAKJ,IAAL,GAAYI,GAAG,CAACJ,IAAhB;AACA,aAAKC,KAAL,GAAaG,GAAG,CAACH,KAAjB;AACH;AACJ;AACJ;;AAbyC","sourcesContent":["import antlr4 from 'antlr4';\nimport pgnLexer from './.antlr/pgnLexer';\nimport pgnParser from './.antlr/pgnParser';\n\n\nexport interface Move {\n    move?: string;\n    glyph?: string;\n    comment?: string;\n}\n\nexport interface PgnObject {\n    tags: { [key: string]: string };\n    moves: Array<[Move, Move]>;\n}\n\nexport function parsePgn(input: string): PgnObject {\n    const chars = new antlr4.InputStream(input);\n    const lexer = new pgnLexer(chars);\n    const tokens = new antlr4.CommonTokenStream(lexer);\n    const parser = new pgnParser(tokens);\n    parser.game();\n\n    return {\n        tags: parser.tags,\n        moves: parser.moves,\n    }\n}\n\n\nexport default class Pgn implements PgnObject {\n    tags: { [key: string]: string; } = {};\n    moves: [Move, Move][] = [];\n\n    constructor(pgn?: string | PgnObject) {\n        if (pgn !== undefined) {\n            if (typeof pgn === 'string') {\n                this.parse(pgn);\n            } else {\n                this.tags = pgn.tags;\n                this.moves = pgn.moves;\n            }\n        }\n    }\n\n    parse = (input: string): void => {\n        const tmp = parsePgn(input);\n        this.tags = tmp.tags;\n        this.moves = tmp.moves;\n    }\n\n    addMove = (input: string | Move): void => {\n        if (typeof input === 'string') {\n            let tmp = parsePgn(input);\n            this.addMove(tmp.moves[0][0]);\n        } else {\n            if (this.moves.length === 0) {\n                this.moves.push([input, {}]);\n                return;\n            }\n            let lastMove = this.moves[this.moves.length-1][1];\n            if (lastMove.move === undefined && lastMove.glyph === undefined && lastMove.comment === undefined)\n                this.moves[this.moves.length-1][1] = input;\n            else\n                this.moves.push([input, {}]);\n        }\n    }\n\n    toString = (): string => {\n        const tags: Array<string> = [];\n        for (let tag in this.tags) {\n            tags.push('[' + tag + ' \"' + this.tags[tag] + '\"');\n        }\n\n        const moves: Array<string> = [];\n        for (let i=0; i<this.moves.length; i++) {\n            let tmp = '' + (i + 1);\n            for (let move of this.moves[i]) {\n                if (move.move !== undefined)\n                    tmp += ' ' + move.move;\n                if (move.glyph !== undefined)\n                    tmp += move.glyph;\n                if (move.comment !== undefined)\n                    tmp += ' {' + move.comment + '}';\n            }\n            moves.push(tmp);\n        }\n\n        return tags.join('\\n') + '\\n' + moves.join('\\n');\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}