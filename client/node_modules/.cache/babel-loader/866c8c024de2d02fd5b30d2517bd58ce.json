{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst LexerActionType = {\n  // The type of a {@link LexerChannelAction} action.\n  CHANNEL: 0,\n  // The type of a {@link LexerCustomAction} action\n  CUSTOM: 1,\n  // The type of a {@link LexerModeAction} action.\n  MODE: 2,\n  //The type of a {@link LexerMoreAction} action.\n  MORE: 3,\n  //The type of a {@link LexerPopModeAction} action.\n  POP_MODE: 4,\n  //The type of a {@link LexerPushModeAction} action.\n  PUSH_MODE: 5,\n  //The type of a {@link LexerSkipAction} action.\n  SKIP: 6,\n  //The type of a {@link LexerTypeAction} action.\n  TYPE: 7\n};\n\nclass LexerAction {\n  constructor(action) {\n    this.actionType = action;\n    this.isPositionDependent = false;\n  }\n\n  hashCode() {\n    const hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType);\n  }\n\n  equals(other) {\n    return this === other;\n  }\n\n}\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\n\n\nclass LexerSkipAction extends LexerAction {\n  constructor() {\n    super(LexerActionType.SKIP);\n  }\n\n  execute(lexer) {\n    lexer.skip();\n  }\n\n  toString() {\n    return \"skip\";\n  }\n\n} // Provides a singleton instance of this parameterless lexer action.\n\n\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\n\nclass LexerTypeAction extends LexerAction {\n  constructor(type) {\n    super(LexerActionType.TYPE);\n    this.type = type;\n  }\n\n  execute(lexer) {\n    lexer.type = this.type;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.type);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerTypeAction)) {\n      return false;\n    } else {\n      return this.type === other.type;\n    }\n  }\n\n  toString() {\n    return \"type(\" + this.type + \")\";\n  }\n\n}\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\n\n\nclass LexerPushModeAction extends LexerAction {\n  constructor(mode) {\n    super(LexerActionType.PUSH_MODE);\n    this.mode = mode;\n  }\n  /**\n   * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n   * value provided by {@link //getMode}.</p>\n   */\n\n\n  execute(lexer) {\n    lexer.pushMode(this.mode);\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.mode);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerPushModeAction)) {\n      return false;\n    } else {\n      return this.mode === other.mode;\n    }\n  }\n\n  toString() {\n    return \"pushMode(\" + this.mode + \")\";\n  }\n\n}\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\n\n\nclass LexerPopModeAction extends LexerAction {\n  constructor() {\n    super(LexerActionType.POP_MODE);\n  }\n  /**\n   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n   */\n\n\n  execute(lexer) {\n    lexer.popMode();\n  }\n\n  toString() {\n    return \"popMode\";\n  }\n\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\n\nclass LexerMoreAction extends LexerAction {\n  constructor() {\n    super(LexerActionType.MORE);\n  }\n  /**\n   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n   */\n\n\n  execute(lexer) {\n    lexer.more();\n  }\n\n  toString() {\n    return \"more\";\n  }\n\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\n\nclass LexerModeAction extends LexerAction {\n  constructor(mode) {\n    super(LexerActionType.MODE);\n    this.mode = mode;\n  }\n  /**\n   * <p>This action is implemented by calling {@link Lexer//mode} with the\n   * value provided by {@link //getMode}.</p>\n   */\n\n\n  execute(lexer) {\n    lexer.mode(this.mode);\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.mode);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerModeAction)) {\n      return false;\n    } else {\n      return this.mode === other.mode;\n    }\n  }\n\n  toString() {\n    return \"mode(\" + this.mode + \")\";\n  }\n\n}\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\n\n\nclass LexerCustomAction extends LexerAction {\n  /**\n   * Constructs a custom lexer action with the specified rule and action\n   * indexes.\n   *\n   * @param ruleIndex The rule index to use for calls to\n   * {@link Recognizer//action}.\n   * @param actionIndex The action index to use for calls to\n   * {@link Recognizer//action}.\n   */\n  constructor(ruleIndex, actionIndex) {\n    super(LexerActionType.CUSTOM);\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex;\n    this.isPositionDependent = true;\n  }\n  /**\n   * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n   * appropriate rule and action indexes.</p>\n   */\n\n\n  execute(lexer) {\n    lexer.action(null, this.ruleIndex, this.actionIndex);\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerCustomAction)) {\n      return false;\n    } else {\n      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n    }\n  }\n\n}\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\n\n\nclass LexerChannelAction extends LexerAction {\n  constructor(channel) {\n    super(LexerActionType.CHANNEL);\n    this.channel = channel;\n  }\n  /**\n   * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n   * value provided by {@link //getChannel}.</p>\n   */\n\n\n  execute(lexer) {\n    lexer._channel = this.channel;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.channel);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerChannelAction)) {\n      return false;\n    } else {\n      return this.channel === other.channel;\n    }\n  }\n\n  toString() {\n    return \"channel(\" + this.channel + \")\";\n  }\n\n}\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\n\n\nclass LexerIndexedCustomAction extends LexerAction {\n  constructor(offset, action) {\n    super(action.actionType);\n    this.offset = offset;\n    this.action = action;\n    this.isPositionDependent = true;\n  }\n  /**\n   * <p>This method calls {@link //execute} on the result of {@link //getAction}\n   * using the provided {@code lexer}.</p>\n   */\n\n\n  execute(lexer) {\n    // assume the input stream position was properly set by the calling code\n    this.action.execute(lexer);\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.actionType, this.offset, this.action);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerIndexedCustomAction)) {\n      return false;\n    } else {\n      return this.offset === other.offset && this.action === other.action;\n    }\n  }\n\n}\n\nmodule.exports = {\n  LexerActionType,\n  LexerSkipAction,\n  LexerChannelAction,\n  LexerCustomAction,\n  LexerIndexedCustomAction,\n  LexerMoreAction,\n  LexerTypeAction,\n  LexerPushModeAction,\n  LexerPopModeAction,\n  LexerModeAction\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/LexerAction.js"],"names":["LexerActionType","CHANNEL","CUSTOM","MODE","MORE","POP_MODE","PUSH_MODE","SKIP","TYPE","LexerAction","constructor","action","actionType","isPositionDependent","hashCode","hash","Hash","updateHashCode","finish","update","equals","other","LexerSkipAction","execute","lexer","skip","toString","INSTANCE","LexerTypeAction","type","LexerPushModeAction","mode","pushMode","LexerPopModeAction","popMode","LexerMoreAction","more","LexerModeAction","LexerCustomAction","ruleIndex","actionIndex","LexerChannelAction","channel","_channel","LexerIndexedCustomAction","offset","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LexerActionType = {\n    // The type of a {@link LexerChannelAction} action.\n    CHANNEL: 0,\n    // The type of a {@link LexerCustomAction} action\n    CUSTOM: 1,\n    // The type of a {@link LexerModeAction} action.\n    MODE: 2,\n    //The type of a {@link LexerMoreAction} action.\n    MORE: 3,\n    //The type of a {@link LexerPopModeAction} action.\n    POP_MODE: 4,\n    //The type of a {@link LexerPushModeAction} action.\n    PUSH_MODE: 5,\n    //The type of a {@link LexerSkipAction} action.\n    SKIP: 6,\n    //The type of a {@link LexerTypeAction} action.\n    TYPE: 7\n}\n\nclass LexerAction {\n    constructor(action) {\n        this.actionType = action;\n        this.isPositionDependent = false;\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish()\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType);\n    }\n\n    equals(other) {\n        return this === other;\n    }\n}\n\n\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerSkipAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.SKIP);\n    }\n\n    execute(lexer) {\n        lexer.skip();\n    }\n\n    toString() {\n        return \"skip\";\n    }\n}\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\nclass LexerTypeAction extends LexerAction {\n    constructor(type) {\n        super(LexerActionType.TYPE);\n        this.type = type;\n    }\n\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.type);\n    }\n\n    equals(other) {\n        if(this === other) {\n            return true;\n        } else if (! (other instanceof LexerTypeAction)) {\n            return false;\n        } else {\n            return this.type === other.type;\n        }\n    }\n\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n}\n\n\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\nclass LexerPushModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.PUSH_MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerPushModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerPopModeAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.POP_MODE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.popMode();\n    }\n\n    toString() {\n        return \"popMode\";\n    }\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerMoreAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.MORE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.more();\n    }\n\n    toString() {\n        return \"more\";\n    }\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\nclass LexerModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//mode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.mode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\nclass LexerCustomAction extends LexerAction {\n    /**\n     * Constructs a custom lexer action with the specified rule and action\n     * indexes.\n     *\n     * @param ruleIndex The rule index to use for calls to\n     * {@link Recognizer//action}.\n     * @param actionIndex The action index to use for calls to\n     * {@link Recognizer//action}.\n     */\n    constructor(ruleIndex, actionIndex) {\n        super(LexerActionType.CUSTOM);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n     * appropriate rule and action indexes.</p>\n     */\n    execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerCustomAction)) {\n            return false;\n        } else {\n            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n        }\n    }\n}\n\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\nclass LexerChannelAction extends LexerAction {\n    constructor(channel) {\n        super(LexerActionType.CHANNEL);\n        this.channel = channel;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n     * value provided by {@link //getChannel}.</p>\n     */\n    execute(lexer) {\n        lexer._channel = this.channel;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.channel);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerChannelAction)) {\n            return false;\n        } else {\n            return this.channel === other.channel;\n        }\n    }\n\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n}\n\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\nclass LexerIndexedCustomAction extends LexerAction {\n    constructor(offset, action) {\n        super(action.actionType);\n        this.offset = offset;\n        this.action = action;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>This method calls {@link //execute} on the result of {@link //getAction}\n     * using the provided {@code lexer}.</p>\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this.action.execute(lexer);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.offset, this.action);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerIndexedCustomAction)) {\n            return false;\n        } else {\n            return this.offset === other.offset && this.action === other.action;\n        }\n    }\n}\n\nmodule.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n}\n"]},"metadata":{},"sourceType":"script"}