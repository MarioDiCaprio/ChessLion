{"ast":null,"code":"import antlr4 from 'antlr4';\nimport pgnLexer from './.antlr/pgnLexer';\nimport pgnParser from './.antlr/pgnParser';\nexport function parsePgn(input) {\n  const chars = new antlr4.InputStream(input);\n  const lexer = new pgnLexer(chars);\n  const tokens = new antlr4.CommonTokenStream(lexer);\n  const parser = new pgnParser(tokens);\n  parser.game();\n  return {\n    tags: parser.tags,\n    moves: parser.moves\n  };\n}\nexport default class Pgn {\n  constructor(pgn) {\n    this.tags = {};\n    this.moves = [];\n\n    this.parse = input => {\n      const tmp = parsePgn(input);\n      this.tags = tmp.tags;\n      this.moves = tmp.moves;\n    };\n\n    this.toString = () => {\n      const tags = [];\n\n      for (let tag in this.tags) {\n        tags.push('[' + tag + ' \"' + this.tags[tag] + '\"');\n      }\n\n      const moves = [];\n\n      for (let i = 0; i < this.moves.length; i++) {\n        let tmp = '' + (i + 1);\n\n        for (let move of this.moves[i]) {\n          if (move.move !== undefined) tmp += ' ' + move.move;\n          if (move.glyph !== undefined) tmp += move.glyph;\n          if (move.comment !== undefined) tmp += ' {' + move.comment + '}';\n        }\n\n        moves.push(tmp);\n      }\n\n      return tags.join('\\n') + '\\n' + moves.join('\\n');\n    };\n\n    if (pgn !== undefined) {\n      if (typeof pgn === 'string') {}\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/src/utils/pgn/pgnParser.ts"],"names":["antlr4","pgnLexer","pgnParser","parsePgn","input","chars","InputStream","lexer","tokens","CommonTokenStream","parser","game","tags","moves","Pgn","constructor","pgn","parse","tmp","toString","tag","push","i","length","move","undefined","glyph","comment","join"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AAcA,OAAO,SAASC,QAAT,CAAkBC,KAAlB,EAA4C;AAC/C,QAAMC,KAAK,GAAG,IAAIL,MAAM,CAACM,WAAX,CAAuBF,KAAvB,CAAd;AACA,QAAMG,KAAK,GAAG,IAAIN,QAAJ,CAAaI,KAAb,CAAd;AACA,QAAMG,MAAM,GAAG,IAAIR,MAAM,CAACS,iBAAX,CAA6BF,KAA7B,CAAf;AACA,QAAMG,MAAM,GAAG,IAAIR,SAAJ,CAAcM,MAAd,CAAf;AACAE,EAAAA,MAAM,CAACC,IAAP;AAEA,SAAO;AACHC,IAAAA,IAAI,EAAEF,MAAM,CAACE,IADV;AAEHC,IAAAA,KAAK,EAAEH,MAAM,CAACG;AAFX,GAAP;AAIH;AAGD,eAAe,MAAMC,GAAN,CAA+B;AAI1CC,EAAAA,WAAW,CAACC,GAAD,EAA2B;AAAA,SAHtCJ,IAGsC,GAHH,EAGG;AAAA,SAFtCC,KAEsC,GAFd,EAEc;;AAAA,SAQtCI,KARsC,GAQ7Bb,KAAD,IAAyB;AAC7B,YAAMc,GAAG,GAAGf,QAAQ,CAACC,KAAD,CAApB;AACA,WAAKQ,IAAL,GAAYM,GAAG,CAACN,IAAhB;AACA,WAAKC,KAAL,GAAaK,GAAG,CAACL,KAAjB;AACH,KAZqC;;AAAA,SActCM,QAdsC,GAc3B,MAAc;AACrB,YAAMP,IAAmB,GAAG,EAA5B;;AACA,WAAK,IAAIQ,GAAT,IAAgB,KAAKR,IAArB,EAA2B;AACvBA,QAAAA,IAAI,CAACS,IAAL,CAAU,MAAMD,GAAN,GAAY,IAAZ,GAAmB,KAAKR,IAAL,CAAUQ,GAAV,CAAnB,GAAoC,GAA9C;AACH;;AAED,YAAMP,KAAoB,GAAG,EAA7B;;AACA,WAAK,IAAIS,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAC,KAAKT,KAAL,CAAWU,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,YAAIJ,GAAG,GAAG,MAAMI,CAAC,GAAG,CAAV,CAAV;;AACA,aAAK,IAAIE,IAAT,IAAiB,KAAKX,KAAL,CAAWS,CAAX,CAAjB,EAAgC;AAC5B,cAAIE,IAAI,CAACA,IAAL,KAAcC,SAAlB,EACIP,GAAG,IAAI,MAAMM,IAAI,CAACA,IAAlB;AACJ,cAAIA,IAAI,CAACE,KAAL,KAAeD,SAAnB,EACIP,GAAG,IAAIM,IAAI,CAACE,KAAZ;AACJ,cAAIF,IAAI,CAACG,OAAL,KAAiBF,SAArB,EACIP,GAAG,IAAI,OAAOM,IAAI,CAACG,OAAZ,GAAsB,GAA7B;AACP;;AACDd,QAAAA,KAAK,CAACQ,IAAN,CAAWH,GAAX;AACH;;AAED,aAAON,IAAI,CAACgB,IAAL,CAAU,IAAV,IAAkB,IAAlB,GAAyBf,KAAK,CAACe,IAAN,CAAW,IAAX,CAAhC;AACH,KAnCqC;;AAClC,QAAIZ,GAAG,KAAKS,SAAZ,EAAuB;AACnB,UAAI,OAAOT,GAAP,KAAe,QAAnB,EAA6B,CAE5B;AACJ;AACJ;;AAVyC","sourcesContent":["import antlr4 from 'antlr4';\nimport pgnLexer from './.antlr/pgnLexer';\nimport pgnParser from './.antlr/pgnParser';\n\n\nexport interface Move {\n    move?: string;\n    glyph?: string;\n    comment?: string;\n}\n\nexport interface PgnObject {\n    tags: { [key: string]: string };\n    moves: Array<[Move, Move]>;\n}\n\nexport function parsePgn(input: string): PgnObject {\n    const chars = new antlr4.InputStream(input);\n    const lexer = new pgnLexer(chars);\n    const tokens = new antlr4.CommonTokenStream(lexer);\n    const parser = new pgnParser(tokens);\n    parser.game();\n\n    return {\n        tags: parser.tags,\n        moves: parser.moves,\n    }\n}\n\n\nexport default class Pgn implements PgnObject {\n    tags: { [key: string]: string; } = {};\n    moves: [Move, Move][] = [];\n\n    constructor(pgn?: string | PgnObject) {\n        if (pgn !== undefined) {\n            if (typeof pgn === 'string') {\n\n            }\n        }\n    }\n\n    parse = (input: string): void => {\n        const tmp = parsePgn(input);\n        this.tags = tmp.tags;\n        this.moves = tmp.moves;\n    }\n\n    toString = (): string => {\n        const tags: Array<string> = [];\n        for (let tag in this.tags) {\n            tags.push('[' + tag + ' \"' + this.tags[tag] + '\"');\n        }\n\n        const moves: Array<string> = [];\n        for (let i=0; i<this.moves.length; i++) {\n            let tmp = '' + (i + 1);\n            for (let move of this.moves[i]) {\n                if (move.move !== undefined)\n                    tmp += ' ' + move.move;\n                if (move.glyph !== undefined)\n                    tmp += move.glyph;\n                if (move.comment !== undefined)\n                    tmp += ' {' + move.comment + '}';\n            }\n            moves.push(tmp);\n        }\n\n        return tags.join('\\n') + '\\n' + moves.join('\\n');\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}