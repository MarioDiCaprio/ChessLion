{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Set\n} = require(\"../Utils\");\n\nconst {\n  DFAState\n} = require('./DFAState');\n\nconst {\n  StarLoopEntryState\n} = require('../atn/ATNState');\n\nconst {\n  ATNConfigSet\n} = require('./../atn/ATNConfigSet');\n\nconst {\n  DFASerializer\n} = require('./DFASerializer');\n\nconst {\n  LexerDFASerializer\n} = require('./DFASerializer');\n\nclass DFA {\n  constructor(atnStartState, decision) {\n    if (decision === undefined) {\n      decision = 0;\n    }\n    /**\n     * From which ATN state did we create this DFA?\n     */\n\n\n    this.atnStartState = atnStartState;\n    this.decision = decision;\n    /**\n     * A set of all DFA states. Use {@link Map} so we can get old state back\n     * ({@link Set} only allows you to see if it's there).\n     */\n\n    this._states = new Set();\n    this.s0 = null;\n    /**\n     * {@code true} if this DFA is for a precedence decision; otherwise,\n     * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n     * {@link //setPrecedenceDfa}\n     */\n\n    this.precedenceDfa = false;\n\n    if (atnStartState instanceof StarLoopEntryState) {\n      if (atnStartState.isPrecedenceDecision) {\n        this.precedenceDfa = true;\n        const precedenceState = new DFAState(null, new ATNConfigSet());\n        precedenceState.edges = [];\n        precedenceState.isAcceptState = false;\n        precedenceState.requiresFullContext = false;\n        this.s0 = precedenceState;\n      }\n    }\n  }\n  /**\n   * Get the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n   * @return The start state corresponding to the specified precedence, or\n   * {@code null} if no start state exists for the specified precedence.\n   *\n   * @throws IllegalStateException if this is not a precedence DFA.\n   * @see //isPrecedenceDfa()\n   */\n\n\n  getPrecedenceStartState(precedence) {\n    if (!this.precedenceDfa) {\n      throw \"Only precedence DFAs may contain a precedence start state.\";\n    } // s0.edges is never null for a precedence DFA\n\n\n    if (precedence < 0 || precedence >= this.s0.edges.length) {\n      return null;\n    }\n\n    return this.s0.edges[precedence] || null;\n  }\n  /**\n   * Set the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n   * @param startState The start state corresponding to the specified\n   * precedence.\n   *\n   * @throws IllegalStateException if this is not a precedence DFA.\n   * @see //isPrecedenceDfa()\n   */\n\n\n  setPrecedenceStartState(precedence, startState) {\n    if (!this.precedenceDfa) {\n      throw \"Only precedence DFAs may contain a precedence start state.\";\n    }\n\n    if (precedence < 0) {\n      return;\n    }\n    /**\n     * synchronization on s0 here is ok. when the DFA is turned into a\n     * precedence DFA, s0 will be initialized once and not updated again\n     * s0.edges is never null for a precedence DFA\n     */\n\n\n    this.s0.edges[precedence] = startState;\n  }\n  /**\n   * Sets whether this is a precedence DFA. If the specified value differs\n   * from the current DFA configuration, the following actions are taken;\n   * otherwise no changes are made to the current DFA.\n   *\n   * <ul>\n   * <li>The {@link //states} map is cleared</li>\n   * <li>If {@code precedenceDfa} is {@code false}, the initial state\n   * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n   * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n   * store the start states for individual precedence values.</li>\n   * <li>The {@link //precedenceDfa} field is updated</li>\n   * </ul>\n   *\n   * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n   * {@code false}\n   */\n\n\n  setPrecedenceDfa(precedenceDfa) {\n    if (this.precedenceDfa !== precedenceDfa) {\n      this._states = new Set();\n\n      if (precedenceDfa) {\n        const precedenceState = new DFAState(null, new ATNConfigSet());\n        precedenceState.edges = [];\n        precedenceState.isAcceptState = false;\n        precedenceState.requiresFullContext = false;\n        this.s0 = precedenceState;\n      } else {\n        this.s0 = null;\n      }\n\n      this.precedenceDfa = precedenceDfa;\n    }\n  }\n  /**\n   * Return a list of all states in this DFA, ordered by state number.\n   */\n\n\n  sortedStates() {\n    const list = this._states.values();\n\n    return list.sort(function (a, b) {\n      return a.stateNumber - b.stateNumber;\n    });\n  }\n\n  toString(literalNames, symbolicNames) {\n    literalNames = literalNames || null;\n    symbolicNames = symbolicNames || null;\n\n    if (this.s0 === null) {\n      return \"\";\n    }\n\n    const serializer = new DFASerializer(this, literalNames, symbolicNames);\n    return serializer.toString();\n  }\n\n  toLexerString() {\n    if (this.s0 === null) {\n      return \"\";\n    }\n\n    const serializer = new LexerDFASerializer(this);\n    return serializer.toString();\n  }\n\n  get states() {\n    return this._states;\n  }\n\n}\n\nmodule.exports = DFA;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/dfa/DFA.js"],"names":["Set","require","DFAState","StarLoopEntryState","ATNConfigSet","DFASerializer","LexerDFASerializer","DFA","constructor","atnStartState","decision","undefined","_states","s0","precedenceDfa","isPrecedenceDecision","precedenceState","edges","isAcceptState","requiresFullContext","getPrecedenceStartState","precedence","length","setPrecedenceStartState","startState","setPrecedenceDfa","sortedStates","list","values","sort","a","b","stateNumber","toString","literalNames","symbolicNames","serializer","toLexerString","states","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set} = require(\"../Utils\");\nconst {DFAState} = require('./DFAState');\nconst {StarLoopEntryState} = require('../atn/ATNState');\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {DFASerializer} = require('./DFASerializer');\nconst {LexerDFASerializer} = require('./DFASerializer');\n\nclass DFA {\n\tconstructor(atnStartState, decision) {\n\t\tif (decision === undefined) {\n\t\t\tdecision = 0;\n\t\t}\n\t\t/**\n\t\t * From which ATN state did we create this DFA?\n\t\t */\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.decision = decision;\n\t\t/**\n\t\t * A set of all DFA states. Use {@link Map} so we can get old state back\n\t\t * ({@link Set} only allows you to see if it's there).\n\t\t */\n\t\tthis._states = new Set();\n\t\tthis.s0 = null;\n\t\t/**\n\t\t * {@code true} if this DFA is for a precedence decision; otherwise,\n\t\t * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t\t * {@link //setPrecedenceDfa}\n\t\t */\n\t\tthis.precedenceDfa = false;\n\t\tif (atnStartState instanceof StarLoopEntryState)\n\t\t{\n\t\t\tif (atnStartState.isPrecedenceDecision) {\n\t\t\t\tthis.precedenceDfa = true;\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @return The start state corresponding to the specified precedence, or\n\t * {@code null} if no start state exists for the specified precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tgetPrecedenceStartState(precedence) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\t// s0.edges is never null for a precedence DFA\n\t\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.s0.edges[precedence] || null;\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tsetPrecedenceStartState(precedence, startState) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * synchronization on s0 here is ok. when the DFA is turned into a\n\t\t * precedence DFA, s0 will be initialized once and not updated again\n\t\t * s0.edges is never null for a precedence DFA\n\t\t */\n\t\tthis.s0.edges[precedence] = startState;\n\t}\n\n\t/**\n\t * Sets whether this is a precedence DFA. If the specified value differs\n\t * from the current DFA configuration, the following actions are taken;\n\t * otherwise no changes are made to the current DFA.\n\t *\n\t * <ul>\n\t * <li>The {@link //states} map is cleared</li>\n\t * <li>If {@code precedenceDfa} is {@code false}, the initial state\n\t * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n\t * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n\t * store the start states for individual precedence values.</li>\n\t * <li>The {@link //precedenceDfa} field is updated</li>\n\t * </ul>\n\t *\n\t * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n\t * {@code false}\n\t */\n\tsetPrecedenceDfa(precedenceDfa) {\n\t\tif (this.precedenceDfa!==precedenceDfa) {\n\t\t\tthis._states = new Set();\n\t\t\tif (precedenceDfa) {\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t} else {\n\t\t\t\tthis.s0 = null;\n\t\t\t}\n\t\t\tthis.precedenceDfa = precedenceDfa;\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all states in this DFA, ordered by state number.\n\t */\n\tsortedStates() {\n\t\tconst list = this._states.values();\n\t\treturn list.sort(function(a, b) {\n\t\t\treturn a.stateNumber - b.stateNumber;\n\t\t});\n\t}\n\n\ttoString(literalNames, symbolicNames) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new DFASerializer(this, literalNames, symbolicNames);\n\t\treturn serializer.toString();\n\t}\n\n\ttoLexerString() {\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n\n\tget states(){\n\t\treturn this._states;\n\t}\n}\n\n\nmodule.exports = DFA;\n"]},"metadata":{},"sourceType":"script"}