{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./../Token');\n\nconst {\n  NoViableAltException,\n  InputMismatchException,\n  FailedPredicateException,\n  ParseCancellationException\n} = require('./Errors');\n\nconst {\n  ATNState\n} = require('./../atn/ATNState');\n\nconst {\n  Interval,\n  IntervalSet\n} = require('./../IntervalSet');\n\nclass ErrorStrategy {\n  reset(recognizer) {}\n\n  recoverInline(recognizer) {}\n\n  recover(recognizer, e) {}\n\n  sync(recognizer) {}\n\n  inErrorRecoveryMode(recognizer) {}\n\n  reportError(recognizer) {}\n\n}\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\n\n\nclass DefaultErrorStrategy extends ErrorStrategy {\n  constructor() {\n    super();\n    /**\n     * Indicates whether the error strategy is currently \"recovering from an\n     * error\". This is used to suppress reporting multiple error messages while\n     * attempting to recover from a detected syntax error.\n     *\n     * @see //inErrorRecoveryMode\n     */\n\n    this.errorRecoveryMode = false;\n    /**\n     * The index into the input stream where the last error occurred.\n     * This is used to prevent infinite loops where an error is found\n     * but no token is consumed during recovery...another error is found,\n     * ad nauseum. This is a failsafe mechanism to guarantee that at least\n     * one token/tree node is consumed for two errors.\n     */\n\n    this.lastErrorIndex = -1;\n    this.lastErrorStates = null;\n    this.nextTokensContext = null;\n    this.nextTokenState = 0;\n  }\n  /**\n   * <p>The default implementation simply calls {@link //endErrorCondition} to\n   * ensure that the handler is not in error recovery mode.</p>\n  */\n\n\n  reset(recognizer) {\n    this.endErrorCondition(recognizer);\n  }\n  /**\n   * This method is called to enter error recovery mode when a recognition\n   * exception is reported.\n   *\n   * @param recognizer the parser instance\n  */\n\n\n  beginErrorCondition(recognizer) {\n    this.errorRecoveryMode = true;\n  }\n\n  inErrorRecoveryMode(recognizer) {\n    return this.errorRecoveryMode;\n  }\n  /**\n   * This method is called to leave error recovery mode after recovering from\n   * a recognition exception.\n   * @param recognizer\n   */\n\n\n  endErrorCondition(recognizer) {\n    this.errorRecoveryMode = false;\n    this.lastErrorStates = null;\n    this.lastErrorIndex = -1;\n  }\n  /**\n   * {@inheritDoc}\n   * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n   */\n\n\n  reportMatch(recognizer) {\n    this.endErrorCondition(recognizer);\n  }\n  /**\n   * {@inheritDoc}\n   *\n   * <p>The default implementation returns immediately if the handler is already\n   * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n   * and dispatches the reporting task based on the runtime type of {@code e}\n   * according to the following table.</p>\n   *\n   * <ul>\n   * <li>{@link NoViableAltException}: Dispatches the call to\n   * {@link //reportNoViableAlternative}</li>\n   * <li>{@link InputMismatchException}: Dispatches the call to\n   * {@link //reportInputMismatch}</li>\n   * <li>{@link FailedPredicateException}: Dispatches the call to\n   * {@link //reportFailedPredicate}</li>\n   * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n   * the exception</li>\n   * </ul>\n   */\n\n\n  reportError(recognizer, e) {\n    // if we've already reported an error and have not matched a token\n    // yet successfully, don't report any errors.\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return; // don't report spurious errors\n    }\n\n    this.beginErrorCondition(recognizer);\n\n    if (e instanceof NoViableAltException) {\n      this.reportNoViableAlternative(recognizer, e);\n    } else if (e instanceof InputMismatchException) {\n      this.reportInputMismatch(recognizer, e);\n    } else if (e instanceof FailedPredicateException) {\n      this.reportFailedPredicate(recognizer, e);\n    } else {\n      console.log(\"unknown recognition error type: \" + e.constructor.name);\n      console.log(e.stack);\n      recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n    }\n  }\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * <p>The default implementation resynchronizes the parser by consuming tokens\n   * until we find one in the resynchronization set--loosely the set of tokens\n   * that can follow the current rule.</p>\n   *\n   */\n\n\n  recover(recognizer, e) {\n    if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {\n      // uh oh, another error at same token index and previously-visited\n      // state in ATN; must be a case where LT(1) is in the recovery\n      // token set so nothing got consumed. Consume a single token\n      // at least to prevent an infinite loop; this is a failsafe.\n      recognizer.consume();\n    }\n\n    this.lastErrorIndex = recognizer._input.index;\n\n    if (this.lastErrorStates === null) {\n      this.lastErrorStates = [];\n    }\n\n    this.lastErrorStates.push(recognizer.state);\n    const followSet = this.getErrorRecoverySet(recognizer);\n    this.consumeUntil(recognizer, followSet);\n  }\n  /**\n   * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n   * that the current lookahead symbol is consistent with what were expecting\n   * at this point in the ATN. You can call this anytime but ANTLR only\n   * generates code to check before subrules/loops and each iteration.\n   *\n   * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n   * subrules. E.g.,</p>\n   *\n   * <pre>\n   * a : sync ( stuff sync )* ;\n   * sync : {consume to what can follow sync} ;\n   * </pre>\n   *\n   * At the start of a sub rule upon error, {@link //sync} performs single\n   * token deletion, if possible. If it can't do that, it bails on the current\n   * rule and uses the default error recovery, which consumes until the\n   * resynchronization set of the current rule.\n   *\n   * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n   * with an empty alternative), then the expected set includes what follows\n   * the subrule.</p>\n   *\n   * <p>During loop iteration, it consumes until it sees a token that can start a\n   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n   * stay in the loop as long as possible.</p>\n   *\n   * <p><strong>ORIGINS</strong></p>\n   *\n   * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n   * A single mismatch token or missing token would force the parser to bail\n   * out of the entire rules surrounding the loop. So, for rule</p>\n   *\n   * <pre>\n   * classDef : 'class' ID '{' member* '}'\n   * </pre>\n   *\n   * input with an extra token between members would force the parser to\n   * consume until it found the next class definition rather than the next\n   * member definition of the current class.\n   *\n   * <p>This functionality cost a little bit of effort because the parser has to\n   * compare token set at the start of the loop and at each iteration. If for\n   * some reason speed is suffering for you, you can turn off this\n   * functionality by simply overriding this method as a blank { }.</p>\n   *\n   */\n\n\n  sync(recognizer) {\n    // If already recovering, don't try to sync\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n\n    const s = recognizer._interp.atn.states[recognizer.state];\n    const la = recognizer.getTokenStream().LA(1); // try cheaper subset first; might get lucky. seems to shave a wee bit off\n\n    const nextTokens = recognizer.atn.nextTokens(s);\n\n    if (nextTokens.contains(la)) {\n      this.nextTokensContext = null;\n      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n      return;\n    } else if (nextTokens.contains(Token.EPSILON)) {\n      if (this.nextTokensContext === null) {\n        // It's possible the next token won't match information tracked\n        // by sync is restricted for performance.\n        this.nextTokensContext = recognizer._ctx;\n        this.nextTokensState = recognizer._stateNumber;\n      }\n\n      return;\n    }\n\n    switch (s.stateType) {\n      case ATNState.BLOCK_START:\n      case ATNState.STAR_BLOCK_START:\n      case ATNState.PLUS_BLOCK_START:\n      case ATNState.STAR_LOOP_ENTRY:\n        // report error and recover if possible\n        if (this.singleTokenDeletion(recognizer) !== null) {\n          return;\n        } else {\n          throw new InputMismatchException(recognizer);\n        }\n\n      case ATNState.PLUS_LOOP_BACK:\n      case ATNState.STAR_LOOP_BACK:\n        this.reportUnwantedToken(recognizer);\n        const expecting = new IntervalSet();\n        expecting.addSet(recognizer.getExpectedTokens());\n        const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n        break;\n\n      default: // do nothing if we can't identify the exact kind of ATN state\n\n    }\n  }\n  /**\n   * This is called by {@link //reportError} when the exception is a\n   * {@link NoViableAltException}.\n   *\n   * @see //reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n\n\n  reportNoViableAlternative(recognizer, e) {\n    const tokens = recognizer.getTokenStream();\n    let input;\n\n    if (tokens !== null) {\n      if (e.startToken.type === Token.EOF) {\n        input = \"<EOF>\";\n      } else {\n        input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n      }\n    } else {\n      input = \"<unknown input>\";\n    }\n\n    const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This is called by {@link //reportError} when the exception is an\n   * {@link InputMismatchException}.\n   *\n   * @see //reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n\n\n  reportInputMismatch(recognizer, e) {\n    const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) + \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This is called by {@link //reportError} when the exception is a\n   * {@link FailedPredicateException}.\n   *\n   * @see //reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n\n\n  reportFailedPredicate(recognizer, e) {\n    const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];\n    const msg = \"rule \" + ruleName + \" \" + e.message;\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This method is called to report a syntax error which requires the removal\n   * of a token from the input stream. At the time this method is called, the\n   * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n   * removed from the input stream. When this method returns,\n   * {@code recognizer} is in error recovery mode.\n   *\n   * <p>This method is called when {@link //singleTokenDeletion} identifies\n   * single-token deletion as a viable recovery strategy for a mismatched\n   * input error.</p>\n   *\n   * <p>The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser//notifyErrorListeners}.</p>\n   *\n   * @param recognizer the parser instance\n   *\n   */\n\n\n  reportUnwantedToken(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n\n    this.beginErrorCondition(recognizer);\n    const t = recognizer.getCurrentToken();\n    const tokenName = this.getTokenErrorDisplay(t);\n    const expecting = this.getExpectedTokens(recognizer);\n    const msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);\n    recognizer.notifyErrorListeners(msg, t, null);\n  }\n  /**\n   * This method is called to report a syntax error which requires the\n   * insertion of a missing token into the input stream. At the time this\n   * method is called, the missing token has not yet been inserted. When this\n   * method returns, {@code recognizer} is in error recovery mode.\n   *\n   * <p>This method is called when {@link //singleTokenInsertion} identifies\n   * single-token insertion as a viable recovery strategy for a mismatched\n   * input error.</p>\n   *\n   * <p>The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser//notifyErrorListeners}.</p>\n   *\n   * @param recognizer the parser instance\n   */\n\n\n  reportMissingToken(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n\n    this.beginErrorCondition(recognizer);\n    const t = recognizer.getCurrentToken();\n    const expecting = this.getExpectedTokens(recognizer);\n    const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + \" at \" + this.getTokenErrorDisplay(t);\n    recognizer.notifyErrorListeners(msg, t, null);\n  }\n  /**\n   * <p>The default implementation attempts to recover from the mismatched input\n   * by using single token insertion and deletion as described below. If the\n   * recovery attempt fails, this method throws an\n   * {@link InputMismatchException}.</p>\n   *\n   * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n   *\n   * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n   * right token, however, then assume {@code LA(1)} is some extra spurious\n   * token and delete it. Then consume and return the next token (which was\n   * the {@code LA(2)} token) as the successful result of the match operation.</p>\n   *\n   * <p>This recovery strategy is implemented by {@link\n   * //singleTokenDeletion}.</p>\n   *\n   * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n   *\n   * <p>If current token (at {@code LA(1)}) is consistent with what could come\n   * after the expected {@code LA(1)} token, then assume the token is missing\n   * and use the parser's {@link TokenFactory} to create it on the fly. The\n   * \"insertion\" is performed by returning the created token as the successful\n   * result of the match operation.</p>\n   *\n   * <p>This recovery strategy is implemented by {@link\n   * //singleTokenInsertion}.</p>\n   *\n   * <p><strong>EXAMPLE</strong></p>\n   *\n   * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n   * the parser returns from the nested call to {@code expr}, it will have\n   * call chain:</p>\n   *\n   * <pre>\n   * stat &rarr; expr &rarr; atom\n   * </pre>\n   *\n   * and it will be trying to match the {@code ')'} at this point in the\n   * derivation:\n   *\n   * <pre>\n   * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n   * ^\n   * </pre>\n   *\n   * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n   * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n   * is in the set of tokens that can follow the {@code ')'} token reference\n   * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n   */\n\n\n  recoverInline(recognizer) {\n    // SINGLE TOKEN DELETION\n    const matchedSymbol = this.singleTokenDeletion(recognizer);\n\n    if (matchedSymbol !== null) {\n      // we have deleted the extra token.\n      // now, move past ttype token as if all were ok\n      recognizer.consume();\n      return matchedSymbol;\n    } // SINGLE TOKEN INSERTION\n\n\n    if (this.singleTokenInsertion(recognizer)) {\n      return this.getMissingSymbol(recognizer);\n    } // even that didn't work; must throw the exception\n\n\n    throw new InputMismatchException(recognizer);\n  }\n  /**\n   * This method implements the single-token insertion inline error recovery\n   * strategy. It is called by {@link //recoverInline} if the single-token\n   * deletion strategy fails to recover from the mismatched input. If this\n   * method returns {@code true}, {@code recognizer} will be in error recovery\n   * mode.\n   *\n   * <p>This method determines whether or not single-token insertion is viable by\n   * checking if the {@code LA(1)} input symbol could be successfully matched\n   * if it were instead the {@code LA(2)} symbol. If this method returns\n   * {@code true}, the caller is responsible for creating and inserting a\n   * token with the correct type to produce this behavior.</p>\n   *\n   * @param recognizer the parser instance\n   * @return {@code true} if single-token insertion is a viable recovery\n   * strategy for the current mismatched input, otherwise {@code false}\n   */\n\n\n  singleTokenInsertion(recognizer) {\n    const currentSymbolType = recognizer.getTokenStream().LA(1); // if current token is consistent with what could come after current\n    // ATN state, then we know we're missing a token; error recovery\n    // is free to conjure up and insert the missing token\n\n    const atn = recognizer._interp.atn;\n    const currentState = atn.states[recognizer.state];\n    const next = currentState.transitions[0].target;\n    const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);\n\n    if (expectingAtLL2.contains(currentSymbolType)) {\n      this.reportMissingToken(recognizer);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * This method implements the single-token deletion inline error recovery\n   * strategy. It is called by {@link //recoverInline} to attempt to recover\n   * from mismatched input. If this method returns null, the parser and error\n   * handler state will not have changed. If this method returns non-null,\n   * {@code recognizer} will <em>not</em> be in error recovery mode since the\n   * returned token was a successful match.\n   *\n   * <p>If the single-token deletion is successful, this method calls\n   * {@link //reportUnwantedToken} to report the error, followed by\n   * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n   * before returning {@link //reportMatch} is called to signal a successful\n   * match.</p>\n   *\n   * @param recognizer the parser instance\n   * @return the successfully matched {@link Token} instance if single-token\n   * deletion successfully recovers from the mismatched input, otherwise\n   * {@code null}\n   */\n\n\n  singleTokenDeletion(recognizer) {\n    const nextTokenType = recognizer.getTokenStream().LA(2);\n    const expecting = this.getExpectedTokens(recognizer);\n\n    if (expecting.contains(nextTokenType)) {\n      this.reportUnwantedToken(recognizer); // print(\"recoverFromMismatchedToken deleting \" \\\n      // + str(recognizer.getTokenStream().LT(1)) \\\n      // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n      // + \" is what we want\", file=sys.stderr)\n\n      recognizer.consume(); // simply delete extra token\n      // we want to return the token we're actually matching\n\n      const matchedSymbol = recognizer.getCurrentToken();\n      this.reportMatch(recognizer); // we know current token is correct\n\n      return matchedSymbol;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Conjure up a missing token during error recovery.\n   *\n   * The recognizer attempts to recover from single missing\n   * symbols. But, actions might refer to that missing symbol.\n   * For example, x=ID {f($x);}. The action clearly assumes\n   * that there has been an identifier matched previously and that\n   * $x points at that token. If that token is missing, but\n   * the next token in the stream is what we want we assume that\n   * this token is missing and we keep going. Because we\n   * have to return some token to replace the missing token,\n   * we have to conjure one up. This method gives the user control\n   * over the tokens returned for missing tokens. Mostly,\n   * you will want to create something special for identifier\n   * tokens. For literals such as '{' and ',', the default\n   * action in the parser or tree parser works. It simply creates\n   * a CommonToken of the appropriate type. The text will be the token.\n   * If you change what tokens must be created by the lexer,\n   * override this method to create the appropriate tokens.\n   *\n   */\n\n\n  getMissingSymbol(recognizer) {\n    const currentSymbol = recognizer.getCurrentToken();\n    const expecting = this.getExpectedTokens(recognizer);\n    const expectedTokenType = expecting.first(); // get any element\n\n    let tokenText;\n\n    if (expectedTokenType === Token.EOF) {\n      tokenText = \"<missing EOF>\";\n    } else {\n      tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n    }\n\n    let current = currentSymbol;\n    const lookback = recognizer.getTokenStream().LT(-1);\n\n    if (current.type === Token.EOF && lookback !== null) {\n      current = lookback;\n    }\n\n    return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token.DEFAULT_CHANNEL, -1, -1, current.line, current.column);\n  }\n\n  getExpectedTokens(recognizer) {\n    return recognizer.getExpectedTokens();\n  }\n  /**\n   * How should a token be displayed in an error message? The default\n   * is to display just the text, but during development you might\n   * want to have a lot of information spit out. Override in that case\n   * to use t.toString() (which, for CommonToken, dumps everything about\n   * the token). This is better than forcing you to override a method in\n   * your token objects because you don't have to go modify your lexer\n   * so that it creates a new Java type.\n   */\n\n\n  getTokenErrorDisplay(t) {\n    if (t === null) {\n      return \"<no token>\";\n    }\n\n    let s = t.text;\n\n    if (s === null) {\n      if (t.type === Token.EOF) {\n        s = \"<EOF>\";\n      } else {\n        s = \"<\" + t.type + \">\";\n      }\n    }\n\n    return this.escapeWSAndQuote(s);\n  }\n\n  escapeWSAndQuote(s) {\n    s = s.replace(/\\n/g, \"\\\\n\");\n    s = s.replace(/\\r/g, \"\\\\r\");\n    s = s.replace(/\\t/g, \"\\\\t\");\n    return \"'\" + s + \"'\";\n  }\n  /**\n   * Compute the error recovery set for the current rule. During\n   * rule invocation, the parser pushes the set of tokens that can\n   * follow that rule reference on the stack; this amounts to\n   * computing FIRST of what follows the rule reference in the\n   * enclosing rule. See LinearApproximator.FIRST().\n   * This local follow set only includes tokens\n   * from within the rule; i.e., the FIRST computation done by\n   * ANTLR stops at the end of a rule.\n   *\n   * EXAMPLE\n   *\n   * When you find a \"no viable alt exception\", the input is not\n   * consistent with any of the alternatives for rule r. The best\n   * thing to do is to consume tokens until you see something that\n   * can legally follow a call to r//or* any rule that called r.\n   * You don't want the exact set of viable next tokens because the\n   * input might just be missing a token--you might consume the\n   * rest of the input looking for one of the missing tokens.\n   *\n   * Consider grammar:\n   *\n   * a : '[' b ']'\n   * | '(' b ')'\n   * ;\n   * b : c '^' INT ;\n   * c : ID\n   * | INT\n   * ;\n   *\n   * At each rule invocation, the set of tokens that could follow\n   * that rule is pushed on a stack. Here are the various\n   * context-sensitive follow sets:\n   *\n   * FOLLOW(b1_in_a) = FIRST(']') = ']'\n   * FOLLOW(b2_in_a) = FIRST(')') = ')'\n   * FOLLOW(c_in_b) = FIRST('^') = '^'\n   *\n   * Upon erroneous input \"[]\", the call chain is\n   *\n   * a -> b -> c\n   *\n   * and, hence, the follow context stack is:\n   *\n   * depth follow set start of rule execution\n   * 0 <EOF> a (from main())\n   * 1 ']' b\n   * 2 '^' c\n   *\n   * Notice that ')' is not included, because b would have to have\n   * been called from a different context in rule a for ')' to be\n   * included.\n   *\n   * For error recovery, we cannot consider FOLLOW(c)\n   * (context-sensitive or otherwise). We need the combined set of\n   * all context-sensitive FOLLOW sets--the set of all tokens that\n   * could follow any reference in the call chain. We need to\n   * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n   * we resync'd to that token, we'd consume until EOF. We need to\n   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n   * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n   * not consume anything. After printing an error, rule c would\n   * return normally. Rule b would not find the required '^' though.\n   * At this point, it gets a mismatched token error and throws an\n   * exception (since LA(1) is not in the viable following token\n   * set). The rule exception handler tries to recover, but finds\n   * the same recovery set and doesn't consume anything. Rule b\n   * exits normally returning to rule a. Now it finds the ']' (and\n   * with the successful match exits errorRecovery mode).\n   *\n   * So, you can see that the parser walks up the call chain looking\n   * for the token that was a member of the recovery set.\n   *\n   * Errors are not generated in errorRecovery mode.\n   *\n   * ANTLR's error recovery mechanism is based upon original ideas:\n   *\n   * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n   *\n   * and\n   *\n   * \"A note on error recovery in recursive descent parsers\":\n   * http://portal.acm.org/citation.cfm?id=947902.947905\n   *\n   * Later, Josef Grosch had some good ideas:\n   *\n   * \"Efficient and Comfortable Error Recovery in Recursive Descent\n   * Parsers\":\n   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n   *\n   * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n   * at run-time upon error to avoid overhead during parsing.\n   */\n\n\n  getErrorRecoverySet(recognizer) {\n    const atn = recognizer._interp.atn;\n    let ctx = recognizer._ctx;\n    const recoverSet = new IntervalSet();\n\n    while (ctx !== null && ctx.invokingState >= 0) {\n      // compute what follows who invoked us\n      const invokingState = atn.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      const follow = atn.nextTokens(rt.followState);\n      recoverSet.addSet(follow);\n      ctx = ctx.parentCtx;\n    }\n\n    recoverSet.removeOne(Token.EPSILON);\n    return recoverSet;\n  } // Consume tokens until one matches the given token set.//\n\n\n  consumeUntil(recognizer, set) {\n    let ttype = recognizer.getTokenStream().LA(1);\n\n    while (ttype !== Token.EOF && !set.contains(ttype)) {\n      recognizer.consume();\n      ttype = recognizer.getTokenStream().LA(1);\n    }\n  }\n\n}\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\n\n\nclass BailErrorStrategy extends DefaultErrorStrategy {\n  constructor() {\n    super();\n  }\n  /**\n   * Instead of recovering from exception {@code e}, re-throw it wrapped\n   * in a {@link ParseCancellationException} so it is not caught by the\n   * rule function catches. Use {@link Exception//getCause()} to get the\n   * original {@link RecognitionException}.\n   */\n\n\n  recover(recognizer, e) {\n    let context = recognizer._ctx;\n\n    while (context !== null) {\n      context.exception = e;\n      context = context.parentCtx;\n    }\n\n    throw new ParseCancellationException(e);\n  }\n  /**\n   * Make sure we don't attempt to recover inline; if the parser\n   * successfully recovers, it won't throw an exception.\n   */\n\n\n  recoverInline(recognizer) {\n    this.recover(recognizer, new InputMismatchException(recognizer));\n  } // Make sure we don't attempt to recover from problems in subrules.//\n\n\n  sync(recognizer) {// pass\n  }\n\n}\n\nmodule.exports = {\n  BailErrorStrategy,\n  DefaultErrorStrategy\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/error/ErrorStrategy.js"],"names":["Token","require","NoViableAltException","InputMismatchException","FailedPredicateException","ParseCancellationException","ATNState","Interval","IntervalSet","ErrorStrategy","reset","recognizer","recoverInline","recover","e","sync","inErrorRecoveryMode","reportError","DefaultErrorStrategy","constructor","errorRecoveryMode","lastErrorIndex","lastErrorStates","nextTokensContext","nextTokenState","endErrorCondition","beginErrorCondition","reportMatch","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","console","log","name","stack","notifyErrorListeners","getOffendingToken","getMessage","getInputStream","index","indexOf","state","consume","_input","push","followSet","getErrorRecoverySet","consumeUntil","s","_interp","atn","states","la","getTokenStream","LA","nextTokens","contains","INVALID_STATE_NUMBER","EPSILON","_ctx","nextTokensState","_stateNumber","stateType","BLOCK_START","STAR_BLOCK_START","PLUS_BLOCK_START","STAR_LOOP_ENTRY","singleTokenDeletion","PLUS_LOOP_BACK","STAR_LOOP_BACK","reportUnwantedToken","expecting","addSet","getExpectedTokens","whatFollowsLoopIterationOrRule","tokens","input","startToken","type","EOF","getText","tokenIndex","offendingToken","msg","escapeWSAndQuote","getTokenErrorDisplay","toString","literalNames","symbolicNames","ruleName","ruleNames","ruleIndex","message","t","getCurrentToken","tokenName","reportMissingToken","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","currentState","next","transitions","target","expectingAtLL2","nextTokenType","currentSymbol","expectedTokenType","first","tokenText","current","lookback","LT","getTokenFactory","create","source","DEFAULT_CHANNEL","line","column","text","replace","ctx","recoverSet","invokingState","rt","follow","followState","parentCtx","removeOne","set","ttype","BailErrorStrategy","context","exception","module","exports"],"mappings":"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AAiB,CAAC9D,UAAD,EAAa;AAC1B,WAAOA,UAAU,CAAC8D,iBAAX,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIY,EAAAA,oBAAoB,CAACQ,CAAD,EAAI;AACpB,QAAIA,CAAC,KAAK,IAAV,EAAgB;AACZ,aAAO,YAAP;AACH;;AACD,QAAI7C,CAAC,GAAG6C,CAAC,CAAC2B,IAAV;;AACA,QAAIxE,CAAC,KAAK,IAAV,EAAgB;AACZ,UAAI6C,CAAC,CAACf,IAAF,KAAS9E,KAAK,CAAC+E,GAAnB,EAAwB;AACpB/B,QAAAA,CAAC,GAAG,OAAJ;AACH,OAFD,MAEO;AACHA,QAAAA,CAAC,GAAG,MAAM6C,CAAC,CAACf,IAAR,GAAe,GAAnB;AACH;AACJ;;AACD,WAAO,KAAKM,gBAAL,CAAsBpC,CAAtB,CAAP;AACH;;AAEDoC,EAAAA,gBAAgB,CAACpC,CAAD,EAAI;AAChBA,IAAAA,CAAC,GAAGA,CAAC,CAACyE,OAAF,CAAU,KAAV,EAAgB,KAAhB,CAAJ;AACAzE,IAAAA,CAAC,GAAGA,CAAC,CAACyE,OAAF,CAAU,KAAV,EAAgB,KAAhB,CAAJ;AACAzE,IAAAA,CAAC,GAAGA,CAAC,CAACyE,OAAF,CAAU,KAAV,EAAgB,KAAhB,CAAJ;AACA,WAAO,MAAMzE,CAAN,GAAU,GAAjB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIF,EAAAA,mBAAmB,CAACnC,UAAD,EAAa;AAC5B,UAAMuC,GAAG,GAAGvC,UAAU,CAACsC,OAAX,CAAmBC,GAA/B;AACA,QAAIwE,GAAG,GAAG/G,UAAU,CAACgD,IAArB;AACA,UAAMgE,UAAU,GAAG,IAAInH,WAAJ,EAAnB;;AACA,WAAOkH,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACE,aAAJ,IAAmB,CAA1C,EAA6C;AACzC;AACA,YAAMA,aAAa,GAAG1E,GAAG,CAACC,MAAJ,CAAWuE,GAAG,CAACE,aAAf,CAAtB;AACA,YAAMC,EAAE,GAAGD,aAAa,CAACrB,WAAd,CAA0B,CAA1B,CAAX;AACA,YAAMuB,MAAM,GAAG5E,GAAG,CAACK,UAAJ,CAAesE,EAAE,CAACE,WAAlB,CAAf;AACAJ,MAAAA,UAAU,CAACnD,MAAX,CAAkBsD,MAAlB;AACAJ,MAAAA,GAAG,GAAGA,GAAG,CAACM,SAAV;AACH;;AACDL,IAAAA,UAAU,CAACM,SAAX,CAAqBjI,KAAK,CAAC0D,OAA3B;AACA,WAAOiE,UAAP;AACH,GAvpB4C,CAypBjD;;;AACI5E,EAAAA,YAAY,CAACpC,UAAD,EAAauH,GAAb,EAAkB;AAC1B,QAAIC,KAAK,GAAGxH,UAAU,CAAC0C,cAAX,GAA4BC,EAA5B,CAA+B,CAA/B,CAAZ;;AACA,WAAO6E,KAAK,KAAKnI,KAAK,CAAC+E,GAAhB,IAAuB,CAACmD,GAAG,CAAC1E,QAAJ,CAAa2E,KAAb,CAA/B,EAAoD;AAChDxH,MAAAA,UAAU,CAAC+B,OAAX;AACAyF,MAAAA,KAAK,GAAGxH,UAAU,CAAC0C,cAAX,GAA4BC,EAA5B,CAA+B,CAA/B,CAAR;AACH;AACJ;;AAhqB4C;AAoqBjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM8E,iBAAN,SAAgClH,oBAAhC,CAAqD;AACjDC,EAAAA,WAAW,GAAG;AACV;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,OAAO,CAACF,UAAD,EAAaG,CAAb,EAAgB;AACnB,QAAIuH,OAAO,GAAG1H,UAAU,CAACgD,IAAzB;;AACA,WAAO0E,OAAO,KAAK,IAAnB,EAAyB;AACrBA,MAAAA,OAAO,CAACC,SAAR,GAAoBxH,CAApB;AACAuH,MAAAA,OAAO,GAAGA,OAAO,CAACL,SAAlB;AACH;;AACD,UAAM,IAAI3H,0BAAJ,CAA+BS,CAA/B,CAAN;AACH;AAED;AACJ;AACA;AACA;;;AACIF,EAAAA,aAAa,CAACD,UAAD,EAAa;AACtB,SAAKE,OAAL,CAAaF,UAAb,EAAyB,IAAIR,sBAAJ,CAA2BQ,UAA3B,CAAzB;AACH,GA1BgD,CA4BrD;;;AACII,EAAAA,IAAI,CAACJ,UAAD,EAAa,CACb;AACH;;AA/BgD;;AAmCrD4H,MAAM,CAACC,OAAP,GAAiB;AAACJ,EAAAA,iBAAD;AAAoBlH,EAAAA;AAApB,CAAjB","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token')\nconst {NoViableAltException, InputMismatchException, FailedPredicateException, ParseCancellationException} = require('./Errors')\nconst {ATNState} = require('./../atn/ATNState')\nconst {Interval, IntervalSet} = require('./../IntervalSet')\n\nclass ErrorStrategy {\n\n    reset(recognizer) {\n    }\n\n    recoverInline(recognizer) {\n    }\n\n    recover(recognizer, e) {\n    }\n\n    sync(recognizer) {\n    }\n\n    inErrorRecoveryMode(recognizer) {\n    }\n\n    reportError(recognizer) {\n    }\n}\n\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\nclass DefaultErrorStrategy extends ErrorStrategy {\n    constructor() {\n        super();\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see //inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n\n        /**\n         * The index into the input stream where the last error occurred.\n         * This is used to prevent infinite loops where an error is found\n         * but no token is consumed during recovery...another error is found,\n         * ad nauseum. This is a failsafe mechanism to guarantee that at least\n         * one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        this.lastErrorStates = null;\n        this.nextTokensContext = null;\n        this.nextTokenState = 0;\n    }\n\n    /**\n     * <p>The default implementation simply calls {@link //endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.</p>\n    */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n    */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = null;\n        this.lastErrorIndex = -1;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of {@code e}\n     * according to the following table.</p>\n     *\n     * <ul>\n     * <li>{@link NoViableAltException}: Dispatches the call to\n     * {@link //reportNoViableAlternative}</li>\n     * <li>{@link InputMismatchException}: Dispatches the call to\n     * {@link //reportInputMismatch}</li>\n     * <li>{@link FailedPredicateException}: Dispatches the call to\n     * {@link //reportFailedPredicate}</li>\n     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n     * the exception</li>\n     * </ul>\n     */\n    reportError(recognizer, e) {\n       // if we've already reported an error and have not matched a token\n       // yet successfully, don't report any errors.\n        if(this.inErrorRecoveryMode(recognizer)) {\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if ( e instanceof NoViableAltException ) {\n            this.reportNoViableAlternative(recognizer, e);\n        } else if ( e instanceof InputMismatchException ) {\n            this.reportInputMismatch(recognizer, e);\n        } else if ( e instanceof FailedPredicateException ) {\n            this.reportFailedPredicate(recognizer, e);\n        } else {\n            console.log(\"unknown recognition error type: \" + e.constructor.name);\n            console.log(e.stack);\n            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     *\n     * {@inheritDoc}\n     *\n     * <p>The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.</p>\n     *\n     */\n    recover(recognizer, e) {\n        if (this.lastErrorIndex===recognizer.getInputStream().index &&\n            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer._input.index;\n        if (this.lastErrorStates === null) {\n            this.lastErrorStates = [];\n        }\n        this.lastErrorStates.push(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer)\n        this.consumeUntil(recognizer, followSet);\n    }\n\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,</p>\n     *\n     * <pre>\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * </pre>\n     *\n     * At the start of a sub rule upon error, {@link //sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.</p>\n     *\n     * <p>During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.</p>\n     *\n     * <p><strong>ORIGINS</strong></p>\n     *\n     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule</p>\n     *\n     * <pre>\n     * classDef : 'class' ID '{' member* '}'\n     * </pre>\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * <p>This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.</p>\n     *\n     */\n    sync(recognizer) {\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        const s = recognizer._interp.atn.states[recognizer.state];\n        const la = recognizer.getTokenStream().LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if(nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n            return;\n        } else if (nextTokens.contains(Token.EPSILON)) {\n            if(this.nextTokensContext === null) {\n                // It's possible the next token won't match information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer._ctx;\n                this.nextTokensState = recognizer._stateNumber;\n            }\n            return;\n        }\n        switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n           // report error and recover if possible\n            if( this.singleTokenDeletion(recognizer) !== null) {\n                return;\n            } else {\n                throw new InputMismatchException(recognizer);\n            }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n            this.reportUnwantedToken(recognizer);\n            const expecting = new IntervalSet()\n            expecting.addSet(recognizer.getExpectedTokens());\n            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer))\n            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n            break;\n        default:\n            // do nothing if we can't identify the exact kind of ATN state\n        }\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        const tokens = recognizer.getTokenStream()\n        let input\n        if(tokens !== null) {\n            if (e.startToken.type===Token.EOF) {\n                input = \"<EOF>\";\n            } else {\n                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n            }\n        } else {\n            input = \"<unknown input>\";\n        }\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n            \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex]\n        const msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     *\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const tokenName = this.getTokenErrorDisplay(t)\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if ( this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n            \" at \" + this.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * <p>The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method throws an\n     * {@link InputMismatchException}.</p>\n     *\n     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n     *\n     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n     * right token, however, then assume {@code LA(1)} is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the {@code LA(2)} token) as the successful result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenDeletion}.</p>\n     *\n     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n     *\n     * <p>If current token (at {@code LA(1)}) is consistent with what could come\n     * after the expected {@code LA(1)} token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenInsertion}.</p>\n     *\n     * <p><strong>EXAMPLE</strong></p>\n     *\n     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n     * the parser returns from the nested call to {@code expr}, it will have\n     * call chain:</p>\n     *\n     * <pre>\n     * stat &rarr; expr &rarr; atom\n     * </pre>\n     *\n     * and it will be trying to match the {@code ')'} at this point in the\n     * derivation:\n     *\n     * <pre>\n     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n     * ^\n     * </pre>\n     *\n     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n     * is in the set of tokens that can follow the {@code ')'} token reference\n     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        const matchedSymbol = this.singleTokenDeletion(recognizer)\n        if (matchedSymbol !== null) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        throw new InputMismatchException(recognizer);\n    }\n\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link //recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns {@code true}, {@code recognizer} will be in error recovery\n     * mode.\n     *\n     * <p>This method determines whether or not single-token insertion is viable by\n     * checking if the {@code LA(1)} input symbol could be successfully matched\n     * if it were instead the {@code LA(2)} symbol. If this method returns\n     * {@code true}, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.</p>\n     *\n     * @param recognizer the parser instance\n     * @return {@code true} if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise {@code false}\n     */\n    singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.getTokenStream().LA(1)\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        const atn = recognizer._interp.atn\n        const currentState = atn.states[recognizer.state]\n        const next = currentState.transitions[0].target\n        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx)\n        if (expectingAtLL2.contains(currentSymbolType) ){\n            this.reportMissingToken(recognizer);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link //recoverInline} to attempt to recover\n     * from mismatched input. If this method returns null, the parser and error\n     * handler state will not have changed. If this method returns non-null,\n     * {@code recognizer} will <em>not</em> be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * <p>If the single-token deletion is successful, this method calls\n     * {@link //reportUnwantedToken} to report the error, followed by\n     * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link //reportMatch} is called to signal a successful\n     * match.</p>\n     *\n     * @param recognizer the parser instance\n     * @return the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * {@code null}\n     */\n    singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.getTokenStream().LA(2)\n        const expecting = this.getExpectedTokens(recognizer)\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            // print(\"recoverFromMismatchedToken deleting \" \\\n            // + str(recognizer.getTokenStream().LT(1)) \\\n            // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n            // + \" is what we want\", file=sys.stderr)\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            const matchedSymbol = recognizer.getCurrentToken()\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Conjure up a missing token during error recovery.\n     *\n     * The recognizer attempts to recover from single missing\n     * symbols. But, actions might refer to that missing symbol.\n     * For example, x=ID {f($x);}. The action clearly assumes\n     * that there has been an identifier matched previously and that\n     * $x points at that token. If that token is missing, but\n     * the next token in the stream is what we want we assume that\n     * this token is missing and we keep going. Because we\n     * have to return some token to replace the missing token,\n     * we have to conjure one up. This method gives the user control\n     * over the tokens returned for missing tokens. Mostly,\n     * you will want to create something special for identifier\n     * tokens. For literals such as '{' and ',', the default\n     * action in the parser or tree parser works. It simply creates\n     * a CommonToken of the appropriate type. The text will be the token.\n     * If you change what tokens must be created by the lexer,\n     * override this method to create the appropriate tokens.\n     *\n     */\n    getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const expectedTokenType = expecting.first() // get any element\n        let tokenText\n        if (expectedTokenType===Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        } else {\n            tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n        }\n        let current = currentSymbol\n        const lookback = recognizer.getTokenStream().LT(-1)\n        if (current.type===Token.EOF && lookback !== null) {\n            current = lookback;\n        }\n        return recognizer.getTokenFactory().create(current.source,\n            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n            -1, -1, current.line, current.column);\n    }\n\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out. Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (t === null) {\n            return \"<no token>\";\n        }\n        let s = t.text\n        if (s === null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g,\"\\\\n\");\n        s = s.replace(/\\r/g,\"\\\\r\");\n        s = s.replace(/\\t/g,\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    /**\n     * Compute the error recovery set for the current rule. During\n     * rule invocation, the parser pushes the set of tokens that can\n     * follow that rule reference on the stack; this amounts to\n     * computing FIRST of what follows the rule reference in the\n     * enclosing rule. See LinearApproximator.FIRST().\n     * This local follow set only includes tokens\n     * from within the rule; i.e., the FIRST computation done by\n     * ANTLR stops at the end of a rule.\n     *\n     * EXAMPLE\n     *\n     * When you find a \"no viable alt exception\", the input is not\n     * consistent with any of the alternatives for rule r. The best\n     * thing to do is to consume tokens until you see something that\n     * can legally follow a call to r//or* any rule that called r.\n     * You don't want the exact set of viable next tokens because the\n     * input might just be missing a token--you might consume the\n     * rest of the input looking for one of the missing tokens.\n     *\n     * Consider grammar:\n     *\n     * a : '[' b ']'\n     * | '(' b ')'\n     * ;\n     * b : c '^' INT ;\n     * c : ID\n     * | INT\n     * ;\n     *\n     * At each rule invocation, the set of tokens that could follow\n     * that rule is pushed on a stack. Here are the various\n     * context-sensitive follow sets:\n     *\n     * FOLLOW(b1_in_a) = FIRST(']') = ']'\n     * FOLLOW(b2_in_a) = FIRST(')') = ')'\n     * FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     * Upon erroneous input \"[]\", the call chain is\n     *\n     * a -> b -> c\n     *\n     * and, hence, the follow context stack is:\n     *\n     * depth follow set start of rule execution\n     * 0 <EOF> a (from main())\n     * 1 ']' b\n     * 2 '^' c\n     *\n     * Notice that ')' is not included, because b would have to have\n     * been called from a different context in rule a for ')' to be\n     * included.\n     *\n     * For error recovery, we cannot consider FOLLOW(c)\n     * (context-sensitive or otherwise). We need the combined set of\n     * all context-sensitive FOLLOW sets--the set of all tokens that\n     * could follow any reference in the call chain. We need to\n     * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n     * we resync'd to that token, we'd consume until EOF. We need to\n     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     * not consume anything. After printing an error, rule c would\n     * return normally. Rule b would not find the required '^' though.\n     * At this point, it gets a mismatched token error and throws an\n     * exception (since LA(1) is not in the viable following token\n     * set). The rule exception handler tries to recover, but finds\n     * the same recovery set and doesn't consume anything. Rule b\n     * exits normally returning to rule a. Now it finds the ']' (and\n     * with the successful match exits errorRecovery mode).\n     *\n     * So, you can see that the parser walks up the call chain looking\n     * for the token that was a member of the recovery set.\n     *\n     * Errors are not generated in errorRecovery mode.\n     *\n     * ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     * and\n     *\n     * \"A note on error recovery in recursive descent parsers\":\n     * http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     * Later, Josef Grosch had some good ideas:\n     *\n     * \"Efficient and Comfortable Error Recovery in Recursive Descent\n     * Parsers\":\n     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     * at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        const atn = recognizer._interp.atn\n        let ctx = recognizer._ctx\n        const recoverSet = new IntervalSet()\n        while (ctx !== null && ctx.invokingState>=0) {\n            // compute what follows who invoked us\n            const invokingState = atn.states[ctx.invokingState]\n            const rt = invokingState.transitions[0]\n            const follow = atn.nextTokens(rt.followState)\n            recoverSet.addSet(follow);\n            ctx = ctx.parentCtx;\n        }\n        recoverSet.removeOne(Token.EPSILON);\n        return recoverSet;\n    }\n\n// Consume tokens until one matches the given token set.//\n    consumeUntil(recognizer, set) {\n        let ttype = recognizer.getTokenStream().LA(1)\n        while( ttype !== Token.EOF && !set.contains(ttype)) {\n            recognizer.consume();\n            ttype = recognizer.getTokenStream().LA(1);\n        }\n    }\n}\n\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\nclass BailErrorStrategy extends DefaultErrorStrategy {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Instead of recovering from exception {@code e}, re-throw it wrapped\n     * in a {@link ParseCancellationException} so it is not caught by the\n     * rule function catches. Use {@link Exception//getCause()} to get the\n     * original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        let context = recognizer._ctx\n        while (context !== null) {\n            context.exception = e;\n            context = context.parentCtx;\n        }\n        throw new ParseCancellationException(e);\n    }\n\n    /**\n     * Make sure we don't attempt to recover inline; if the parser\n     * successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n\n// Make sure we don't attempt to recover from problems in subrules.//\n    sync(recognizer) {\n        // pass\n    }\n}\n\n\nmodule.exports = {BailErrorStrategy, DefaultErrorStrategy};\n"]},"metadata":{},"sourceType":"script"}