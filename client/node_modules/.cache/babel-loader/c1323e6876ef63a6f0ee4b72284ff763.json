{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  DecisionState\n} = require('./ATNState');\n\nconst {\n  SemanticContext\n} = require('./SemanticContext');\n\nconst {\n  Hash\n} = require(\"../Utils\");\n\nfunction checkParams(params, isCfg) {\n  if (params === null) {\n    const result = {\n      state: null,\n      alt: null,\n      context: null,\n      semanticContext: null\n    };\n\n    if (isCfg) {\n      result.reachesIntoOuterContext = 0;\n    }\n\n    return result;\n  } else {\n    const props = {};\n    props.state = params.state || null;\n    props.alt = params.alt === undefined ? null : params.alt;\n    props.context = params.context || null;\n    props.semanticContext = params.semanticContext || null;\n\n    if (isCfg) {\n      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n    }\n\n    return props;\n  }\n}\n\nclass ATNConfig {\n  /**\n   * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n   * The syntactic context is a graph-structured stack node whose\n   * path(s) to the root is the rule invocation(s)\n   * chain used to arrive at the state.  The semantic context is\n   * the tree of semantic predicates encountered before reaching\n   * an ATN state\n   */\n  constructor(params, config) {\n    this.checkContext(params, config);\n    params = checkParams(params);\n    config = checkParams(config, true); // The ATN state associated with this configuration///\n\n    this.state = params.state !== null ? params.state : config.state; // What alt (or lexer rule) is predicted by this configuration///\n\n    this.alt = params.alt !== null ? params.alt : config.alt;\n    /**\n     * The stack of invoking states leading to the rule/states associated\n     * with this config.  We track only those contexts pushed during\n     * execution of the ATN simulator\n     */\n\n    this.context = params.context !== null ? params.context : config.context;\n    this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE; // TODO: make it a boolean then\n\n    /**\n     * We cannot execute predicates dependent upon local context unless\n     * we know for sure we are in the correct context. Because there is\n     * no way to do this efficiently, we simply cannot evaluate\n     * dependent predicates unless we are in the rule that initially\n     * invokes the ATN simulator.\n     * closure() tracks the depth of how far we dip into the\n     * outer context: depth &gt; 0.  Note that it may not be totally\n     * accurate depth since I don't ever decrement\n     */\n\n    this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n  }\n\n  checkContext(params, config) {\n    if ((params.context === null || params.context === undefined) && (config === null || config.context === null || config.context === undefined)) {\n      this.context = null;\n    }\n  }\n\n  hashCode() {\n    const hash = new Hash();\n    this.updateHashCode(hash);\n    return hash.finish();\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n  }\n  /**\n   * An ATN configuration is equal to another if both have\n   * the same state, they predict the same alternative, and\n   * syntactic/semantic contexts are the same\n   */\n\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof ATNConfig)) {\n      return false;\n    } else {\n      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;\n    }\n  }\n\n  hashCodeForConfigSet() {\n    const hash = new Hash();\n    hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n    return hash.finish();\n  }\n\n  equalsForConfigSet(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof ATNConfig)) {\n      return false;\n    } else {\n      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);\n    }\n  }\n\n  toString() {\n    return \"(\" + this.state + \",\" + this.alt + (this.context !== null ? \",[\" + this.context.toString() + \"]\" : \"\") + (this.semanticContext !== SemanticContext.NONE ? \",\" + this.semanticContext.toString() : \"\") + (this.reachesIntoOuterContext > 0 ? \",up=\" + this.reachesIntoOuterContext : \"\") + \")\";\n  }\n\n}\n\nclass LexerATNConfig extends ATNConfig {\n  constructor(params, config) {\n    super(params, config); // This is the backing field for {@link //getLexerActionExecutor}.\n\n    const lexerActionExecutor = params.lexerActionExecutor || null;\n    this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);\n    this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;\n    this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n    this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n    return this;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n  }\n\n  equals(other) {\n    return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);\n  }\n\n  checkNonGreedyDecision(source, target) {\n    return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;\n  }\n\n}\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ATNConfig.js"],"names":["DecisionState","require","SemanticContext","Hash","checkParams","params","isCfg","result","state","alt","context","semanticContext","reachesIntoOuterContext","props","undefined","precedenceFilterSuppressed","ATNConfig","constructor","config","checkContext","NONE","hashCode","hash","updateHashCode","finish","update","stateNumber","equals","other","hashCodeForConfigSet","equalsForConfigSet","toString","LexerATNConfig","lexerActionExecutor","passedThroughNonGreedyDecision","checkNonGreedyDecision","prototype","source","target","nonGreedy","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAM;AAACA,EAAAA;AAAD,IAAkBC,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAoBD,OAAO,CAAC,mBAAD,CAAjC;;AACA,MAAM;AAACE,EAAAA;AAAD,IAASF,OAAO,CAAC,UAAD,CAAtB;;AAGA,SAASG,WAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoC;AACnC,MAAGD,MAAM,KAAG,IAAZ,EAAkB;AACjB,UAAME,MAAM,GAAG;AAAEC,MAAAA,KAAK,EAAC,IAAR;AAAcC,MAAAA,GAAG,EAAC,IAAlB;AAAwBC,MAAAA,OAAO,EAAC,IAAhC;AAAsCC,MAAAA,eAAe,EAAC;AAAtD,KAAf;;AACA,QAAGL,KAAH,EAAU;AACTC,MAAAA,MAAM,CAACK,uBAAP,GAAiC,CAAjC;AACA;;AACD,WAAOL,MAAP;AACA,GAND,MAMO;AACN,UAAMM,KAAK,GAAG,EAAd;AACAA,IAAAA,KAAK,CAACL,KAAN,GAAcH,MAAM,CAACG,KAAP,IAAgB,IAA9B;AACAK,IAAAA,KAAK,CAACJ,GAAN,GAAaJ,MAAM,CAACI,GAAP,KAAeK,SAAhB,GAA6B,IAA7B,GAAoCT,MAAM,CAACI,GAAvD;AACAI,IAAAA,KAAK,CAACH,OAAN,GAAgBL,MAAM,CAACK,OAAP,IAAkB,IAAlC;AACAG,IAAAA,KAAK,CAACF,eAAN,GAAwBN,MAAM,CAACM,eAAP,IAA0B,IAAlD;;AACA,QAAGL,KAAH,EAAU;AACTO,MAAAA,KAAK,CAACD,uBAAN,GAAgCP,MAAM,CAACO,uBAAP,IAAkC,CAAlE;AACAC,MAAAA,KAAK,CAACE,0BAAN,GAAmCV,MAAM,CAACU,0BAAP,IAAqC,KAAxE;AACA;;AACD,WAAOF,KAAP;AACA;AACD;;AAED,MAAMG,SAAN,CAAgB;AACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACZ,MAAD,EAASa,MAAT,EAAiB;AACxB,SAAKC,YAAL,CAAkBd,MAAlB,EAA0Ba,MAA1B;AACAb,IAAAA,MAAM,GAAGD,WAAW,CAACC,MAAD,CAApB;AACAa,IAAAA,MAAM,GAAGd,WAAW,CAACc,MAAD,EAAS,IAAT,CAApB,CAHwB,CAIxB;;AACA,SAAKV,KAAL,GAAaH,MAAM,CAACG,KAAP,KAAe,IAAf,GAAsBH,MAAM,CAACG,KAA7B,GAAqCU,MAAM,CAACV,KAAzD,CALwB,CAMxB;;AACA,SAAKC,GAAL,GAAWJ,MAAM,CAACI,GAAP,KAAa,IAAb,GAAoBJ,MAAM,CAACI,GAA3B,GAAiCS,MAAM,CAACT,GAAnD;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,OAAL,GAAeL,MAAM,CAACK,OAAP,KAAiB,IAAjB,GAAwBL,MAAM,CAACK,OAA/B,GAAyCQ,MAAM,CAACR,OAA/D;AACA,SAAKC,eAAL,GAAuBN,MAAM,CAACM,eAAP,KAAyB,IAAzB,GAAgCN,MAAM,CAACM,eAAvC,GAClBO,MAAM,CAACP,eAAP,KAAyB,IAAzB,GAAgCO,MAAM,CAACP,eAAvC,GAAyDT,eAAe,CAACkB,IAD9E,CAdwB,CAgBxB;;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKR,uBAAL,GAA+BM,MAAM,CAACN,uBAAtC;AACA,SAAKG,0BAAL,GAAkCG,MAAM,CAACH,0BAAzC;AACH;;AAEDI,EAAAA,YAAY,CAACd,MAAD,EAASa,MAAT,EAAiB;AACzB,QAAG,CAACb,MAAM,CAACK,OAAP,KAAiB,IAAjB,IAAyBL,MAAM,CAACK,OAAP,KAAiBI,SAA3C,MACMI,MAAM,KAAG,IAAT,IAAiBA,MAAM,CAACR,OAAP,KAAiB,IAAlC,IAA0CQ,MAAM,CAACR,OAAP,KAAiBI,SADjE,CAAH,EACgF;AAC5E,WAAKJ,OAAL,GAAe,IAAf;AACH;AACJ;;AAEDW,EAAAA,QAAQ,GAAG;AACP,UAAMC,IAAI,GAAG,IAAInB,IAAJ,EAAb;AACA,SAAKoB,cAAL,CAAoBD,IAApB;AACA,WAAOA,IAAI,CAACE,MAAL,EAAP;AACH;;AAEDD,EAAAA,cAAc,CAACD,IAAD,EAAO;AACjBA,IAAAA,IAAI,CAACG,MAAL,CAAY,KAAKjB,KAAL,CAAWkB,WAAvB,EAAoC,KAAKjB,GAAzC,EAA8C,KAAKC,OAAnD,EAA4D,KAAKC,eAAjE;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIgB,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,QAAI,SAASA,KAAb,EAAoB;AAChB,aAAO,IAAP;AACH,KAFD,MAEO,IAAI,EAAGA,KAAK,YAAYZ,SAApB,CAAJ,EAAoC;AACvC,aAAO,KAAP;AACH,KAFM,MAEA;AACH,aAAO,KAAKR,KAAL,CAAWkB,WAAX,KAAyBE,KAAK,CAACpB,KAAN,CAAYkB,WAArC,IACH,KAAKjB,GAAL,KAAWmB,KAAK,CAACnB,GADd,KAEF,KAAKC,OAAL,KAAe,IAAf,GAAsBkB,KAAK,CAAClB,OAAN,KAAgB,IAAtC,GAA6C,KAAKA,OAAL,CAAaiB,MAAb,CAAoBC,KAAK,CAAClB,OAA1B,CAF3C,KAGH,KAAKC,eAAL,CAAqBgB,MAArB,CAA4BC,KAAK,CAACjB,eAAlC,CAHG,IAIH,KAAKI,0BAAL,KAAkCa,KAAK,CAACb,0BAJ5C;AAKH;AACJ;;AAEDc,EAAAA,oBAAoB,GAAG;AACnB,UAAMP,IAAI,GAAG,IAAInB,IAAJ,EAAb;AACAmB,IAAAA,IAAI,CAACG,MAAL,CAAY,KAAKjB,KAAL,CAAWkB,WAAvB,EAAoC,KAAKjB,GAAzC,EAA8C,KAAKE,eAAnD;AACA,WAAOW,IAAI,CAACE,MAAL,EAAP;AACH;;AAEDM,EAAAA,kBAAkB,CAACF,KAAD,EAAQ;AACtB,QAAI,SAASA,KAAb,EAAoB;AAChB,aAAO,IAAP;AACH,KAFD,MAEO,IAAI,EAAGA,KAAK,YAAYZ,SAApB,CAAJ,EAAoC;AACvC,aAAO,KAAP;AACH,KAFM,MAEA;AACH,aAAO,KAAKR,KAAL,CAAWkB,WAAX,KAAyBE,KAAK,CAACpB,KAAN,CAAYkB,WAArC,IACH,KAAKjB,GAAL,KAAWmB,KAAK,CAACnB,GADd,IAEH,KAAKE,eAAL,CAAqBgB,MAArB,CAA4BC,KAAK,CAACjB,eAAlC,CAFJ;AAGH;AACJ;;AAEDoB,EAAAA,QAAQ,GAAG;AACP,WAAO,MAAM,KAAKvB,KAAX,GAAmB,GAAnB,GAAyB,KAAKC,GAA9B,IACF,KAAKC,OAAL,KAAe,IAAf,GAAsB,OAAO,KAAKA,OAAL,CAAaqB,QAAb,EAAP,GAAiC,GAAvD,GAA6D,EAD3D,KAEF,KAAKpB,eAAL,KAAyBT,eAAe,CAACkB,IAAzC,GACQ,MAAM,KAAKT,eAAL,CAAqBoB,QAArB,EADd,GAES,EAJP,KAKF,KAAKnB,uBAAL,GAA6B,CAA7B,GACQ,SAAS,KAAKA,uBADtB,GAES,EAPP,IAOa,GAPpB;AAQH;;AAvGW;;AA2GhB,MAAMoB,cAAN,SAA6BhB,SAA7B,CAAuC;AACnCC,EAAAA,WAAW,CAACZ,MAAD,EAASa,MAAT,EAAiB;AACxB,UAAMb,MAAN,EAAca,MAAd,EADwB,CAGxB;;AACA,UAAMe,mBAAmB,GAAG5B,MAAM,CAAC4B,mBAAP,IAA8B,IAA1D;AACA,SAAKA,mBAAL,GAA2BA,mBAAmB,KAAKf,MAAM,KAAG,IAAT,GAAgBA,MAAM,CAACe,mBAAvB,GAA6C,IAAlD,CAA9C;AACA,SAAKC,8BAAL,GAAsChB,MAAM,KAAG,IAAT,GAAgB,KAAKiB,sBAAL,CAA4BjB,MAA5B,EAAoC,KAAKV,KAAzC,CAAhB,GAAkE,KAAxG;AACA,SAAKqB,oBAAL,GAA4BG,cAAc,CAACI,SAAf,CAAyBf,QAArD;AACA,SAAKS,kBAAL,GAA0BE,cAAc,CAACI,SAAf,CAAyBT,MAAnD;AACA,WAAO,IAAP;AACH;;AAEDJ,EAAAA,cAAc,CAACD,IAAD,EAAO;AACjBA,IAAAA,IAAI,CAACG,MAAL,CAAY,KAAKjB,KAAL,CAAWkB,WAAvB,EAAoC,KAAKjB,GAAzC,EAA8C,KAAKC,OAAnD,EAA4D,KAAKC,eAAjE,EAAkF,KAAKuB,8BAAvF,EAAuH,KAAKD,mBAA5H;AACH;;AAEDN,EAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,WAAO,SAASA,KAAT,IACEA,KAAK,YAAYI,cAAjB,IACD,KAAKE,8BAAL,KAAwCN,KAAK,CAACM,8BAD7C,KAEA,KAAKD,mBAAL,GAA2B,KAAKA,mBAAL,CAAyBN,MAAzB,CAAgCC,KAAK,CAACK,mBAAtC,CAA3B,GAAwF,CAACL,KAAK,CAACK,mBAF/F,KAGD,MAAMN,MAAN,CAAaC,KAAb,CAJR;AAKH;;AAEDO,EAAAA,sBAAsB,CAACE,MAAD,EAASC,MAAT,EAAiB;AACnC,WAAOD,MAAM,CAACH,8BAAP,IACFI,MAAM,YAAYtC,aAAnB,IAAqCsC,MAAM,CAACC,SADhD;AAEH;;AA5BkC;;AAgCvCC,MAAM,CAACC,OAAP,CAAezB,SAAf,GAA2BA,SAA3B;AACAwB,MAAM,CAACC,OAAP,CAAeT,cAAf,GAAgCA,cAAhC","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DecisionState} = require('./ATNState');\nconst {SemanticContext} = require('./SemanticContext');\nconst {Hash} = require(\"../Utils\");\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tconst result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tconst props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nclass ATNConfig {\n    /**\n     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n     * The syntactic context is a graph-structured stack node whose\n     * path(s) to the root is the rule invocation(s)\n     * chain used to arrive at the state.  The semantic context is\n     * the tree of semantic predicates encountered before reaching\n     * an ATN state\n     */\n    constructor(params, config) {\n        this.checkContext(params, config);\n        params = checkParams(params);\n        config = checkParams(config, true);\n        // The ATN state associated with this configuration///\n        this.state = params.state!==null ? params.state : config.state;\n        // What alt (or lexer rule) is predicted by this configuration///\n        this.alt = params.alt!==null ? params.alt : config.alt;\n        /**\n         * The stack of invoking states leading to the rule/states associated\n         * with this config.  We track only those contexts pushed during\n         * execution of the ATN simulator\n         */\n        this.context = params.context!==null ? params.context : config.context;\n        this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n        // TODO: make it a boolean then\n        /**\n         * We cannot execute predicates dependent upon local context unless\n         * we know for sure we are in the correct context. Because there is\n         * no way to do this efficiently, we simply cannot evaluate\n         * dependent predicates unless we are in the rule that initially\n         * invokes the ATN simulator.\n         * closure() tracks the depth of how far we dip into the\n         * outer context: depth &gt; 0.  Note that it may not be totally\n         * accurate depth since I don't ever decrement\n         */\n        this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n\n    checkContext(params, config) {\n        if((params.context===null || params.context===undefined) &&\n                (config===null || config.context===null || config.context===undefined)) {\n            this.context = null;\n        }\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish();\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n\n    /**\n     * An ATN configuration is equal to another if both have\n     * the same state, they predict the same alternative, and\n     * syntactic/semantic contexts are the same\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n                this.semanticContext.equals(other.semanticContext) &&\n                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n        }\n    }\n\n    hashCodeForConfigSet() {\n        const hash = new Hash();\n        hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n        return hash.finish();\n    }\n\n    equalsForConfigSet(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                this.semanticContext.equals(other.semanticContext);\n        }\n    }\n\n    toString() {\n        return \"(\" + this.state + \",\" + this.alt +\n            (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n            (this.semanticContext !== SemanticContext.NONE ?\n                    (\",\" + this.semanticContext.toString())\n                    : \"\") +\n            (this.reachesIntoOuterContext>0 ?\n                    (\",up=\" + this.reachesIntoOuterContext)\n                    : \"\") + \")\";\n    }\n}\n\n\nclass LexerATNConfig extends ATNConfig {\n    constructor(params, config) {\n        super(params, config);\n\n        // This is the backing field for {@link //getLexerActionExecutor}.\n        const lexerActionExecutor = params.lexerActionExecutor || null;\n        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n        this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n        return this;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n\n    equals(other) {\n        return this === other ||\n                (other instanceof LexerATNConfig &&\n                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&\n                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n                super.equals(other));\n    }\n\n    checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision ||\n            (target instanceof DecisionState) && target.nonGreedy;\n    }\n}\n\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;\n"]},"metadata":{},"sourceType":"script"}