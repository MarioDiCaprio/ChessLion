{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./Token');\n/* stop is not included! */\n\n\nclass Interval {\n  constructor(start, stop) {\n    this.start = start;\n    this.stop = stop;\n  }\n\n  clone() {\n    return new Interval(this.start, this.stop);\n  }\n\n  contains(item) {\n    return item >= this.start && item < this.stop;\n  }\n\n  toString() {\n    if (this.start === this.stop - 1) {\n      return this.start.toString();\n    } else {\n      return this.start.toString() + \"..\" + (this.stop - 1).toString();\n    }\n  }\n\n  get length() {\n    return this.stop - this.start;\n  }\n\n}\n\nclass IntervalSet {\n  constructor() {\n    this.intervals = null;\n    this.readOnly = false;\n  }\n\n  first(v) {\n    if (this.intervals === null || this.intervals.length === 0) {\n      return Token.INVALID_TYPE;\n    } else {\n      return this.intervals[0].start;\n    }\n  }\n\n  addOne(v) {\n    this.addInterval(new Interval(v, v + 1));\n  }\n\n  addRange(l, h) {\n    this.addInterval(new Interval(l, h + 1));\n  }\n\n  addInterval(toAdd) {\n    if (this.intervals === null) {\n      this.intervals = [];\n      this.intervals.push(toAdd.clone());\n    } else {\n      // find insert pos\n      for (let pos = 0; pos < this.intervals.length; pos++) {\n        const existing = this.intervals[pos]; // distinct range -> insert\n\n        if (toAdd.stop < existing.start) {\n          this.intervals.splice(pos, 0, toAdd);\n          return;\n        } // contiguous range -> adjust\n        else if (toAdd.stop === existing.start) {\n          this.intervals[pos] = new Interval(toAdd.start, existing.stop);\n          return;\n        } // overlapping range -> adjust and reduce\n        else if (toAdd.start <= existing.stop) {\n          this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n          this.reduce(pos);\n          return;\n        }\n      } // greater than any existing\n\n\n      this.intervals.push(toAdd.clone());\n    }\n  }\n\n  addSet(other) {\n    if (other.intervals !== null) {\n      other.intervals.forEach(toAdd => this.addInterval(toAdd), this);\n    }\n\n    return this;\n  }\n\n  reduce(pos) {\n    // only need to reduce if pos is not the last\n    if (pos < this.intervals.length - 1) {\n      const current = this.intervals[pos];\n      const next = this.intervals[pos + 1]; // if next contained in current\n\n      if (current.stop >= next.stop) {\n        this.intervals.splice(pos + 1, 1);\n        this.reduce(pos);\n      } else if (current.stop >= next.start) {\n        this.intervals[pos] = new Interval(current.start, next.stop);\n        this.intervals.splice(pos + 1, 1);\n      }\n    }\n  }\n\n  complement(start, stop) {\n    const result = new IntervalSet();\n    result.addInterval(new Interval(start, stop + 1));\n    if (this.intervals !== null) this.intervals.forEach(toRemove => result.removeRange(toRemove));\n    return result;\n  }\n\n  contains(item) {\n    if (this.intervals === null) {\n      return false;\n    } else {\n      for (let k = 0; k < this.intervals.length; k++) {\n        if (this.intervals[k].contains(item)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }\n\n  removeRange(toRemove) {\n    if (toRemove.start === toRemove.stop - 1) {\n      this.removeOne(toRemove.start);\n    } else if (this.intervals !== null) {\n      let pos = 0;\n\n      for (let n = 0; n < this.intervals.length; n++) {\n        const existing = this.intervals[pos]; // intervals are ordered\n\n        if (toRemove.stop <= existing.start) {\n          return;\n        } // check for including range, split it\n        else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {\n          this.intervals[pos] = new Interval(existing.start, toRemove.start);\n          const x = new Interval(toRemove.stop, existing.stop);\n          this.intervals.splice(pos, 0, x);\n          return;\n        } // check for included range, remove it\n        else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {\n          this.intervals.splice(pos, 1);\n          pos = pos - 1; // need another pass\n        } // check for lower boundary\n        else if (toRemove.start < existing.stop) {\n          this.intervals[pos] = new Interval(existing.start, toRemove.start);\n        } // check for upper boundary\n        else if (toRemove.stop < existing.stop) {\n          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n        }\n\n        pos += 1;\n      }\n    }\n  }\n\n  removeOne(value) {\n    if (this.intervals !== null) {\n      for (let i = 0; i < this.intervals.length; i++) {\n        const existing = this.intervals[i]; // intervals are ordered\n\n        if (value < existing.start) {\n          return;\n        } // check for single value range\n        else if (value === existing.start && value === existing.stop - 1) {\n          this.intervals.splice(i, 1);\n          return;\n        } // check for lower boundary\n        else if (value === existing.start) {\n          this.intervals[i] = new Interval(existing.start + 1, existing.stop);\n          return;\n        } // check for upper boundary\n        else if (value === existing.stop - 1) {\n          this.intervals[i] = new Interval(existing.start, existing.stop - 1);\n          return;\n        } // split existing range\n        else if (value < existing.stop - 1) {\n          const replace = new Interval(existing.start, value);\n          existing.start = value + 1;\n          this.intervals.splice(i, 0, replace);\n          return;\n        }\n      }\n    }\n  }\n\n  toString(literalNames, symbolicNames, elemsAreChar) {\n    literalNames = literalNames || null;\n    symbolicNames = symbolicNames || null;\n    elemsAreChar = elemsAreChar || false;\n\n    if (this.intervals === null) {\n      return \"{}\";\n    } else if (literalNames !== null || symbolicNames !== null) {\n      return this.toTokenString(literalNames, symbolicNames);\n    } else if (elemsAreChar) {\n      return this.toCharString();\n    } else {\n      return this.toIndexString();\n    }\n  }\n\n  toCharString() {\n    const names = [];\n\n    for (let i = 0; i < this.intervals.length; i++) {\n      const existing = this.intervals[i];\n\n      if (existing.stop === existing.start + 1) {\n        if (existing.start === Token.EOF) {\n          names.push(\"<EOF>\");\n        } else {\n          names.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n        }\n      } else {\n        names.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop - 1) + \"'\");\n      }\n    }\n\n    if (names.length > 1) {\n      return \"{\" + names.join(\", \") + \"}\";\n    } else {\n      return names[0];\n    }\n  }\n\n  toIndexString() {\n    const names = [];\n\n    for (let i = 0; i < this.intervals.length; i++) {\n      const existing = this.intervals[i];\n\n      if (existing.stop === existing.start + 1) {\n        if (existing.start === Token.EOF) {\n          names.push(\"<EOF>\");\n        } else {\n          names.push(existing.start.toString());\n        }\n      } else {\n        names.push(existing.start.toString() + \"..\" + (existing.stop - 1).toString());\n      }\n    }\n\n    if (names.length > 1) {\n      return \"{\" + names.join(\", \") + \"}\";\n    } else {\n      return names[0];\n    }\n  }\n\n  toTokenString(literalNames, symbolicNames) {\n    const names = [];\n\n    for (let i = 0; i < this.intervals.length; i++) {\n      const existing = this.intervals[i];\n\n      for (let j = existing.start; j < existing.stop; j++) {\n        names.push(this.elementName(literalNames, symbolicNames, j));\n      }\n    }\n\n    if (names.length > 1) {\n      return \"{\" + names.join(\", \") + \"}\";\n    } else {\n      return names[0];\n    }\n  }\n\n  elementName(literalNames, symbolicNames, token) {\n    if (token === Token.EOF) {\n      return \"<EOF>\";\n    } else if (token === Token.EPSILON) {\n      return \"<EPSILON>\";\n    } else {\n      return literalNames[token] || symbolicNames[token];\n    }\n  }\n\n  get length() {\n    return this.intervals.map(interval => interval.length).reduce((acc, val) => acc + val);\n  }\n\n}\n\nmodule.exports = {\n  Interval,\n  IntervalSet\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/IntervalSet.js"],"names":["Token","require","Interval","constructor","start","stop","clone","contains","item","toString","length","IntervalSet","intervals","readOnly","first","v","INVALID_TYPE","addOne","addInterval","addRange","l","h","toAdd","push","pos","existing","splice","Math","min","max","reduce","addSet","other","forEach","current","next","complement","result","toRemove","removeRange","k","removeOne","n","x","value","i","replace","literalNames","symbolicNames","elemsAreChar","toTokenString","toCharString","toIndexString","names","EOF","String","fromCharCode","join","j","elementName","token","EPSILON","map","interval","acc","val","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\n\n/* stop is not included! */\nclass Interval {\n\n\tconstructor(start, stop) {\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t}\n\n\tclone() {\n\t\treturn new Interval(this.start, this.stop);\n\t}\n\n\tcontains(item) {\n\t\treturn item >= this.start && item < this.stop;\n\t}\n\n\ttoString() {\n\t\tif(this.start===this.stop-1) {\n\t\t\treturn this.start.toString();\n\t\t} else {\n\t\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.stop - this.start;\n\t}\n}\n\n\nclass IntervalSet {\n\tconstructor() {\n\t\tthis.intervals = null;\n\t\tthis.readOnly = false;\n\t}\n\n\tfirst(v) {\n\t\tif (this.intervals === null || this.intervals.length===0) {\n\t\t\treturn Token.INVALID_TYPE;\n\t\t} else {\n\t\t\treturn this.intervals[0].start;\n\t\t}\n\t}\n\n\taddOne(v) {\n\t\tthis.addInterval(new Interval(v, v + 1));\n\t}\n\n\taddRange(l, h) {\n\t\tthis.addInterval(new Interval(l, h + 1));\n\t}\n\n\taddInterval(toAdd) {\n\t\tif (this.intervals === null) {\n\t\t\tthis.intervals = [];\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t} else {\n\t\t\t// find insert pos\n\t\t\tfor (let pos = 0; pos < this.intervals.length; pos++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// distinct range -> insert\n\t\t\t\tif (toAdd.stop < existing.start) {\n\t\t\t\t\tthis.intervals.splice(pos, 0, toAdd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// contiguous range -> adjust\n\t\t\t\telse if (toAdd.stop === existing.start) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toAdd.start, existing.stop)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// overlapping range -> adjust and reduce\n\t\t\t\telse if (toAdd.start <= existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n\t\t\t\t\tthis.reduce(pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// greater than any existing\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t}\n\t}\n\n\taddSet(other) {\n\t\tif (other.intervals !== null) {\n\t\t\tother.intervals.forEach( toAdd => this.addInterval(toAdd), this);\n\t\t}\n\t\treturn this;\n\t}\n\n\treduce(pos) {\n\t\t// only need to reduce if pos is not the last\n\t\tif (pos < this.intervals.length - 1) {\n\t\t\tconst current = this.intervals[pos];\n\t\t\tconst next = this.intervals[pos + 1];\n\t\t\t// if next contained in current\n\t\t\tif (current.stop >= next.stop) {\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t\tthis.reduce(pos);\n\t\t\t} else if (current.stop >= next.start) {\n\t\t\t\tthis.intervals[pos] = new Interval(current.start, next.stop);\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplement(start, stop) {\n\t\tconst result = new IntervalSet();\n\t\tresult.addInterval(new Interval(start, stop + 1));\n\t\tif(this.intervals !== null)\n\t\t\tthis.intervals.forEach(toRemove => result.removeRange(toRemove));\n\t\treturn result;\n\t}\n\n\tcontains(item) {\n\t\tif (this.intervals === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let k = 0; k < this.intervals.length; k++) {\n\t\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tremoveRange(toRemove) {\n\t\tif(toRemove.start===toRemove.stop-1) {\n\t\t\tthis.removeOne(toRemove.start);\n\t\t} else if (this.intervals !== null) {\n\t\t\tlet pos = 0;\n\t\t\tfor(let n=0; n<this.intervals.length; n++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (toRemove.stop<=existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for including range, split it\n\t\t\t\telse if(toRemove.start>existing.start && toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t\tconst x = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t\tthis.intervals.splice(pos, 0, x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for included range, remove it\n\t\t\t\telse if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {\n\t\t\t\t\tthis.intervals.splice(pos, 1);\n\t\t\t\t\tpos = pos - 1; // need another pass\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if(toRemove.start<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if(toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t}\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveOne(value) {\n\t\tif (this.intervals !== null) {\n\t\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\t\tconst existing = this.intervals[i];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (value < existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for single value range\n\t\t\t\telse if (value === existing.start && value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if (value === existing.start) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start + 1, existing.stop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if (value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start, existing.stop - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// split existing range\n\t\t\t\telse if (value < existing.stop - 1) {\n\t\t\t\t\tconst replace = new Interval(existing.start, value);\n\t\t\t\t\texisting.start = value + 1;\n\t\t\t\t\tthis.intervals.splice(i, 0, replace);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(literalNames, symbolicNames, elemsAreChar) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\telemsAreChar = elemsAreChar || false;\n\t\tif (this.intervals === null) {\n\t\t\treturn \"{}\";\n\t\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t\t} else if(elemsAreChar) {\n\t\t\treturn this.toCharString();\n\t\t} else {\n\t\t\treturn this.toIndexString();\n\t\t}\n\t}\n\n\ttoCharString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop-1) + \"'\");\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoIndexString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(existing.start.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(existing.start.toString() + \"..\" + (existing.stop-1).toString());\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoTokenString(literalNames, symbolicNames) {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tfor (let j = existing.start; j < existing.stop; j++) {\n\t\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\telementName(literalNames, symbolicNames, token) {\n\t\tif (token === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (token === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn literalNames[token] || symbolicNames[token];\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);\n\t}\n}\n\nmodule.exports = {\n\tInterval,\n\tIntervalSet\n};\n"]},"metadata":{},"sourceType":"script"}