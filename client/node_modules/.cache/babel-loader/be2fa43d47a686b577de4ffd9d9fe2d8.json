{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  RuleNode\n} = require('./tree/Tree');\n\nconst {\n  INVALID_INTERVAL\n} = require('./tree/Tree');\n\nconst Trees = require('./tree/Trees');\n\nclass RuleContext extends RuleNode {\n  /** A rule context is a record of a single rule invocation. It knows\n   * which context invoked it, if any. If there is no parent context, then\n   * naturally the invoking state is not valid.  The parent link\n   * provides a chain upwards from the current rule invocation to the root\n   * of the invocation tree, forming a stack. We actually carry no\n   * information about the rule associated with this context (except\n   * when parsing). We keep only the state number of the invoking state from\n   * the ATN submachine that invoked this. Contrast this with the s\n   * pointer inside ParserRuleContext that tracks the current state\n   * being \"executed\" for the current rule.\n   *\n   * The parent contexts are useful for computing lookahead sets and\n   * getting error information.\n   *\n   * These objects are used during parsing and prediction.\n   * For the special case of parsers, we use the subclass\n   * ParserRuleContext.\n   *\n   * @see ParserRuleContext\n   */\n  constructor(parent, invokingState) {\n    // What context invoked this rule?\n    super();\n    this.parentCtx = parent || null;\n    /**\n     * What state invoked the rule associated with this context?\n     * The \"return address\" is the followState of invokingState\n     * If parent is null, this should be -1.\n     */\n\n    this.invokingState = invokingState || -1;\n  }\n\n  depth() {\n    let n = 0;\n    let p = this;\n\n    while (p !== null) {\n      p = p.parentCtx;\n      n += 1;\n    }\n\n    return n;\n  }\n  /**\n   * A context is empty if there is no invoking state; meaning nobody call\n   * current context.\n   */\n\n\n  isEmpty() {\n    return this.invokingState === -1;\n  } // satisfy the ParseTree / SyntaxTree interface\n\n\n  getSourceInterval() {\n    return INVALID_INTERVAL;\n  }\n\n  getRuleContext() {\n    return this;\n  }\n\n  getPayload() {\n    return this;\n  }\n  /**\n   * Return the combined text of all child nodes. This method only considers\n   * tokens which have been added to the parse tree.\n   * <p>\n   * Since tokens on hidden channels (e.g. whitespace or comments) are not\n   * added to the parse trees, they will not appear in the output of this\n   * method.\n   */\n\n\n  getText() {\n    if (this.getChildCount() === 0) {\n      return \"\";\n    } else {\n      return this.children.map(function (child) {\n        return child.getText();\n      }).join(\"\");\n    }\n  }\n  /**\n   * For rule associated with this parse tree internal node, return\n   * the outer alternative number used to match the input. Default\n   * implementation does not compute nor store this alt num. Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   * to set it.\n   */\n\n\n  getAltNumber() {\n    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n    return 0;\n  }\n  /**\n   * Set the outer alternative number for this context node. Default\n   * implementation does nothing to avoid backing field overhead for\n   * trees that don't need it.  Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   */\n\n\n  setAltNumber(altNumber) {}\n\n  getChild(i) {\n    return null;\n  }\n\n  getChildCount() {\n    return 0;\n  }\n\n  accept(visitor) {\n    return visitor.visitChildren(this);\n  }\n  /**\n   * Print out a whole tree, not just a node, in LISP format\n   * (root child1 .. childN). Print just a node if this is a leaf.\n   */\n\n\n  toStringTree(ruleNames, recog) {\n    return Trees.toStringTree(this, ruleNames, recog);\n  }\n\n  toString(ruleNames, stop) {\n    ruleNames = ruleNames || null;\n    stop = stop || null;\n    let p = this;\n    let s = \"[\";\n\n    while (p !== null && p !== stop) {\n      if (ruleNames === null) {\n        if (!p.isEmpty()) {\n          s += p.invokingState;\n        }\n      } else {\n        const ri = p.ruleIndex;\n        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : \"\" + ri;\n        s += ruleName;\n      }\n\n      if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n        s += \" \";\n      }\n\n      p = p.parentCtx;\n    }\n\n    s += \"]\";\n    return s;\n  }\n\n}\n\nmodule.exports = RuleContext;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/RuleContext.js"],"names":["RuleNode","require","INVALID_INTERVAL","Trees","RuleContext","constructor","parent","invokingState","parentCtx","depth","n","p","isEmpty","getSourceInterval","getRuleContext","getPayload","getText","getChildCount","children","map","child","join","getAltNumber","setAltNumber","altNumber","getChild","i","accept","visitor","visitChildren","toStringTree","ruleNames","recog","toString","stop","s","ri","ruleIndex","ruleName","length","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {RuleNode} = require('./tree/Tree');\nconst {INVALID_INTERVAL} = require('./tree/Tree');\nconst Trees = require('./tree/Trees');\n\nclass RuleContext extends RuleNode {\n\t/** A rule context is a record of a single rule invocation. It knows\n\t * which context invoked it, if any. If there is no parent context, then\n\t * naturally the invoking state is not valid.  The parent link\n\t * provides a chain upwards from the current rule invocation to the root\n\t * of the invocation tree, forming a stack. We actually carry no\n\t * information about the rule associated with this context (except\n\t * when parsing). We keep only the state number of the invoking state from\n\t * the ATN submachine that invoked this. Contrast this with the s\n\t * pointer inside ParserRuleContext that tracks the current state\n\t * being \"executed\" for the current rule.\n\t *\n\t * The parent contexts are useful for computing lookahead sets and\n\t * getting error information.\n\t *\n\t * These objects are used during parsing and prediction.\n\t * For the special case of parsers, we use the subclass\n\t * ParserRuleContext.\n\t *\n\t * @see ParserRuleContext\n\t */\n\tconstructor(parent, invokingState) {\n\t\t// What context invoked this rule?\n\t\tsuper();\n\t\tthis.parentCtx = parent || null;\n\t\t/**\n\t\t * What state invoked the rule associated with this context?\n\t\t * The \"return address\" is the followState of invokingState\n\t\t * If parent is null, this should be -1.\n\t\t */\n\t\tthis.invokingState = invokingState || -1;\n\t}\n\n\tdepth() {\n\t\tlet n = 0;\n\t\tlet p = this;\n\t\twhile (p !== null) {\n\t\t\tp = p.parentCtx;\n\t\t\tn += 1;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * A context is empty if there is no invoking state; meaning nobody call\n\t * current context.\n\t */\n\tisEmpty() {\n\t\treturn this.invokingState === -1;\n\t}\n\n// satisfy the ParseTree / SyntaxTree interface\n\tgetSourceInterval() {\n\t\treturn INVALID_INTERVAL;\n\t}\n\n\tgetRuleContext() {\n\t\treturn this;\n\t}\n\n\tgetPayload() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the combined text of all child nodes. This method only considers\n\t * tokens which have been added to the parse tree.\n\t * <p>\n\t * Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t * added to the parse trees, they will not appear in the output of this\n\t * method.\n\t */\n\tgetText() {\n\t\tif (this.getChildCount() === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.children.map(function(child) {\n\t\t\t\treturn child.getText();\n\t\t\t}).join(\"\");\n\t\t}\n\t}\n\n\t/**\n\t * For rule associated with this parse tree internal node, return\n\t * the outer alternative number used to match the input. Default\n\t * implementation does not compute nor store this alt num. Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t * to set it.\n\t */\n\tgetAltNumber() {\n\t    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\t    return 0;\n    }\n\n\t/**\n\t * Set the outer alternative number for this context node. Default\n\t * implementation does nothing to avoid backing field overhead for\n\t * trees that don't need it.  Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t */\n\tsetAltNumber(altNumber) { }\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/**\n\t * Print out a whole tree, not just a node, in LISP format\n\t * (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\ttoStringTree(ruleNames, recog) {\n\t\treturn Trees.toStringTree(this, ruleNames, recog);\n\t}\n\n\ttoString(ruleNames, stop) {\n\t\truleNames = ruleNames || null;\n\t\tstop = stop || null;\n\t\tlet p = this;\n\t\tlet s = \"[\";\n\t\twhile (p !== null && p !== stop) {\n\t\t\tif (ruleNames === null) {\n\t\t\t\tif (!p.isEmpty()) {\n\t\t\t\t\ts += p.invokingState;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ri = p.ruleIndex;\n\t\t\t\tconst ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t\t: \"\" + ri;\n\t\t\t\ts += ruleName;\n\t\t\t}\n\t\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\t\ts += \" \";\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\ts += \"]\";\n\t\treturn s;\n\t}\n}\n\nmodule.exports = RuleContext;\n"]},"metadata":{},"sourceType":"script"}