{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  hashStuff\n} = require(\"../Utils\");\n\nconst {\n  LexerIndexedCustomAction\n} = require('./LexerAction');\n\nclass LexerActionExecutor {\n  /**\n   * Represents an executor for a sequence of lexer actions which traversed during\n   * the matching operation of a lexer rule (token).\n   *\n   * <p>The executor tracks position information for position-dependent lexer actions\n   * efficiently, ensuring that actions appearing only at the end of the rule do\n   * not cause bloating of the {@link DFA} created for the lexer.</p>\n   */\n  constructor(lexerActions) {\n    this.lexerActions = lexerActions === null ? [] : lexerActions;\n    /**\n     * Caches the result of {@link //hashCode} since the hash code is an element\n     * of the performance-critical {@link LexerATNConfig//hashCode} operation\n     */\n\n    this.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n    // lexerActions]))\n\n    return this;\n  }\n  /**\n   * Creates a {@link LexerActionExecutor} which encodes the current offset\n   * for position-dependent lexer actions.\n   *\n   * <p>Normally, when the executor encounters lexer actions where\n   * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n   * {@link IntStream//seek} on the input {@link CharStream} to set the input\n   * position to the <em>end</em> of the current token. This behavior provides\n   * for efficient DFA representation of lexer actions which appear at the end\n   * of a lexer rule, even when the lexer rule matches a variable number of\n   * characters.</p>\n   *\n   * <p>Prior to traversing a match transition in the ATN, the current offset\n   * from the token start index is assigned to all position-dependent lexer\n   * actions which have not already been assigned a fixed offset. By storing\n   * the offsets relative to the token start index, the DFA representation of\n   * lexer actions which appear in the middle of tokens remains efficient due\n   * to sharing among tokens of the same length, regardless of their absolute\n   * position in the input stream.</p>\n   *\n   * <p>If the current executor already has offsets assigned to all\n   * position-dependent lexer actions, the method returns {@code this}.</p>\n   *\n   * @param offset The current offset to assign to all position-dependent\n   * lexer actions which do not already have offsets assigned.\n   *\n   * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n   * for all position-dependent lexer actions.\n   */\n\n\n  fixOffsetBeforeMatch(offset) {\n    let updatedLexerActions = null;\n\n    for (let i = 0; i < this.lexerActions.length; i++) {\n      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n        if (updatedLexerActions === null) {\n          updatedLexerActions = this.lexerActions.concat([]);\n        }\n\n        updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);\n      }\n    }\n\n    if (updatedLexerActions === null) {\n      return this;\n    } else {\n      return new LexerActionExecutor(updatedLexerActions);\n    }\n  }\n  /**\n   * Execute the actions encapsulated by this executor within the context of a\n   * particular {@link Lexer}.\n   *\n   * <p>This method calls {@link IntStream//seek} to set the position of the\n   * {@code input} {@link CharStream} prior to calling\n   * {@link LexerAction//execute} on a position-dependent action. Before the\n   * method returns, the input position will be restored to the same position\n   * it was in when the method was invoked.</p>\n   *\n   * @param lexer The lexer instance.\n   * @param input The input stream which is the source for the current token.\n   * When this method is called, the current {@link IntStream//index} for\n   * {@code input} should be the start of the following token, i.e. 1\n   * character past the end of the current token.\n   * @param startIndex The token start index. This value may be passed to\n   * {@link IntStream//seek} to set the {@code input} position to the beginning\n   * of the token.\n   */\n\n\n  execute(lexer, input, startIndex) {\n    let requiresSeek = false;\n    const stopIndex = input.index;\n\n    try {\n      for (let i = 0; i < this.lexerActions.length; i++) {\n        let lexerAction = this.lexerActions[i];\n\n        if (lexerAction instanceof LexerIndexedCustomAction) {\n          const offset = lexerAction.offset;\n          input.seek(startIndex + offset);\n          lexerAction = lexerAction.action;\n          requiresSeek = startIndex + offset !== stopIndex;\n        } else if (lexerAction.isPositionDependent) {\n          input.seek(stopIndex);\n          requiresSeek = false;\n        }\n\n        lexerAction.execute(lexer);\n      }\n    } finally {\n      if (requiresSeek) {\n        input.seek(stopIndex);\n      }\n    }\n  }\n\n  hashCode() {\n    return this.cachedHashCode;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.cachedHashCode);\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof LexerActionExecutor)) {\n      return false;\n    } else if (this.cachedHashCode != other.cachedHashCode) {\n      return false;\n    } else if (this.lexerActions.length != other.lexerActions.length) {\n      return false;\n    } else {\n      const numActions = this.lexerActions.length;\n\n      for (let idx = 0; idx < numActions; ++idx) {\n        if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n  /**\n   * Creates a {@link LexerActionExecutor} which executes the actions for\n   * the input {@code lexerActionExecutor} followed by a specified\n   * {@code lexerAction}.\n   *\n   * @param lexerActionExecutor The executor for actions already traversed by\n   * the lexer while matching a token within a particular\n   * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n   * though it were an empty executor.\n   * @param lexerAction The lexer action to execute after the actions\n   * specified in {@code lexerActionExecutor}.\n   *\n   * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n   * of {@code lexerActionExecutor} and {@code lexerAction}.\n   */\n\n\n  static append(lexerActionExecutor, lexerAction) {\n    if (lexerActionExecutor === null) {\n      return new LexerActionExecutor([lexerAction]);\n    }\n\n    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);\n    return new LexerActionExecutor(lexerActions);\n  }\n\n}\n\nmodule.exports = LexerActionExecutor;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js"],"names":["hashStuff","require","LexerIndexedCustomAction","LexerActionExecutor","constructor","lexerActions","cachedHashCode","fixOffsetBeforeMatch","offset","updatedLexerActions","i","length","isPositionDependent","concat","execute","lexer","input","startIndex","requiresSeek","stopIndex","index","lexerAction","seek","action","hashCode","updateHashCode","hash","update","equals","other","numActions","idx","append","lexerActionExecutor","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {hashStuff} = require(\"../Utils\");\nconst {LexerIndexedCustomAction} = require('./LexerAction');\n\nclass LexerActionExecutor {\n\t/**\n\t * Represents an executor for a sequence of lexer actions which traversed during\n\t * the matching operation of a lexer rule (token).\n\t *\n\t * <p>The executor tracks position information for position-dependent lexer actions\n\t * efficiently, ensuring that actions appearing only at the end of the rule do\n\t * not cause bloating of the {@link DFA} created for the lexer.</p>\n\t */\n\tconstructor(lexerActions) {\n\t\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t\t/**\n\t\t * Caches the result of {@link //hashCode} since the hash code is an element\n\t\t * of the performance-critical {@link LexerATNConfig//hashCode} operation\n\t\t */\n\t\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t\t// lexerActions]))\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * <p>Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n\t * {@link IntStream//seek} on the input {@link CharStream} to set the input\n\t * position to the <em>end</em> of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.</p>\n\t *\n\t * <p>Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.</p>\n\t *\n\t * <p>If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns {@code this}.</p>\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tfixOffsetBeforeMatch(offset) {\n\t\tlet updatedLexerActions = null;\n\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (updatedLexerActions === null) {\n\t\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t\t}\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\t\tthis.lexerActions[i]);\n\t\t\t}\n\t\t}\n\t\tif (updatedLexerActions === null) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * <p>This method calls {@link IntStream//seek} to set the position of the\n\t * {@code input} {@link CharStream} prior to calling\n\t * {@link LexerAction//execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.</p>\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream//index} for\n\t * {@code input} should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream//seek} to set the {@code input} position to the beginning\n\t * of the token.\n\t */\n\texecute(lexer, input, startIndex) {\n\t\tlet requiresSeek = false;\n\t\tconst stopIndex = input.index;\n\t\ttry {\n\t\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\t\tlet lexerAction = this.lexerActions[i];\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tconst offset = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\t\treturn false;\n\t\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst numActions = this.lexerActions.length\n\t\t\tfor (let idx = 0; idx < numActions; ++idx) {\n\t\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input {@code lexerActionExecutor} followed by a specified\n\t * {@code lexerAction}.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n\t * though it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in {@code lexerActionExecutor}.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n\t * of {@code lexerActionExecutor} and {@code lexerAction}.\n\t */\n\tstatic append(lexerActionExecutor, lexerAction) {\n\t\tif (lexerActionExecutor === null) {\n\t\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t\t}\n\t\tconst lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n}\n\n\nmodule.exports = LexerActionExecutor;\n"]},"metadata":{},"sourceType":"script"}