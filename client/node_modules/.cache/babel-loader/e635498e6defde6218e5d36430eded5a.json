{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./../Token');\n\nconst Lexer = require('./../Lexer');\n\nconst ATN = require('./ATN');\n\nconst ATNSimulator = require('./ATNSimulator');\n\nconst {\n  DFAState\n} = require('./../dfa/DFAState');\n\nconst {\n  OrderedATNConfigSet\n} = require('./ATNConfigSet');\n\nconst {\n  PredictionContext\n} = require('./../PredictionContext');\n\nconst {\n  SingletonPredictionContext\n} = require('./../PredictionContext');\n\nconst {\n  RuleStopState\n} = require('./ATNState');\n\nconst {\n  LexerATNConfig\n} = require('./ATNConfig');\n\nconst {\n  Transition\n} = require('./Transition');\n\nconst LexerActionExecutor = require('./LexerActionExecutor');\n\nconst {\n  LexerNoViableAltException\n} = require('./../error/Errors');\n\nfunction resetSimState(sim) {\n  sim.index = -1;\n  sim.line = 0;\n  sim.column = -1;\n  sim.dfaState = null;\n}\n\nclass SimState {\n  constructor() {\n    resetSimState(this);\n  }\n\n  reset() {\n    resetSimState(this);\n  }\n\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n  /**\n   * When we hit an accept state in either the DFA or the ATN, we\n   * have to notify the character stream to start buffering characters\n   * via {@link IntStream//mark} and record the current state. The current sim state\n   * includes the current index into the input, the current line,\n   * and current character position in that line. Note that the Lexer is\n   * tracking the starting line and characterization of the token. These\n   * variables track the \"state\" of the simulator when it hits an accept state.\n   *\n   * <p>We track these variables separately for the DFA and ATN simulation\n   * because the DFA simulation often has to fail over to the ATN\n   * simulation. If the ATN simulation fails, we need the DFA to fall\n   * back to its previously accepted state, if any. If the ATN succeeds,\n   * then the ATN does the accept and the DFA simulator that invoked it\n   * can simply return the predicted token type.</p>\n   */\n  constructor(recog, atn, decisionToDFA, sharedContextCache) {\n    super(atn, sharedContextCache);\n    this.decisionToDFA = decisionToDFA;\n    this.recog = recog;\n    /**\n     * The current token's starting index into the character stream.\n     * Shared across DFA to ATN simulation in case the ATN fails and the\n     * DFA did not have a previous accept state. In this case, we use the\n     * ATN-generated exception object\n     */\n\n    this.startIndex = -1; // line number 1..n within the input///\n\n    this.line = 1;\n    /**\n     * The index of the character relative to the beginning of the line\n     * 0..n-1\n     */\n\n    this.column = 0;\n    this.mode = Lexer.DEFAULT_MODE;\n    /**\n     * Used during DFA/ATN exec to record the most recent accept configuration\n     * info\n     */\n\n    this.prevAccept = new SimState();\n  }\n\n  copyState(simulator) {\n    this.column = simulator.column;\n    this.line = simulator.line;\n    this.mode = simulator.mode;\n    this.startIndex = simulator.startIndex;\n  }\n\n  match(input, mode) {\n    this.match_calls += 1;\n    this.mode = mode;\n    const mark = input.mark();\n\n    try {\n      this.startIndex = input.index;\n      this.prevAccept.reset();\n      const dfa = this.decisionToDFA[mode];\n\n      if (dfa.s0 === null) {\n        return this.matchATN(input);\n      } else {\n        return this.execATN(input, dfa.s0);\n      }\n    } finally {\n      input.release(mark);\n    }\n  }\n\n  reset() {\n    this.prevAccept.reset();\n    this.startIndex = -1;\n    this.line = 1;\n    this.column = 0;\n    this.mode = Lexer.DEFAULT_MODE;\n  }\n\n  matchATN(input) {\n    const startState = this.atn.modeToStartState[this.mode];\n\n    if (LexerATNSimulator.debug) {\n      console.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n    }\n\n    const old_mode = this.mode;\n    const s0_closure = this.computeStartState(input, startState);\n    const suppressEdge = s0_closure.hasSemanticContext;\n    s0_closure.hasSemanticContext = false;\n    const next = this.addDFAState(s0_closure);\n\n    if (!suppressEdge) {\n      this.decisionToDFA[this.mode].s0 = next;\n    }\n\n    const predict = this.execATN(input, next);\n\n    if (LexerATNSimulator.debug) {\n      console.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n    }\n\n    return predict;\n  }\n\n  execATN(input, ds0) {\n    if (LexerATNSimulator.debug) {\n      console.log(\"start state closure=\" + ds0.configs);\n    }\n\n    if (ds0.isAcceptState) {\n      // allow zero-length tokens\n      this.captureSimState(this.prevAccept, input, ds0);\n    }\n\n    let t = input.LA(1);\n    let s = ds0; // s is current/from DFA state\n\n    while (true) {\n      // while more work\n      if (LexerATNSimulator.debug) {\n        console.log(\"execATN loop starting closure: \" + s.configs);\n      }\n      /**\n       * As we move src->trg, src->trg, we keep track of the previous trg to\n       * avoid looking up the DFA state again, which is expensive.\n       * If the previous target was already part of the DFA, we might\n       * be able to avoid doing a reach operation upon t. If s!=null,\n       * it means that semantic predicates didn't prevent us from\n       * creating a DFA state. Once we know s!=null, we check to see if\n       * the DFA state has an edge already for t. If so, we can just reuse\n       * it's configuration set; there's no point in re-computing it.\n       * This is kind of like doing DFA simulation within the ATN\n       * simulation because DFA simulation is really just a way to avoid\n       * computing reach/closure sets. Technically, once we know that\n       * we have a previously added DFA state, we could jump over to\n       * the DFA simulator. But, that would mean popping back and forth\n       * a lot and making things more complicated algorithmically.\n       * This optimization makes a lot of sense for loops within DFA.\n       * A character will take us back to an existing DFA state\n       * that already has lots of edges out of it. e.g., .* in comments.\n       * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n       */\n\n\n      let target = this.getExistingTargetState(s, t); // print(\"Existing:\" + str(target))\n\n      if (target === null) {\n        target = this.computeTargetState(input, s, t); // print(\"Computed:\" + str(target))\n      }\n\n      if (target === ATNSimulator.ERROR) {\n        break;\n      } // If this is a consumable input element, make sure to consume before\n      // capturing the accept state so the input index, line, and char\n      // position accurately reflect the state of the interpreter at the\n      // end of the token.\n\n\n      if (t !== Token.EOF) {\n        this.consume(input);\n      }\n\n      if (target.isAcceptState) {\n        this.captureSimState(this.prevAccept, input, target);\n\n        if (t === Token.EOF) {\n          break;\n        }\n      }\n\n      t = input.LA(1);\n      s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return this.failOrAccept(this.prevAccept, input, s.configs, t);\n  }\n  /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns {@code null}.\n   *\n   * @param s The current DFA state\n   * @param t The next input symbol\n   * @return The existing target DFA state for the given input symbol\n   * {@code t}, or {@code null} if the target state for this edge is not\n   * already cached\n   */\n\n\n  getExistingTargetState(s, t) {\n    if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n      return null;\n    }\n\n    let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\n    if (target === undefined) {\n      target = null;\n    }\n\n    if (LexerATNSimulator.debug && target !== null) {\n      console.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n    }\n\n    return target;\n  }\n  /**\n   * Compute a target state for an edge in the DFA, and attempt to add the\n   * computed state and corresponding edge to the DFA.\n   *\n   * @param input The input stream\n   * @param s The current DFA state\n   * @param t The next input symbol\n   *\n   * @return The computed target DFA state for the given input symbol\n   * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n   * returns {@link //ERROR}.\n   */\n\n\n  computeTargetState(input, s, t) {\n    const reach = new OrderedATNConfigSet(); // if we don't find an existing DFA state\n    // Fill reach starting from closure, following t transitions\n\n    this.getReachableConfigSet(input, s.configs, reach, t);\n\n    if (reach.items.length === 0) {\n      // we got nowhere on t from s\n      if (!reach.hasSemanticContext) {\n        // we got nowhere on t, don't throw out this knowledge; it'd\n        // cause a failover from DFA later.\n        this.addDFAEdge(s, t, ATNSimulator.ERROR);\n      } // stop when we can't match any more char\n\n\n      return ATNSimulator.ERROR;\n    } // Add an edge from s to target DFA found/created for reach\n\n\n    return this.addDFAEdge(s, t, null, reach);\n  }\n\n  failOrAccept(prevAccept, input, reach, t) {\n    if (this.prevAccept.dfaState !== null) {\n      const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n      this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);\n      return prevAccept.dfaState.prediction;\n    } else {\n      // if no accept and EOF is first char, return EOF\n      if (t === Token.EOF && input.index === this.startIndex) {\n        return Token.EOF;\n      }\n\n      throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n    }\n  }\n  /**\n   * Given a starting configuration set, figure out all ATN configurations\n   * we can reach upon input {@code t}. Parameter {@code reach} is a return\n   * parameter.\n   */\n\n\n  getReachableConfigSet(input, closure, reach, t) {\n    // this is used to skip processing for configs which have a lower priority\n    // than a config that already reached an accept state for the same rule\n    let skipAlt = ATN.INVALID_ALT_NUMBER;\n\n    for (let i = 0; i < closure.items.length; i++) {\n      const cfg = closure.items[i];\n      const currentAltReachedAcceptState = cfg.alt === skipAlt;\n\n      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n        continue;\n      }\n\n      if (LexerATNSimulator.debug) {\n        console.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg.toString(this.recog, true));\n      }\n\n      for (let j = 0; j < cfg.state.transitions.length; j++) {\n        const trans = cfg.state.transitions[j]; // for each transition\n\n        const target = this.getReachableTarget(trans, t);\n\n        if (target !== null) {\n          let lexerActionExecutor = cfg.lexerActionExecutor;\n\n          if (lexerActionExecutor !== null) {\n            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n          }\n\n          const treatEofAsEpsilon = t === Token.EOF;\n          const config = new LexerATNConfig({\n            state: target,\n            lexerActionExecutor: lexerActionExecutor\n          }, cfg);\n\n          if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n            // any remaining configs for this alt have a lower priority\n            // than the one that just reached an accept state.\n            skipAlt = cfg.alt;\n          }\n        }\n      }\n    }\n  }\n\n  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n    if (LexerATNSimulator.debug) {\n      console.log(\"ACTION %s\\n\", lexerActionExecutor);\n    } // seek to after last char in token\n\n\n    input.seek(index);\n    this.line = line;\n    this.column = charPos;\n\n    if (lexerActionExecutor !== null && this.recog !== null) {\n      lexerActionExecutor.execute(this.recog, input, startIndex);\n    }\n  }\n\n  getReachableTarget(trans, t) {\n    if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n      return trans.target;\n    } else {\n      return null;\n    }\n  }\n\n  computeStartState(input, p) {\n    const initialContext = PredictionContext.EMPTY;\n    const configs = new OrderedATNConfigSet();\n\n    for (let i = 0; i < p.transitions.length; i++) {\n      const target = p.transitions[i].target;\n      const cfg = new LexerATNConfig({\n        state: target,\n        alt: i + 1,\n        context: initialContext\n      }, null);\n      this.closure(input, cfg, configs, false, false, false);\n    }\n\n    return configs;\n  }\n  /**\n   * Since the alternatives within any lexer decision are ordered by\n   * preference, this method stops pursuing the closure as soon as an accept\n   * state is reached. After the first accept state is reached by depth-first\n   * search from {@code config}, all other (potentially reachable) states for\n   * this rule would have a lower priority.\n   *\n   * @return {Boolean} {@code true} if an accept state is reached, otherwise\n   * {@code false}.\n   */\n\n\n  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n    let cfg = null;\n\n    if (LexerATNSimulator.debug) {\n      console.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n      if (LexerATNSimulator.debug) {\n        if (this.recog !== null) {\n          console.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n        } else {\n          console.log(\"closure at rule stop %s\\n\", config);\n        }\n      }\n\n      if (config.context === null || config.context.hasEmptyPath()) {\n        if (config.context === null || config.context.isEmpty()) {\n          configs.add(config);\n          return true;\n        } else {\n          configs.add(new LexerATNConfig({\n            state: config.state,\n            context: PredictionContext.EMPTY\n          }, config));\n          currentAltReachedAcceptState = true;\n        }\n      }\n\n      if (config.context !== null && !config.context.isEmpty()) {\n        for (let i = 0; i < config.context.length; i++) {\n          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n            const newContext = config.context.getParent(i); // \"pop\" return state\n\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            cfg = new LexerATNConfig({\n              state: returnState,\n              context: newContext\n            }, config);\n            currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n          }\n        }\n      }\n\n      return currentAltReachedAcceptState;\n    } // optimization\n\n\n    if (!config.state.epsilonOnlyTransitions) {\n      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n        configs.add(config);\n      }\n    }\n\n    for (let j = 0; j < config.state.transitions.length; j++) {\n      const trans = config.state.transitions[j];\n      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\n      if (cfg !== null) {\n        currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n      }\n    }\n\n    return currentAltReachedAcceptState;\n  } // side-effect: can alter configs.hasSemanticContext\n\n\n  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {\n    let cfg = null;\n\n    if (trans.serializationType === Transition.RULE) {\n      const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n      cfg = new LexerATNConfig({\n        state: trans.target,\n        context: newContext\n      }, config);\n    } else if (trans.serializationType === Transition.PRECEDENCE) {\n      throw \"Precedence predicates are not supported in lexers.\";\n    } else if (trans.serializationType === Transition.PREDICATE) {\n      // Track traversing semantic predicates. If we traverse,\n      // we cannot add a DFA state for this \"reach\" computation\n      // because the DFA would not test the predicate again in the\n      // future. Rather than creating collections of semantic predicates\n      // like v3 and testing them on prediction, v4 will test them on the\n      // fly all the time using the ATN not the DFA. This is slower but\n      // semantically it's not used that often. One of the key elements to\n      // this predicate mechanism is not adding DFA states that see\n      // predicates immediately afterwards in the ATN. For example,\n      // a : ID {p1}? | ID {p2}? ;\n      // should create the start state for rule 'a' (to save start state\n      // competition), but should not create target of ID state. The\n      // collection of ATN states the following ID references includes\n      // states reached by traversing predicates. Since this is when we\n      // test them, we cannot cash the DFA state target of ID.\n      if (LexerATNSimulator.debug) {\n        console.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n      }\n\n      configs.hasSemanticContext = true;\n\n      if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n        cfg = new LexerATNConfig({\n          state: trans.target\n        }, config);\n      }\n    } else if (trans.serializationType === Transition.ACTION) {\n      if (config.context === null || config.context.hasEmptyPath()) {\n        // execute actions anywhere in the start rule for a token.\n        //\n        // TODO: if the entry rule is invoked recursively, some\n        // actions may be executed during the recursive call. The\n        // problem can appear when hasEmptyPath() is true but\n        // isEmpty() is false. In this case, the config needs to be\n        // split into two contexts - one with just the empty path\n        // and another with everything but the empty path.\n        // Unfortunately, the current algorithm does not allow\n        // getEpsilonTarget to return two configurations, so\n        // additional modifications are needed before we can support\n        // the split operation.\n        const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);\n        cfg = new LexerATNConfig({\n          state: trans.target,\n          lexerActionExecutor: lexerActionExecutor\n        }, config);\n      } else {\n        // ignore actions in referenced rules\n        cfg = new LexerATNConfig({\n          state: trans.target\n        }, config);\n      }\n    } else if (trans.serializationType === Transition.EPSILON) {\n      cfg = new LexerATNConfig({\n        state: trans.target\n      }, config);\n    } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {\n      if (treatEofAsEpsilon) {\n        if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n          cfg = new LexerATNConfig({\n            state: trans.target\n          }, config);\n        }\n      }\n    }\n\n    return cfg;\n  }\n  /**\n   * Evaluate a predicate specified in the lexer.\n   *\n   * <p>If {@code speculative} is {@code true}, this method was called before\n   * {@link //consume} for the matched character. This method should call\n   * {@link //consume} before evaluating the predicate to ensure position\n   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n   * and {@link Lexer//getcolumn}, properly reflect the current\n   * lexer state. This method should restore {@code input} and the simulator\n   * to the original state before returning (i.e. undo the actions made by the\n   * call to {@link //consume}.</p>\n   *\n   * @param input The input stream.\n   * @param ruleIndex The rule containing the predicate.\n   * @param predIndex The index of the predicate within the rule.\n   * @param speculative {@code true} if the current index in {@code input} is\n   * one character before the predicate's location.\n   *\n   * @return {@code true} if the specified predicate evaluates to\n   * {@code true}.\n   */\n\n\n  evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n    // assume true if no recognizer was provided\n    if (this.recog === null) {\n      return true;\n    }\n\n    if (!speculative) {\n      return this.recog.sempred(null, ruleIndex, predIndex);\n    }\n\n    const savedcolumn = this.column;\n    const savedLine = this.line;\n    const index = input.index;\n    const marker = input.mark();\n\n    try {\n      this.consume(input);\n      return this.recog.sempred(null, ruleIndex, predIndex);\n    } finally {\n      this.column = savedcolumn;\n      this.line = savedLine;\n      input.seek(index);\n      input.release(marker);\n    }\n  }\n\n  captureSimState(settings, input, dfaState) {\n    settings.index = input.index;\n    settings.line = this.line;\n    settings.column = this.column;\n    settings.dfaState = dfaState;\n  }\n\n  addDFAEdge(from_, tk, to, cfgs) {\n    if (to === undefined) {\n      to = null;\n    }\n\n    if (cfgs === undefined) {\n      cfgs = null;\n    }\n\n    if (to === null && cfgs !== null) {\n      // leading to this call, ATNConfigSet.hasSemanticContext is used as a\n      // marker indicating dynamic predicate evaluation makes this edge\n      // dependent on the specific input sequence, so the static edge in the\n      // DFA should be omitted. The target DFAState is still created since\n      // execATN has the ability to resynchronize with the DFA state cache\n      // following the predicate evaluation step.\n      //\n      // TJP notes: next time through the DFA, we see a pred again and eval.\n      // If that gets us to a previously created (but dangling) DFA\n      // state, we can continue in pure DFA mode from there.\n      // /\n      const suppressEdge = cfgs.hasSemanticContext;\n      cfgs.hasSemanticContext = false;\n      to = this.addDFAState(cfgs);\n\n      if (suppressEdge) {\n        return to;\n      }\n    } // add the edge\n\n\n    if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n      // Only track edges within the DFA bounds\n      return to;\n    }\n\n    if (LexerATNSimulator.debug) {\n      console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n    }\n\n    if (from_.edges === null) {\n      // make room for tokens 1..n and -1 masquerading as index 0\n      from_.edges = [];\n    }\n\n    from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n    return to;\n  }\n  /**\n   * Add a new DFA state if there isn't one with this set of\n   * configurations already. This method also detects the first\n   * configuration containing an ATN rule stop state. Later, when\n   * traversing the DFA, we will know which rule to accept.\n   */\n\n\n  addDFAState(configs) {\n    const proposed = new DFAState(null, configs);\n    let firstConfigWithRuleStopState = null;\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const cfg = configs.items[i];\n\n      if (cfg.state instanceof RuleStopState) {\n        firstConfigWithRuleStopState = cfg;\n        break;\n      }\n    }\n\n    if (firstConfigWithRuleStopState !== null) {\n      proposed.isAcceptState = true;\n      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n    }\n\n    const dfa = this.decisionToDFA[this.mode];\n    const existing = dfa.states.get(proposed);\n\n    if (existing !== null) {\n      return existing;\n    }\n\n    const newState = proposed;\n    newState.stateNumber = dfa.states.length;\n    configs.setReadonly(true);\n    newState.configs = configs;\n    dfa.states.add(newState);\n    return newState;\n  }\n\n  getDFA(mode) {\n    return this.decisionToDFA[mode];\n  } // Get the text matched so far for the current token.\n\n\n  getText(input) {\n    // index is first lookahead char, don't include.\n    return input.getText(this.startIndex, input.index - 1);\n  }\n\n  consume(input) {\n    const curChar = input.LA(1);\n\n    if (curChar === \"\\n\".charCodeAt(0)) {\n      this.line += 1;\n      this.column = 0;\n    } else {\n      this.column += 1;\n    }\n\n    input.consume();\n  }\n\n  getTokenName(tt) {\n    if (tt === -1) {\n      return \"EOF\";\n    } else {\n      return \"'\" + String.fromCharCode(tt) + \"'\";\n    }\n  }\n\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\nmodule.exports = LexerATNSimulator;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js"],"names":["Token","require","Lexer","ATN","ATNSimulator","DFAState","OrderedATNConfigSet","PredictionContext","SingletonPredictionContext","RuleStopState","LexerATNConfig","Transition","LexerActionExecutor","LexerNoViableAltException","resetSimState","sim","index","line","column","dfaState","SimState","constructor","reset","LexerATNSimulator","recog","atn","decisionToDFA","sharedContextCache","startIndex","mode","DEFAULT_MODE","prevAccept","copyState","simulator","match","input","match_calls","mark","dfa","s0","matchATN","execATN","release","startState","modeToStartState","debug","console","log","old_mode","s0_closure","computeStartState","suppressEdge","hasSemanticContext","next","addDFAState","predict","toLexerString","ds0","configs","isAcceptState","captureSimState","t","LA","s","target","getExistingTargetState","computeTargetState","ERROR","EOF","consume","failOrAccept","edges","MIN_DFA_EDGE","MAX_DFA_EDGE","undefined","stateNumber","reach","getReachableConfigSet","items","length","addDFAEdge","lexerActionExecutor","accept","prediction","closure","skipAlt","INVALID_ALT_NUMBER","i","cfg","currentAltReachedAcceptState","alt","passedThroughNonGreedyDecision","getTokenName","toString","j","state","transitions","trans","getReachableTarget","fixOffsetBeforeMatch","treatEofAsEpsilon","config","charPos","seek","execute","matches","MAX_CHAR_VALUE","p","initialContext","EMPTY","context","speculative","ruleNames","ruleIndex","hasEmptyPath","isEmpty","add","getReturnState","EMPTY_RETURN_STATE","newContext","getParent","returnState","states","epsilonOnlyTransitions","getEpsilonTarget","serializationType","RULE","create","followState","PRECEDENCE","PREDICATE","predIndex","evaluatePredicate","ACTION","append","lexerActions","actionIndex","EPSILON","ATOM","RANGE","SET","sempred","savedcolumn","savedLine","marker","settings","from_","tk","to","cfgs","proposed","firstConfigWithRuleStopState","ruleToTokenType","existing","get","newState","setReadonly","getDFA","getText","curChar","charCodeAt","tt","String","fromCharCode","dfa_debug","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst Lexer = require('./../Lexer');\nconst ATN = require('./ATN');\nconst ATNSimulator = require('./ATNSimulator');\nconst {DFAState} = require('./../dfa/DFAState');\nconst {OrderedATNConfigSet} = require('./ATNConfigSet');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {SingletonPredictionContext} = require('./../PredictionContext');\nconst {RuleStopState} = require('./ATNState');\nconst {LexerATNConfig} = require('./ATNConfig');\nconst {Transition} = require('./Transition');\nconst LexerActionExecutor = require('./LexerActionExecutor');\nconst {LexerNoViableAltException} = require('./../error/Errors');\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nclass SimState {\n\tconstructor() {\n\t\tresetSimState(this);\n\t}\n\n\treset() {\n\t\tresetSimState(this);\n\t}\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n\t/**\n\t * When we hit an accept state in either the DFA or the ATN, we\n\t * have to notify the character stream to start buffering characters\n\t * via {@link IntStream//mark} and record the current state. The current sim state\n\t * includes the current index into the input, the current line,\n\t * and current character position in that line. Note that the Lexer is\n\t * tracking the starting line and characterization of the token. These\n\t * variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t * <p>We track these variables separately for the DFA and ATN simulation\n\t * because the DFA simulation often has to fail over to the ATN\n\t * simulation. If the ATN simulation fails, we need the DFA to fall\n\t * back to its previously accepted state, if any. If the ATN succeeds,\n\t * then the ATN does the accept and the DFA simulator that invoked it\n\t * can simply return the predicted token type.</p>\n\t */\n\tconstructor(recog, atn, decisionToDFA, sharedContextCache) {\n\t\tsuper(atn, sharedContextCache);\n\t\tthis.decisionToDFA = decisionToDFA;\n\t\tthis.recog = recog;\n\t\t/**\n\t\t * The current token's starting index into the character stream.\n\t\t * Shared across DFA to ATN simulation in case the ATN fails and the\n\t\t * DFA did not have a previous accept state. In this case, we use the\n\t\t * ATN-generated exception object\n\t\t */\n\t\tthis.startIndex = -1;\n\t\t// line number 1..n within the input///\n\t\tthis.line = 1;\n\t\t/**\n\t\t * The index of the character relative to the beginning of the line\n\t\t * 0..n-1\n\t\t */\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t\t/**\n\t\t * Used during DFA/ATN exec to record the most recent accept configuration\n\t\t * info\n\t\t */\n\t\tthis.prevAccept = new SimState();\n\t}\n\n\tcopyState(simulator) {\n\t\tthis.column = simulator.column;\n\t\tthis.line = simulator.line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tmatch(input, mode) {\n\t\tthis.match_calls += 1;\n\t\tthis.mode = mode;\n\t\tconst mark = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tconst dfa = this.decisionToDFA[mode];\n\t\t\tif (dfa.s0 === null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t} else {\n\t\t\t\treturn this.execATN(input, dfa.s0);\n\t\t\t}\n\t\t} finally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis.line = 1;\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tmatchATN(input) {\n\t\tconst startState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t\t}\n\t\tconst old_mode = this.mode;\n\t\tconst s0_closure = this.computeStartState(input, startState);\n\t\tconst suppressEdge = s0_closure.hasSemanticContext;\n\t\ts0_closure.hasSemanticContext = false;\n\n\t\tconst next = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t\t}\n\n\t\tconst predict = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t\t}\n\t\treturn predict;\n\t}\n\n\texecATN(input, ds0) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t\t}\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\t\tlet t = input.LA(1);\n\t\tlet s = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t * avoid looking up the DFA state again, which is expensive.\n\t\t\t * If the previous target was already part of the DFA, we might\n\t\t\t * be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t * it means that semantic predicates didn't prevent us from\n\t\t\t * creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t * the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t * it's configuration set; there's no point in re-computing it.\n\t\t\t * This is kind of like doing DFA simulation within the ATN\n\t\t\t * simulation because DFA simulation is really just a way to avoid\n\t\t\t * computing reach/closure sets. Technically, once we know that\n\t\t\t * we have a previously added DFA state, we could jump over to\n\t\t\t * the DFA simulator. But, that would mean popping back and forth\n\t\t\t * a lot and making things more complicated algorithmically.\n\t\t\t * This optimization makes a lot of sense for loops within DFA.\n\t\t\t * A character will take us back to an existing DFA state\n\t\t\t * that already has lots of edges out of it. e.g., .* in comments.\n\t\t\t * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\t\t */\n\t\t\tlet target = this.getExistingTargetState(s, t);\n\t\t\t// print(\"Existing:\" + str(target))\n\t\t\tif (target === null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t\t// print(\"Computed:\" + str(target))\n\t\t\t}\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== Token.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === Token.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\tgetExistingTargetState(s, t) {\n\t\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\t\tif(target===undefined) {\n\t\t\ttarget = null;\n\t\t}\n\t\tif (LexerATNSimulator.debug && target !== null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link //ERROR}.\n\t */\n\tcomputeTargetState(input, s, t) {\n\t\tconst reach = new OrderedATNConfigSet();\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, null, reach);\n\t}\n\n\tfailOrAccept(prevAccept, input, reach, t) {\n\t\tif (this.prevAccept.dfaState !== null) {\n\t\t\tconst lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t} else {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/**\n\t * Given a starting configuration set, figure out all ATN configurations\n\t * we can reach upon input {@code t}. Parameter {@code reach} is a return\n\t * parameter.\n\t */\n\tgetReachableConfigSet(input, closure,\n\t\t\treach, t) {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let i = 0; i < closure.items.length; i++) {\n\t\t\tconst cfg = closure.items[i];\n\t\t\tconst currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t\t.toString(this.recog, true));\n\t\t\t}\n\t\t\tfor (let j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\t\tconst trans = cfg.state.transitions[j]; // for each transition\n\t\t\t\tconst target = this.getReachableTarget(trans, t);\n\t\t\t\tif (target !== null) {\n\t\t\t\t\tlet lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t}\n\t\t\t\t\tconst treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\t\tconst config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taccept(input, lexerActionExecutor,\n\t\t\t   startIndex, index, line, charPos) {\n\t\t   if (LexerATNSimulator.debug) {\n\t\t\t   console.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t\t   }\n\t\t   // seek to after last char in token\n\t\t   input.seek(index);\n\t\t   this.line = line;\n\t\t   this.column = charPos;\n\t\t   if (lexerActionExecutor !== null && this.recog !== null) {\n\t\t\t   lexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t   }\n\t   }\n\n\tgetReachableTarget(trans, t) {\n\t\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcomputeStartState(input, p) {\n\t\tconst initialContext = PredictionContext.EMPTY;\n\t\tconst configs = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.transitions.length; i++) {\n\t\t\tconst target = p.transitions[i].target;\n\t\t\tconst cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\t\tthis.closure(input, cfg, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from {@code config}, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @return {Boolean} {@code true} if an accept state is reached, otherwise\n\t * {@code false}.\n\t */\n\tclosure(input, config, configs,\n\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog !== null) {\n\t\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\t\tfor (let i = 0; i < config.context.length; i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tconst newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tconst returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\t\t// optimization\n\t\tif (!config.state.epsilonOnlyTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < config.state.transitions.length; j++) {\n\t\t\tconst trans = config.state.transitions[j];\n\t\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (cfg !== null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tgetEpsilonTarget(input, config, trans,\n\t\t\tconfigs, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (trans.serializationType === Transition.RULE) {\n\t\t\tconst newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t\t// Track traversing semantic predicates. If we traverse,\n\t\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t\t// because the DFA would not test the predicate again in the\n\t\t\t// future. Rather than creating collections of semantic predicates\n\t\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t\t// semantically it's not used that often. One of the key elements to\n\t\t\t// this predicate mechanism is not adding DFA states that see\n\t\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t\t// should create the start state for rule 'a' (to save start state\n\t\t\t// competition), but should not create target of ID state. The\n\t\t\t// collection of ATN states the following ID references includes\n\t\t\t// states reached by traversing predicates. Since this is when we\n\t\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.ACTION) {\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tconst lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t\t} else {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cfg;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * <p>If {@code speculative} is {@code true}, this method was called before\n\t * {@link //consume} for the matched character. This method should call\n\t * {@link //consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n\t * and {@link Lexer//getcolumn}, properly reflect the current\n\t * lexer state. This method should restore {@code input} and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link //consume}.</p>\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative {@code true} if the current index in {@code input} is\n\t * one character before the predicate's location.\n\t *\n\t * @return {@code true} if the specified predicate evaluates to\n\t * {@code true}.\n\t */\n\tevaluatePredicate(input, ruleIndex,\n\t\t\tpredIndex, speculative) {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t}\n\t\tconst savedcolumn = this.column;\n\t\tconst savedLine = this.line;\n\t\tconst index = input.index;\n\t\tconst marker = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t} finally {\n\t\t\tthis.column = savedcolumn;\n\t\t\tthis.line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tcaptureSimState(settings, input, dfaState) {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this.line;\n\t\tsettings.column = this.column;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\taddDFAEdge(from_, tk, to, cfgs) {\n\t\tif (to === undefined) {\n\t\t\tto = null;\n\t\t}\n\t\tif (cfgs === undefined) {\n\t\t\tcfgs = null;\n\t\t}\n\t\tif (to === null && cfgs !== null) {\n\t\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t\t// following the predicate evaluation step.\n\t\t\t//\n\t\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t\t// state, we can continue in pure DFA mode from there.\n\t\t\t// /\n\t\t\tconst suppressEdge = cfgs.hasSemanticContext;\n\t\t\tcfgs.hasSemanticContext = false;\n\n\t\t\tto = this.addDFAState(cfgs);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\t// add the edge\n\t\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\t// Only track edges within the DFA bounds\n\t\t\treturn to;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t\t}\n\t\tif (from_.edges === null) {\n\t\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\t\tfrom_.edges = [];\n\t\t}\n\t\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\t\treturn to;\n\t}\n\n\t/**\n\t * Add a new DFA state if there isn't one with this set of\n\t * configurations already. This method also detects the first\n\t * configuration containing an ATN rule stop state. Later, when\n\t * traversing the DFA, we will know which rule to accept.\n\t */\n\taddDFAState(configs) {\n\t\tconst proposed = new DFAState(null, configs);\n\t\tlet firstConfigWithRuleStopState = null;\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tconst cfg = configs.items[i];\n\t\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (firstConfigWithRuleStopState !== null) {\n\t\t\tproposed.isAcceptState = true;\n\t\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t}\n\t\tconst dfa = this.decisionToDFA[this.mode];\n\t\tconst existing = dfa.states.get(proposed);\n\t\tif (existing!==null) {\n\t\t\treturn existing;\n\t\t}\n\t\tconst newState = proposed;\n\t\tnewState.stateNumber = dfa.states.length;\n\t\tconfigs.setReadonly(true);\n\t\tnewState.configs = configs;\n\t\tdfa.states.add(newState);\n\t\treturn newState;\n\t}\n\n\tgetDFA(mode) {\n\t\treturn this.decisionToDFA[mode];\n\t}\n\n// Get the text matched so far for the current token.\n\tgetText(input) {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(this.startIndex, input.index - 1);\n\t}\n\n\tconsume(input) {\n\t\tconst curChar = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis.line += 1;\n\t\t\tthis.column = 0;\n\t\t} else {\n\t\t\tthis.column += 1;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\tgetTokenName(tt) {\n\t\tif (tt === -1) {\n\t\t\treturn \"EOF\";\n\t\t} else {\n\t\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t\t}\n\t}\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nmodule.exports = LexerATNSimulator;\n"]},"metadata":{},"sourceType":"script"}