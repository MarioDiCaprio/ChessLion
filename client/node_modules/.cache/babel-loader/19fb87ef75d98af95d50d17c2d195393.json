{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst RuleContext = require('./RuleContext');\n\nconst {\n  Hash,\n  Map,\n  equalArrays\n} = require('./Utils');\n\nclass PredictionContext {\n  constructor(cachedHashCode) {\n    this.cachedHashCode = cachedHashCode;\n  }\n  /**\n   * Stores the computed hash code of this {@link PredictionContext}. The hash\n   * code is computed in parts to match the following reference algorithm.\n   *\n   * <pre>\n   * private int referenceHashCode() {\n   * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n   * //INITIAL_HASH});\n   *\n   * for (int i = 0; i &lt; {@link //size()}; i++) {\n   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n   * getParent}(i));\n   * }\n   *\n   * for (int i = 0; i &lt; {@link //size()}; i++) {\n   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n   * //getReturnState getReturnState}(i));\n   * }\n   *\n   * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n   * //size()});\n   * return hash;\n   * }\n   * </pre>\n   * This means only the {@link //EMPTY} context is in set.\n   */\n\n\n  isEmpty() {\n    return this === PredictionContext.EMPTY;\n  }\n\n  hasEmptyPath() {\n    return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n  }\n\n  hashCode() {\n    return this.cachedHashCode;\n  }\n\n  updateHashCode(hash) {\n    hash.update(this.cachedHashCode);\n  }\n\n}\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\n\n\nPredictionContext.EMPTY = null;\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\n\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\n\nclass PredictionContextCache {\n  constructor() {\n    this.cache = new Map();\n  }\n  /**\n   * Add a context to the cache and return it. If the context already exists,\n   * return that one instead and do not add a new context to the cache.\n   * Protect shared cache from unsafe thread access.\n   */\n\n\n  add(ctx) {\n    if (ctx === PredictionContext.EMPTY) {\n      return PredictionContext.EMPTY;\n    }\n\n    const existing = this.cache.get(ctx) || null;\n\n    if (existing !== null) {\n      return existing;\n    }\n\n    this.cache.put(ctx, ctx);\n    return ctx;\n  }\n\n  get(ctx) {\n    return this.cache.get(ctx) || null;\n  }\n\n  get length() {\n    return this.cache.length;\n  }\n\n}\n\nclass SingletonPredictionContext extends PredictionContext {\n  constructor(parent, returnState) {\n    let hashCode = 0;\n    const hash = new Hash();\n\n    if (parent !== null) {\n      hash.update(parent, returnState);\n    } else {\n      hash.update(1);\n    }\n\n    hashCode = hash.finish();\n    super(hashCode);\n    this.parentCtx = parent;\n    this.returnState = returnState;\n  }\n\n  getParent(index) {\n    return this.parentCtx;\n  }\n\n  getReturnState(index) {\n    return this.returnState;\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof SingletonPredictionContext)) {\n      return false;\n    } else if (this.hashCode() !== other.hashCode()) {\n      return false; // can't be same if hash is different\n    } else {\n      if (this.returnState !== other.returnState) return false;else if (this.parentCtx == null) return other.parentCtx == null;else return this.parentCtx.equals(other.parentCtx);\n    }\n  }\n\n  toString() {\n    const up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\n    if (up.length === 0) {\n      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n        return \"$\";\n      } else {\n        return \"\" + this.returnState;\n      }\n    } else {\n      return \"\" + this.returnState + \" \" + up;\n    }\n  }\n\n  get length() {\n    return 1;\n  }\n\n  static create(parent, returnState) {\n    if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n      // someone can pass in the bits of an array ctx that mean $\n      return PredictionContext.EMPTY;\n    } else {\n      return new SingletonPredictionContext(parent, returnState);\n    }\n  }\n\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n  constructor() {\n    super(null, PredictionContext.EMPTY_RETURN_STATE);\n  }\n\n  isEmpty() {\n    return true;\n  }\n\n  getParent(index) {\n    return null;\n  }\n\n  getReturnState(index) {\n    return this.returnState;\n  }\n\n  equals(other) {\n    return this === other;\n  }\n\n  toString() {\n    return \"$\";\n  }\n\n}\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n  constructor(parents, returnStates) {\n    /**\n     * Parent can be null only if full ctx mode and we make an array\n     * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n     * null parent and\n     * returnState == {@link //EMPTY_RETURN_STATE}.\n     */\n    const h = new Hash();\n    h.update(parents, returnStates);\n    const hashCode = h.finish();\n    super(hashCode);\n    this.parents = parents;\n    this.returnStates = returnStates;\n    return this;\n  }\n\n  isEmpty() {\n    // since EMPTY_RETURN_STATE can only appear in the last position, we\n    // don't need to verify that size==1\n    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n  }\n\n  getParent(index) {\n    return this.parents[index];\n  }\n\n  getReturnState(index) {\n    return this.returnStates[index];\n  }\n\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof ArrayPredictionContext)) {\n      return false;\n    } else if (this.hashCode() !== other.hashCode()) {\n      return false; // can't be same if hash is different\n    } else {\n      return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);\n    }\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return \"[]\";\n    } else {\n      let s = \"[\";\n\n      for (let i = 0; i < this.returnStates.length; i++) {\n        if (i > 0) {\n          s = s + \", \";\n        }\n\n        if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n          s = s + \"$\";\n          continue;\n        }\n\n        s = s + this.returnStates[i];\n\n        if (this.parents[i] !== null) {\n          s = s + \" \" + this.parents[i];\n        } else {\n          s = s + \"null\";\n        }\n      }\n\n      return s + \"]\";\n    }\n  }\n\n  get length() {\n    return this.returnStates.length;\n  }\n\n}\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\n\n\nfunction predictionContextFromRuleContext(atn, outerContext) {\n  if (outerContext === undefined || outerContext === null) {\n    outerContext = RuleContext.EMPTY;\n  } // if we are in RuleContext of start rule, s, then PredictionContext\n  // is EMPTY. Nobody called us. (if we are empty, return empty)\n\n\n  if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n    return PredictionContext.EMPTY;\n  } // If we have a parent, convert it to a PredictionContext graph\n\n\n  const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n  const state = atn.states[outerContext.invokingState];\n  const transition = state.transitions[0];\n  return SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\n\n\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n  // share same graph if both same\n  if (a === b) {\n    return a;\n  }\n\n  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n    return mergeSingletons(a, b, rootIsWildcard, mergeCache);\n  } // At least one of a or b is array\n  // If one is $ and rootIsWildcard, return $ as// wildcard\n\n\n  if (rootIsWildcard) {\n    if (a instanceof EmptyPredictionContext) {\n      return a;\n    }\n\n    if (b instanceof EmptyPredictionContext) {\n      return b;\n    }\n  } // convert singleton so both are arrays to normalize\n\n\n  if (a instanceof SingletonPredictionContext) {\n    a = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n  }\n\n  if (b instanceof SingletonPredictionContext) {\n    b = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n  }\n\n  return mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\n\n\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n  if (mergeCache !== null) {\n    let previous = mergeCache.get(a, b);\n\n    if (previous !== null) {\n      return previous;\n    }\n\n    previous = mergeCache.get(b, a);\n\n    if (previous !== null) {\n      return previous;\n    }\n  }\n\n  const rootMerge = mergeRoot(a, b, rootIsWildcard);\n\n  if (rootMerge !== null) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, rootMerge);\n    }\n\n    return rootMerge;\n  }\n\n  if (a.returnState === b.returnState) {\n    const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache); // if parent is same as existing a or b parent or reduced to a parent,\n    // return it\n\n    if (parent === a.parentCtx) {\n      return a; // ax + bx = ax, if a=b\n    }\n\n    if (parent === b.parentCtx) {\n      return b; // ax + bx = bx, if a=b\n    } // else: ax + ay = a'[x,y]\n    // merge parents x and y, giving array node with x,y then remainders\n    // of those graphs. dup a, a' points at merged array\n    // new joined parent so create new singleton pointing to it, a'\n\n\n    const spc = SingletonPredictionContext.create(parent, a.returnState);\n\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, spc);\n    }\n\n    return spc;\n  } else {\n    // a != b payloads differ\n    // see if we can collapse parents due to $+x parents if local ctx\n    let singleParent = null;\n\n    if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {\n      // ax +\n      // bx =\n      // [a,b]x\n      singleParent = a.parentCtx;\n    }\n\n    if (singleParent !== null) {\n      // parents are same\n      // sort payloads and use same parent\n      const payloads = [a.returnState, b.returnState];\n\n      if (a.returnState > b.returnState) {\n        payloads[0] = b.returnState;\n        payloads[1] = a.returnState;\n      }\n\n      const parents = [singleParent, singleParent];\n      const apc = new ArrayPredictionContext(parents, payloads);\n\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, apc);\n      }\n\n      return apc;\n    } // parents differ and can't merge them. Just pack together\n    // into array; can't merge.\n    // ax + by = [ax,by]\n\n\n    const payloads = [a.returnState, b.returnState];\n    let parents = [a.parentCtx, b.parentCtx];\n\n    if (a.returnState > b.returnState) {\n      // sort by payload\n      payloads[0] = b.returnState;\n      payloads[1] = a.returnState;\n      parents = [b.parentCtx, a.parentCtx];\n    }\n\n    const a_ = new ArrayPredictionContext(parents, payloads);\n\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, a_);\n    }\n\n    return a_;\n  }\n}\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\n\n\nfunction mergeRoot(a, b, rootIsWildcard) {\n  if (rootIsWildcard) {\n    if (a === PredictionContext.EMPTY) {\n      return PredictionContext.EMPTY; // // + b =//\n    }\n\n    if (b === PredictionContext.EMPTY) {\n      return PredictionContext.EMPTY; // a +// =//\n    }\n  } else {\n    if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n      return PredictionContext.EMPTY; // $ + $ = $\n    } else if (a === PredictionContext.EMPTY) {\n      // $ + x = [$,x]\n      const payloads = [b.returnState, PredictionContext.EMPTY_RETURN_STATE];\n      const parents = [b.parentCtx, null];\n      return new ArrayPredictionContext(parents, payloads);\n    } else if (b === PredictionContext.EMPTY) {\n      // x + $ = [$,x] ($ is always first if present)\n      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];\n      const parents = [a.parentCtx, null];\n      return new ArrayPredictionContext(parents, payloads);\n    }\n  }\n\n  return null;\n}\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\n\n\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n  if (mergeCache !== null) {\n    let previous = mergeCache.get(a, b);\n\n    if (previous !== null) {\n      return previous;\n    }\n\n    previous = mergeCache.get(b, a);\n\n    if (previous !== null) {\n      return previous;\n    }\n  } // merge sorted payloads a + b => M\n\n\n  let i = 0; // walks a\n\n  let j = 0; // walks b\n\n  let k = 0; // walks target M array\n\n  let mergedReturnStates = [];\n  let mergedParents = []; // walk and merge to yield mergedParents, mergedReturnStates\n\n  while (i < a.returnStates.length && j < b.returnStates.length) {\n    const a_parent = a.parents[i];\n    const b_parent = b.parents[j];\n\n    if (a.returnStates[i] === b.returnStates[j]) {\n      // same payload (stack tops are equal), must yield merged singleton\n      const payload = a.returnStates[i]; // $+$ = $\n\n      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;\n      const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent; // ax+ax\n      // ->\n      // ax\n\n      if (bothDollars || ax_ax) {\n        mergedParents[k] = a_parent; // choose left\n\n        mergedReturnStates[k] = payload;\n      } else {\n        // ax+ay -> a'[x,y]\n        mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n        mergedReturnStates[k] = payload;\n      }\n\n      i += 1; // hop over left one as usual\n\n      j += 1; // but also skip one in right side since we merge\n    } else if (a.returnStates[i] < b.returnStates[j]) {\n      // copy a[i] to M\n      mergedParents[k] = a_parent;\n      mergedReturnStates[k] = a.returnStates[i];\n      i += 1;\n    } else {\n      // b > a, copy b[j] to M\n      mergedParents[k] = b_parent;\n      mergedReturnStates[k] = b.returnStates[j];\n      j += 1;\n    }\n\n    k += 1;\n  } // copy over any payloads remaining in either array\n\n\n  if (i < a.returnStates.length) {\n    for (let p = i; p < a.returnStates.length; p++) {\n      mergedParents[k] = a.parents[p];\n      mergedReturnStates[k] = a.returnStates[p];\n      k += 1;\n    }\n  } else {\n    for (let p = j; p < b.returnStates.length; p++) {\n      mergedParents[k] = b.parents[p];\n      mergedReturnStates[k] = b.returnStates[p];\n      k += 1;\n    }\n  } // trim merged if we combined a few that had same stack tops\n\n\n  if (k < mergedParents.length) {\n    // write index < last position; trim\n    if (k === 1) {\n      // for just one merged element, return singleton top\n      const a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);\n\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, a_);\n      }\n\n      return a_;\n    }\n\n    mergedParents = mergedParents.slice(0, k);\n    mergedReturnStates = mergedReturnStates.slice(0, k);\n  }\n\n  const M = new ArrayPredictionContext(mergedParents, mergedReturnStates); // if we created same array as a or b, return that instead\n  // TODO: track whether this is possible above during merge sort for speed\n\n  if (M === a) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, a);\n    }\n\n    return a;\n  }\n\n  if (M === b) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, b);\n    }\n\n    return b;\n  }\n\n  combineCommonParents(mergedParents);\n\n  if (mergeCache !== null) {\n    mergeCache.set(a, b, M);\n  }\n\n  return M;\n}\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\n\n\nfunction combineCommonParents(parents) {\n  const uniqueParents = new Map();\n\n  for (let p = 0; p < parents.length; p++) {\n    const parent = parents[p];\n\n    if (!uniqueParents.containsKey(parent)) {\n      uniqueParents.put(parent, parent);\n    }\n  }\n\n  for (let q = 0; q < parents.length; q++) {\n    parents[q] = uniqueParents.get(parents[q]);\n  }\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n  if (context.isEmpty()) {\n    return context;\n  }\n\n  let existing = visited.get(context) || null;\n\n  if (existing !== null) {\n    return existing;\n  }\n\n  existing = contextCache.get(context);\n\n  if (existing !== null) {\n    visited.put(context, existing);\n    return existing;\n  }\n\n  let changed = false;\n  let parents = [];\n\n  for (let i = 0; i < parents.length; i++) {\n    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\n    if (changed || parent !== context.getParent(i)) {\n      if (!changed) {\n        parents = [];\n\n        for (let j = 0; j < context.length; j++) {\n          parents[j] = context.getParent(j);\n        }\n\n        changed = true;\n      }\n\n      parents[i] = parent;\n    }\n  }\n\n  if (!changed) {\n    contextCache.add(context);\n    visited.put(context, context);\n    return context;\n  }\n\n  let updated = null;\n\n  if (parents.length === 0) {\n    updated = PredictionContext.EMPTY;\n  } else if (parents.length === 1) {\n    updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));\n  } else {\n    updated = new ArrayPredictionContext(parents, context.returnStates);\n  }\n\n  contextCache.add(updated);\n  visited.put(updated, updated);\n  visited.put(context, updated);\n  return updated;\n} // ter's recursive version of Sam's getAllNodes()\n\n\nfunction getAllContextNodes(context, nodes, visited) {\n  if (nodes === null) {\n    nodes = [];\n    return getAllContextNodes(context, nodes, visited);\n  } else if (visited === null) {\n    visited = new Map();\n    return getAllContextNodes(context, nodes, visited);\n  } else {\n    if (context === null || visited.containsKey(context)) {\n      return nodes;\n    }\n\n    visited.put(context, context);\n    nodes.push(context);\n\n    for (let i = 0; i < context.length; i++) {\n      getAllContextNodes(context.getParent(i), nodes, visited);\n    }\n\n    return nodes;\n  }\n}\n\nmodule.exports = {\n  merge,\n  PredictionContext,\n  PredictionContextCache,\n  SingletonPredictionContext,\n  predictionContextFromRuleContext,\n  getCachedPredictionContext\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/PredictionContext.js"],"names":["RuleContext","require","Hash","Map","equalArrays","PredictionContext","constructor","cachedHashCode","isEmpty","EMPTY","hasEmptyPath","getReturnState","length","EMPTY_RETURN_STATE","hashCode","updateHashCode","hash","update","globalNodeCount","id","PredictionContextCache","cache","add","ctx","existing","get","put","SingletonPredictionContext","parent","returnState","finish","parentCtx","getParent","index","equals","other","toString","up","create","EmptyPredictionContext","ArrayPredictionContext","parents","returnStates","h","s","i","predictionContextFromRuleContext","atn","outerContext","undefined","state","states","invokingState","transition","transitions","followState","stateNumber","merge","a","b","rootIsWildcard","mergeCache","mergeSingletons","mergeArrays","previous","rootMerge","mergeRoot","set","spc","singleParent","payloads","apc","a_","j","k","mergedReturnStates","mergedParents","a_parent","b_parent","payload","bothDollars","ax_ax","p","slice","M","combineCommonParents","uniqueParents","containsKey","q","getCachedPredictionContext","context","contextCache","visited","changed","updated","getAllContextNodes","nodes","push","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst {Hash, Map, equalArrays} = require('./Utils');\n\nclass PredictionContext {\n\n\tconstructor(cachedHashCode) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * <pre>\n\t * private int referenceHashCode() {\n\t * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n\t * //INITIAL_HASH});\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n\t * getParent}(i));\n\t * }\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n\t * //getReturnState getReturnState}(i));\n\t * }\n\t *\n\t * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n\t * //size()});\n\t * return hash;\n\t * }\n\t * </pre>\n\t * This means only the {@link //EMPTY} context is in set.\n\t */\n\tisEmpty() {\n\t\treturn this === PredictionContext.EMPTY;\n\t}\n\n\thasEmptyPath() {\n\t\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n}\n\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\nPredictionContext.EMPTY = null;\n\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\nclass PredictionContextCache {\n\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Add a context to the cache and return it. If the context already exists,\n\t * return that one instead and do not add a new context to the cache.\n\t * Protect shared cache from unsafe thread access.\n\t */\n\tadd(ctx) {\n\t\tif (ctx === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY;\n\t\t}\n\t\tconst existing = this.cache.get(ctx) || null;\n\t\tif (existing !== null) {\n\t\t\treturn existing;\n\t\t}\n\t\tthis.cache.put(ctx, ctx);\n\t\treturn ctx;\n\t}\n\n\tget(ctx) {\n\t\treturn this.cache.get(ctx) || null;\n\t}\n\n\tget length(){\n\t\treturn this.cache.length;\n\t}\n}\n\n\nclass SingletonPredictionContext extends PredictionContext {\n\n\tconstructor(parent, returnState) {\n\t\tlet hashCode = 0;\n\t\tconst hash = new Hash();\n\t\tif(parent !== null) {\n\t\t\thash.update(parent, returnState);\n\t\t} else {\n\t\t\thash.update(1);\n\t\t}\n\t\thashCode = hash.finish();\n\t\tsuper(hashCode);\n\t\tthis.parentCtx = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\tif(this.returnState !== other.returnState)\n\t\t\t\treturn false;\n\t\t\telse if(this.parentCtx==null)\n\t\t\t\treturn other.parentCtx==null\n\t\t\telse\n\t\t\t\treturn this.parentCtx.equals(other.parentCtx);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tconst up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\t\tif (up.length === 0) {\n\t\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\treturn \"$\";\n\t\t\t} else {\n\t\t\t\treturn \"\" + this.returnState;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\" + this.returnState + \" \" + up;\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn 1;\n\t}\n\n\tstatic create(parent, returnState) {\n\t\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t\t// someone can pass in the bits of an array ctx that mean $\n\t\t\treturn PredictionContext.EMPTY;\n\t\t} else {\n\t\t\treturn new SingletonPredictionContext(parent, returnState);\n\t\t}\n\t}\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n\n\tconstructor() {\n\t\tsuper(null, PredictionContext.EMPTY_RETURN_STATE);\n\t}\n\n\tisEmpty() {\n\t\treturn true;\n\t}\n\n\tgetParent(index) {\n\t\treturn null;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\treturn this === other;\n\t}\n\n\ttoString() {\n\t\treturn \"$\";\n\t}\n}\n\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n\n\tconstructor(parents, returnStates) {\n\t\t/**\n\t\t * Parent can be null only if full ctx mode and we make an array\n\t\t * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t\t * null parent and\n\t\t * returnState == {@link //EMPTY_RETURN_STATE}.\n\t\t */\n\t\tconst h = new Hash();\n\t\th.update(parents, returnStates);\n\t\tconst hashCode = h.finish();\n\t\tsuper(hashCode);\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t\treturn this;\n\t}\n\n\tisEmpty() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t\t// don't need to verify that size==1\n\t\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parents[index];\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnStates[index];\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\treturn equalArrays(this.returnStates, other.returnStates) &&\n\t\t\t\tequalArrays(this.parents, other.parents);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn \"[]\";\n\t\t} else {\n\t\t\tlet s = \"[\";\n\t\t\tfor (let i = 0; i < this.returnStates.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts = s + \", \";\n\t\t\t\t}\n\t\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\ts = s + \"$\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = s + this.returnStates[i];\n\t\t\t\tif (this.parents[i] !== null) {\n\t\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t\t} else {\n\t\t\t\t\ts = s + \"null\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s + \"]\";\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.returnStates.length;\n\t}\n}\n\n\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tconst parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tconst state = atn.states[outerContext.invokingState];\n\tconst transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tconst rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tconst parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tconst spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tlet singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tconst parents = [ singleParent, singleParent ];\n\t\t\tconst apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\tlet parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tconst a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tconst payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tconst payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tlet i = 0; // walks a\n\tlet j = 0; // walks b\n\tlet k = 0; // walks target M array\n\n\tlet mergedReturnStates = [];\n\tlet mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tconst a_parent = a.parents[i];\n\t\tconst b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tconst payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tconst bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tconst ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tmergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (let p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (let p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tconst a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tconst M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\nfunction combineCommonParents(parents) {\n\tconst uniqueParents = new Map();\n\n\tfor (let p = 0; p < parents.length; p++) {\n\t\tconst parent = parents[p];\n\t\tif (!(uniqueParents.containsKey(parent))) {\n\t\t\tuniqueParents.put(parent, parent);\n\t\t}\n\t}\n\tfor (let q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents.get(parents[q]);\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tlet existing = visited.get(context) || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited.put(context, existing);\n\t\treturn existing;\n\t}\n\tlet changed = false;\n\tlet parents = [];\n\tfor (let i = 0; i < parents.length; i++) {\n\t\tconst parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (let j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited.put(context, context);\n\t\treturn context;\n\t}\n\tlet updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited.put(updated, updated);\n\tvisited.put(context, updated);\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = new Map();\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited.containsKey(context)) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited.put(context, context);\n\t\tnodes.push(context);\n\t\tfor (let i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = {\n\tmerge,\n\tPredictionContext,\n\tPredictionContextCache,\n\tSingletonPredictionContext,\n\tpredictionContextFromRuleContext,\n\tgetCachedPredictionContext\n}\n"]},"metadata":{},"sourceType":"script"}