{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\nconst {\n  PredicateTransition\n} = require('./../atn/Transition');\n\nconst {\n  Interval\n} = require('../IntervalSet').Interval;\n\nclass RecognitionException extends Error {\n  constructor(params) {\n    super(params.message);\n\n    if (!!Error.captureStackTrace) {\n      Error.captureStackTrace(this, RecognitionException);\n    } else {\n      var stack = new Error().stack;\n    }\n\n    this.message = params.message;\n    this.recognizer = params.recognizer;\n    this.input = params.input;\n    this.ctx = params.ctx;\n    /**\n     * The current {@link Token} when an error occurred. Since not all streams\n     * support accessing symbols by index, we have to track the {@link Token}\n     * instance itself\n    */\n\n    this.offendingToken = null;\n    /**\n     * Get the ATN state number the parser was in at the time the error\n     * occurred. For {@link NoViableAltException} and\n     * {@link LexerNoViableAltException} exceptions, this is the\n     * {@link DecisionState} number. For others, it is the state whose outgoing\n     * edge we couldn't match.\n     */\n\n    this.offendingState = -1;\n\n    if (this.recognizer !== null) {\n      this.offendingState = this.recognizer.state;\n    }\n  }\n  /**\n   * Gets the set of input symbols which could potentially follow the\n   * previously matched symbol at the time this exception was thrown.\n   *\n   * <p>If the set of expected tokens is not known and could not be computed,\n   * this method returns {@code null}.</p>\n   *\n   * @return The set of token types that could potentially follow the current\n   * state in the ATN, or {@code null} if the information is not available.\n   */\n\n\n  getExpectedTokens() {\n    if (this.recognizer !== null) {\n      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n    } else {\n      return null;\n    }\n  } // <p>If the state number is not known, this method returns -1.</p>\n\n\n  toString() {\n    return this.message;\n  }\n\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n  constructor(lexer, input, startIndex, deadEndConfigs) {\n    super({\n      message: \"\",\n      recognizer: lexer,\n      input: input,\n      ctx: null\n    });\n    this.startIndex = startIndex;\n    this.deadEndConfigs = deadEndConfigs;\n  }\n\n  toString() {\n    let symbol = \"\";\n\n    if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n      symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));\n    }\n\n    return \"LexerNoViableAltException\" + symbol;\n  }\n\n}\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\n\n\nclass NoViableAltException extends RecognitionException {\n  constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n    ctx = ctx || recognizer._ctx;\n    offendingToken = offendingToken || recognizer.getCurrentToken();\n    startToken = startToken || recognizer.getCurrentToken();\n    input = input || recognizer.getInputStream();\n    super({\n      message: \"\",\n      recognizer: recognizer,\n      input: input,\n      ctx: ctx\n    }); // Which configurations did we try at input.index() that couldn't match\n    // input.LT(1)?//\n\n    this.deadEndConfigs = deadEndConfigs; // The token object at the start index; the input stream might\n    // not be buffering tokens so get a reference to it. (At the\n    // time the error occurred, of course the stream needs to keep a\n    // buffer all of the tokens but later we might not have access to those.)\n\n    this.startToken = startToken;\n    this.offendingToken = offendingToken;\n  }\n\n}\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\n\n\nclass InputMismatchException extends RecognitionException {\n  constructor(recognizer) {\n    super({\n      message: \"\",\n      recognizer: recognizer,\n      input: recognizer.getInputStream(),\n      ctx: recognizer._ctx\n    });\n    this.offendingToken = recognizer.getCurrentToken();\n  }\n\n}\n\nfunction formatMessage(predicate, message) {\n  if (message !== null) {\n    return message;\n  } else {\n    return \"failed predicate: {\" + predicate + \"}?\";\n  }\n}\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\n\n\nclass FailedPredicateException extends RecognitionException {\n  constructor(recognizer, predicate, message) {\n    super({\n      message: formatMessage(predicate, message || null),\n      recognizer: recognizer,\n      input: recognizer.getInputStream(),\n      ctx: recognizer._ctx\n    });\n    const s = recognizer._interp.atn.states[recognizer.state];\n    const trans = s.transitions[0];\n\n    if (trans instanceof PredicateTransition) {\n      this.ruleIndex = trans.ruleIndex;\n      this.predicateIndex = trans.predIndex;\n    } else {\n      this.ruleIndex = 0;\n      this.predicateIndex = 0;\n    }\n\n    this.predicate = predicate;\n    this.offendingToken = recognizer.getCurrentToken();\n  }\n\n}\n\nclass ParseCancellationException extends Error {\n  constructor() {\n    super();\n    Error.captureStackTrace(this, ParseCancellationException);\n  }\n\n}\n\nmodule.exports = {\n  RecognitionException,\n  NoViableAltException,\n  LexerNoViableAltException,\n  InputMismatchException,\n  FailedPredicateException,\n  ParseCancellationException\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/error/Errors.js"],"names":["PredicateTransition","require","Interval","RecognitionException","Error","constructor","params","message","captureStackTrace","stack","recognizer","input","ctx","offendingToken","offendingState","state","getExpectedTokens","atn","toString","LexerNoViableAltException","lexer","startIndex","deadEndConfigs","symbol","size","getText","NoViableAltException","startToken","_ctx","getCurrentToken","getInputStream","InputMismatchException","formatMessage","predicate","FailedPredicateException","s","_interp","states","trans","transitions","ruleIndex","predicateIndex","predIndex","ParseCancellationException","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\n\nconst {PredicateTransition} = require('./../atn/Transition');\nconst {Interval} = require('../IntervalSet').Interval;\n\nclass RecognitionException extends Error {\n    constructor(params) {\n        super(params.message);\n        if (!!Error.captureStackTrace) {\n            Error.captureStackTrace(this, RecognitionException);\n        } else {\n            var stack = new Error().stack;\n        }\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        /**\n         * The current {@link Token} when an error occurred. Since not all streams\n         * support accessing symbols by index, we have to track the {@link Token}\n         * instance itself\n        */\n        this.offendingToken = null;\n        /**\n         * Get the ATN state number the parser was in at the time the error\n         * occurred. For {@link NoViableAltException} and\n         * {@link LexerNoViableAltException} exceptions, this is the\n         * {@link DecisionState} number. For others, it is the state whose outgoing\n         * edge we couldn't match.\n         */\n        this.offendingState = -1;\n        if (this.recognizer!==null) {\n            this.offendingState = this.recognizer.state;\n        }\n    }\n\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * <p>If the set of expected tokens is not known and could not be computed,\n     * this method returns {@code null}.</p>\n     *\n     * @return The set of token types that could potentially follow the current\n     * state in the ATN, or {@code null} if the information is not available.\n     */\n    getExpectedTokens() {\n        if (this.recognizer!==null) {\n            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        } else {\n            return null;\n        }\n    }\n\n    // <p>If the state number is not known, this method returns -1.</p>\n    toString() {\n        return this.message;\n    }\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n        super({message: \"\", recognizer: lexer, input: input, ctx: null});\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n\n    toString() {\n        let symbol = \"\";\n        if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));\n        }\n        return \"LexerNoViableAltException\" + symbol;\n    }\n}\n\n\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\nclass NoViableAltException extends RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n        ctx = ctx || recognizer._ctx;\n        offendingToken = offendingToken || recognizer.getCurrentToken();\n        startToken = startToken || recognizer.getCurrentToken();\n        input = input || recognizer.getInputStream();\n        super({message: \"\", recognizer: recognizer, input: input, ctx: ctx});\n        // Which configurations did we try at input.index() that couldn't match\n        // input.LT(1)?//\n        this.deadEndConfigs = deadEndConfigs;\n        // The token object at the start index; the input stream might\n        // not be buffering tokens so get a reference to it. (At the\n        // time the error occurred, of course the stream needs to keep a\n        // buffer all of the tokens but later we might not have access to those.)\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n}\n\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\nclass InputMismatchException extends RecognitionException {\n    constructor(recognizer) {\n        super({message: \"\", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\nfunction formatMessage(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n}\n\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\nclass FailedPredicateException extends RecognitionException {\n    constructor(recognizer, predicate, message) {\n        super({\n            message: formatMessage(predicate, message || null), recognizer: recognizer,\n            input: recognizer.getInputStream(), ctx: recognizer._ctx\n        });\n        const s = recognizer._interp.atn.states[recognizer.state]\n        const trans = s.transitions[0]\n        if (trans instanceof PredicateTransition) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\n\nclass ParseCancellationException extends Error{\n    constructor() {\n        super()\n        Error.captureStackTrace(this, ParseCancellationException);\n    }\n}\n\nmodule.exports = {\n    RecognitionException,\n    NoViableAltException,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException,\n    ParseCancellationException\n};\n"]},"metadata":{},"sourceType":"script"}