{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst ATN = require('./ATN');\n\nconst Utils = require('./../Utils');\n\nconst {\n  SemanticContext\n} = require('./SemanticContext');\n\nconst {\n  merge\n} = require('./../PredictionContext');\n\nfunction hashATNConfig(c) {\n  return c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a === null || b === null) {\n    return false;\n  } else return a.equalsForConfigSet(b);\n}\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\n\n\nclass ATNConfigSet {\n  constructor(fullCtx) {\n    /**\n     * The reason that we need this is because we don't want the hash map to use\n     * the standard hash code and equals. We need all configurations with the\n     * same\n     * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n     * doubles\n     * the number of objects associated with ATNConfigs. The other solution is\n     * to\n     * use a hash table that lets us specify the equals/hashcode operation.\n     * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n     * when we go readonly as this set becomes a DFA state\n     */\n    this.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n    /**\n     * Indicates that this configuration set is part of a full context\n     * LL prediction. It will be used to determine how to merge $. With SLL\n     * it's a wildcard whereas it is not for LL context merge\n     */\n\n    this.fullCtx = fullCtx === undefined ? true : fullCtx;\n    /**\n     * Indicates that the set of configurations is read-only. Do not\n     * allow any code to manipulate the set; DFA states will point at\n     * the sets and they must not change. This does not protect the other\n     * fields; in particular, conflictingAlts is set after\n     * we've made this readonly\n     */\n\n    this.readOnly = false; // Track the elements as they are added to the set; supports get(i)///\n\n    this.configs = []; // TODO: these fields make me pretty uncomfortable but nice to pack up info\n    // together, saves recomputation\n    // TODO: can we track conflicts as they are added to save scanning configs\n    // later?\n\n    this.uniqueAlt = 0;\n    this.conflictingAlts = null;\n    /**\n     * Used in parser and lexer. In lexer, it indicates we hit a pred\n     * while computing a closure operation. Don't make a DFA state from this\n     */\n\n    this.hasSemanticContext = false;\n    this.dipsIntoOuterContext = false;\n    this.cachedHashCode = -1;\n  }\n  /**\n   * Adding a new config means merging contexts with existing configs for\n   * {@code (s, i, pi, _)}, where {@code s} is the\n   * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n   * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n   * {@code (s,i,pi)} as key.\n   *\n   * <p>This method updates {@link //dipsIntoOuterContext} and\n   * {@link //hasSemanticContext} when necessary.</p>\n   */\n\n\n  add(config, mergeCache) {\n    if (mergeCache === undefined) {\n      mergeCache = null;\n    }\n\n    if (this.readOnly) {\n      throw \"This set is readonly\";\n    }\n\n    if (config.semanticContext !== SemanticContext.NONE) {\n      this.hasSemanticContext = true;\n    }\n\n    if (config.reachesIntoOuterContext > 0) {\n      this.dipsIntoOuterContext = true;\n    }\n\n    const existing = this.configLookup.add(config);\n\n    if (existing === config) {\n      this.cachedHashCode = -1;\n      this.configs.push(config); // track order here\n\n      return true;\n    } // a previous (s,i,pi,_), merge with it and save result\n\n\n    const rootIsWildcard = !this.fullCtx;\n    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n    /**\n     * no need to check for existing.context, config.context in cache\n     * since only way to create new graphs is \"call rule\" and here. We\n     * cache at both places\n     */\n\n    existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext); // make sure to preserve the precedence filter suppression during the merge\n\n    if (config.precedenceFilterSuppressed) {\n      existing.precedenceFilterSuppressed = true;\n    }\n\n    existing.context = merged; // replace context; no need to alt mapping\n\n    return true;\n  }\n\n  getStates() {\n    const states = new Utils.Set();\n\n    for (let i = 0; i < this.configs.length; i++) {\n      states.add(this.configs[i].state);\n    }\n\n    return states;\n  }\n\n  getPredicates() {\n    const preds = [];\n\n    for (let i = 0; i < this.configs.length; i++) {\n      const c = this.configs[i].semanticContext;\n\n      if (c !== SemanticContext.NONE) {\n        preds.push(c.semanticContext);\n      }\n    }\n\n    return preds;\n  }\n\n  optimizeConfigs(interpreter) {\n    if (this.readOnly) {\n      throw \"This set is readonly\";\n    }\n\n    if (this.configLookup.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < this.configs.length; i++) {\n      const config = this.configs[i];\n      config.context = interpreter.getCachedContext(config.context);\n    }\n  }\n\n  addAll(coll) {\n    for (let i = 0; i < coll.length; i++) {\n      this.add(coll[i]);\n    }\n\n    return false;\n  }\n\n  equals(other) {\n    return this === other || other instanceof ATNConfigSet && Utils.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;\n  }\n\n  hashCode() {\n    const hash = new Utils.Hash();\n    hash.update(this.configs);\n    return hash.finish();\n  }\n\n  updateHashCode(hash) {\n    if (this.readOnly) {\n      if (this.cachedHashCode === -1) {\n        this.cachedHashCode = this.hashCode();\n      }\n\n      hash.update(this.cachedHashCode);\n    } else {\n      hash.update(this.hashCode());\n    }\n  }\n\n  isEmpty() {\n    return this.configs.length === 0;\n  }\n\n  contains(item) {\n    if (this.configLookup === null) {\n      throw \"This method is not implemented for readonly sets.\";\n    }\n\n    return this.configLookup.contains(item);\n  }\n\n  containsFast(item) {\n    if (this.configLookup === null) {\n      throw \"This method is not implemented for readonly sets.\";\n    }\n\n    return this.configLookup.containsFast(item);\n  }\n\n  clear() {\n    if (this.readOnly) {\n      throw \"This set is readonly\";\n    }\n\n    this.configs = [];\n    this.cachedHashCode = -1;\n    this.configLookup = new Utils.Set();\n  }\n\n  setReadonly(readOnly) {\n    this.readOnly = readOnly;\n\n    if (readOnly) {\n      this.configLookup = null; // can't mod, no need for lookup cache\n    }\n  }\n\n  toString() {\n    return Utils.arrayToString(this.configs) + (this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") + (this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") + (this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n  }\n\n  get items() {\n    return this.configs;\n  }\n\n  get length() {\n    return this.configs.length;\n  }\n\n}\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n  constructor() {\n    super();\n    this.configLookup = new Utils.Set();\n  }\n\n}\n\nmodule.exports = {\n  ATNConfigSet,\n  OrderedATNConfigSet\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js"],"names":["ATN","require","Utils","SemanticContext","merge","hashATNConfig","c","hashCodeForConfigSet","equalATNConfigs","a","b","equalsForConfigSet","ATNConfigSet","constructor","fullCtx","configLookup","Set","undefined","readOnly","configs","uniqueAlt","conflictingAlts","hasSemanticContext","dipsIntoOuterContext","cachedHashCode","add","config","mergeCache","semanticContext","NONE","reachesIntoOuterContext","existing","push","rootIsWildcard","merged","context","Math","max","precedenceFilterSuppressed","getStates","states","i","length","state","getPredicates","preds","optimizeConfigs","interpreter","getCachedContext","addAll","coll","equals","other","equalArrays","hashCode","hash","Hash","update","finish","updateHashCode","isEmpty","contains","item","containsFast","clear","setReadonly","toString","arrayToString","INVALID_ALT_NUMBER","items","OrderedATNConfigSet","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst ATN = require('./ATN');\nconst Utils = require('./../Utils');\nconst {SemanticContext} = require('./SemanticContext');\nconst {merge} = require('./../PredictionContext');\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\nclass ATNConfigSet {\n\tconstructor(fullCtx) {\n\t\t/**\n\t\t * The reason that we need this is because we don't want the hash map to use\n\t\t * the standard hash code and equals. We need all configurations with the\n\t\t * same\n\t\t * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t\t * doubles\n\t\t * the number of objects associated with ATNConfigs. The other solution is\n\t\t * to\n\t\t * use a hash table that lets us specify the equals/hashcode operation.\n\t\t * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t\t * when we go readonly as this set becomes a DFA state\n\t\t */\n\t\tthis.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n\t\t/**\n\t\t * Indicates that this configuration set is part of a full context\n\t\t * LL prediction. It will be used to determine how to merge $. With SLL\n\t\t * it's a wildcard whereas it is not for LL context merge\n\t\t */\n\t\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t\t/**\n\t\t * Indicates that the set of configurations is read-only. Do not\n\t\t * allow any code to manipulate the set; DFA states will point at\n\t\t * the sets and they must not change. This does not protect the other\n\t\t * fields; in particular, conflictingAlts is set after\n\t\t * we've made this readonly\n\t\t */\n\t\tthis.readOnly = false;\n\t\t// Track the elements as they are added to the set; supports get(i)///\n\t\tthis.configs = [];\n\n\t\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t\t// together, saves recomputation\n\t\t// TODO: can we track conflicts as they are added to save scanning configs\n\t\t// later?\n\t\tthis.uniqueAlt = 0;\n\t\tthis.conflictingAlts = null;\n\n\t\t/**\n\t\t * Used in parser and lexer. In lexer, it indicates we hit a pred\n\t\t * while computing a closure operation. Don't make a DFA state from this\n\t\t */\n\t\tthis.hasSemanticContext = false;\n\t\tthis.dipsIntoOuterContext = false;\n\n\t\tthis.cachedHashCode = -1;\n\t}\n\n\t/**\n\t * Adding a new config means merging contexts with existing configs for\n\t * {@code (s, i, pi, _)}, where {@code s} is the\n\t * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n\t * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n\t * {@code (s,i,pi)} as key.\n\t *\n\t * <p>This method updates {@link //dipsIntoOuterContext} and\n\t * {@link //hasSemanticContext} when necessary.</p>\n\t */\n\tadd(config, mergeCache) {\n\t\tif (mergeCache === undefined) {\n\t\t\tmergeCache = null;\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\t\tthis.hasSemanticContext = true;\n\t\t}\n\t\tif (config.reachesIntoOuterContext > 0) {\n\t\t\tthis.dipsIntoOuterContext = true;\n\t\t}\n\t\tconst existing = this.configLookup.add(config);\n\t\tif (existing === config) {\n\t\t\tthis.cachedHashCode = -1;\n\t\t\tthis.configs.push(config); // track order here\n\t\t\treturn true;\n\t\t}\n\t\t// a previous (s,i,pi,_), merge with it and save result\n\t\tconst rootIsWildcard = !this.fullCtx;\n\t\tconst merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t\t/**\n\t\t * no need to check for existing.context, config.context in cache\n\t\t * since only way to create new graphs is \"call rule\" and here. We\n\t\t * cache at both places\n\t\t */\n\t\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t\t// make sure to preserve the precedence filter suppression during the merge\n\t\tif (config.precedenceFilterSuppressed) {\n\t\t\texisting.precedenceFilterSuppressed = true;\n\t\t}\n\t\texisting.context = merged; // replace context; no need to alt mapping\n\t\treturn true;\n\t}\n\n\tgetStates() {\n\t\tconst states = new Utils.Set();\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tstates.add(this.configs[i].state);\n\t\t}\n\t\treturn states;\n\t}\n\n\tgetPredicates() {\n\t\tconst preds = [];\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst c = this.configs[i].semanticContext;\n\t\t\tif (c !== SemanticContext.NONE) {\n\t\t\t\tpreds.push(c.semanticContext);\n\t\t\t}\n\t\t}\n\t\treturn preds;\n\t}\n\n\toptimizeConfigs(interpreter) {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (this.configLookup.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst config = this.configs[i];\n\t\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t\t}\n\t}\n\n\taddAll(coll) {\n\t\tfor (let i = 0; i < coll.length; i++) {\n\t\t\tthis.add(coll[i]);\n\t\t}\n\t\treturn false;\n\t}\n\n\tequals(other) {\n\t\treturn this === other ||\n\t\t\t(other instanceof ATNConfigSet &&\n\t\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\t\tthis.fullCtx === other.fullCtx &&\n\t\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n\t}\n\n\thashCode() {\n\t\tconst hash = new Utils.Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n\n\tupdateHashCode(hash) {\n\t\tif (this.readOnly) {\n\t\t\tif (this.cachedHashCode === -1) {\n\t\t\t\tthis.cachedHashCode = this.hashCode();\n\t\t\t}\n\t\t\thash.update(this.cachedHashCode);\n\t\t} else {\n\t\t\thash.update(this.hashCode());\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.configs.length === 0;\n\t}\n\n\tcontains(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.contains(item);\n\t}\n\n\tcontainsFast(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.containsFast(item);\n\t}\n\n\tclear() {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tthis.configs = [];\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configLookup = new Utils.Set();\n\t}\n\n\tsetReadonly(readOnly) {\n\t\tthis.readOnly = readOnly;\n\t\tif (readOnly) {\n\t\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Utils.arrayToString(this.configs) +\n\t\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n\t}\n\n\tget items(){\n\t\treturn this.configs;\n\t}\n\n\tget length(){\n\t\treturn this.configs.length;\n\t}\n}\n\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.configLookup = new Utils.Set();\n\t}\n}\n\nmodule.exports = {\n\tATNConfigSet,\n\tOrderedATNConfigSet\n}\n"]},"metadata":{},"sourceType":"script"}