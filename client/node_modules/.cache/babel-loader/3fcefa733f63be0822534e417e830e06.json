{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./../Token');\n\nconst {\n  IntervalSet\n} = require('./../IntervalSet');\n\nconst {\n  Predicate,\n  PrecedencePredicate\n} = require('./SemanticContext');\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\n\n\nclass Transition {\n  constructor(target) {\n    // The target of this transition.\n    if (target === undefined || target === null) {\n      throw \"target cannot be null.\";\n    }\n\n    this.target = target; // Are we epsilon, action, sempred?\n\n    this.isEpsilon = false;\n    this.label = null;\n  }\n\n} // constants for serialization\n\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3; // e.g., {isType(input.LT(1))}?\n\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6; // ~(A|B) or ~atom, wildcard, which convert to next 2\n\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\nTransition.serializationNames = [\"INVALID\", \"EPSILON\", \"RANGE\", \"RULE\", \"PREDICATE\", \"ATOM\", \"ACTION\", \"SET\", \"NOT_SET\", \"WILDCARD\", \"PRECEDENCE\"];\nTransition.serializationTypes = {\n  EpsilonTransition: Transition.EPSILON,\n  RangeTransition: Transition.RANGE,\n  RuleTransition: Transition.RULE,\n  PredicateTransition: Transition.PREDICATE,\n  AtomTransition: Transition.ATOM,\n  ActionTransition: Transition.ACTION,\n  SetTransition: Transition.SET,\n  NotSetTransition: Transition.NOT_SET,\n  WildcardTransition: Transition.WILDCARD,\n  PrecedencePredicateTransition: Transition.PRECEDENCE\n}; // TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n  constructor(target, label) {\n    super(target); // The token type or character value; or, signifies special label.\n\n    this.label_ = label;\n    this.label = this.makeLabel();\n    this.serializationType = Transition.ATOM;\n  }\n\n  makeLabel() {\n    const s = new IntervalSet();\n    s.addOne(this.label_);\n    return s;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return this.label_ === symbol;\n  }\n\n  toString() {\n    return this.label_;\n  }\n\n}\n\nclass RuleTransition extends Transition {\n  constructor(ruleStart, ruleIndex, precedence, followState) {\n    super(ruleStart); // ptr to the rule definition object for this rule ref\n\n    this.ruleIndex = ruleIndex;\n    this.precedence = precedence; // what node to begin computations following ref to rule\n\n    this.followState = followState;\n    this.serializationType = Transition.RULE;\n    this.isEpsilon = true;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return false;\n  }\n\n}\n\nclass EpsilonTransition extends Transition {\n  constructor(target, outermostPrecedenceReturn) {\n    super(target);\n    this.serializationType = Transition.EPSILON;\n    this.isEpsilon = true;\n    this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return false;\n  }\n\n  toString() {\n    return \"epsilon\";\n  }\n\n}\n\nclass RangeTransition extends Transition {\n  constructor(target, start, stop) {\n    super(target);\n    this.serializationType = Transition.RANGE;\n    this.start = start;\n    this.stop = stop;\n    this.label = this.makeLabel();\n  }\n\n  makeLabel() {\n    const s = new IntervalSet();\n    s.addRange(this.start, this.stop);\n    return s;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return symbol >= this.start && symbol <= this.stop;\n  }\n\n  toString() {\n    return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n  }\n\n}\n\nclass AbstractPredicateTransition extends Transition {\n  constructor(target) {\n    super(target);\n  }\n\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n  constructor(target, ruleIndex, predIndex, isCtxDependent) {\n    super(target);\n    this.serializationType = Transition.PREDICATE;\n    this.ruleIndex = ruleIndex;\n    this.predIndex = predIndex;\n    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n\n    this.isEpsilon = true;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return false;\n  }\n\n  getPredicate() {\n    return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n  }\n\n  toString() {\n    return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n  }\n\n}\n\nclass ActionTransition extends Transition {\n  constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n    super(target);\n    this.serializationType = Transition.ACTION;\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex === undefined ? -1 : actionIndex;\n    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\n    this.isEpsilon = true;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return false;\n  }\n\n  toString() {\n    return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n  }\n\n} // A transition containing a set of values.\n\n\nclass SetTransition extends Transition {\n  constructor(target, set) {\n    super(target);\n    this.serializationType = Transition.SET;\n\n    if (set !== undefined && set !== null) {\n      this.label = set;\n    } else {\n      this.label = new IntervalSet();\n      this.label.addOne(Token.INVALID_TYPE);\n    }\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return this.label.contains(symbol);\n  }\n\n  toString() {\n    return this.label.toString();\n  }\n\n}\n\nclass NotSetTransition extends SetTransition {\n  constructor(target, set) {\n    super(target, set);\n    this.serializationType = Transition.NOT_SET;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n  }\n\n  toString() {\n    return '~' + super.toString();\n  }\n\n}\n\nclass WildcardTransition extends Transition {\n  constructor(target) {\n    super(target);\n    this.serializationType = Transition.WILDCARD;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n  }\n\n  toString() {\n    return \".\";\n  }\n\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n  constructor(target, precedence) {\n    super(target);\n    this.serializationType = Transition.PRECEDENCE;\n    this.precedence = precedence;\n    this.isEpsilon = true;\n  }\n\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return false;\n  }\n\n  getPredicate() {\n    return new PrecedencePredicate(this.precedence);\n  }\n\n  toString() {\n    return this.precedence + \" >= _p\";\n  }\n\n}\n\nmodule.exports = {\n  Transition,\n  AtomTransition,\n  SetTransition,\n  NotSetTransition,\n  RuleTransition,\n  ActionTransition,\n  EpsilonTransition,\n  RangeTransition,\n  WildcardTransition,\n  PredicateTransition,\n  PrecedencePredicateTransition,\n  AbstractPredicateTransition\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/Transition.js"],"names":["Token","require","IntervalSet","Predicate","PrecedencePredicate","Transition","constructor","target","undefined","isEpsilon","label","EPSILON","RANGE","RULE","PREDICATE","ATOM","ACTION","SET","NOT_SET","WILDCARD","PRECEDENCE","serializationNames","serializationTypes","EpsilonTransition","RangeTransition","RuleTransition","PredicateTransition","AtomTransition","ActionTransition","SetTransition","NotSetTransition","WildcardTransition","PrecedencePredicateTransition","label_","makeLabel","serializationType","s","addOne","matches","symbol","minVocabSymbol","maxVocabSymbol","toString","ruleStart","ruleIndex","precedence","followState","outermostPrecedenceReturn","start","stop","addRange","String","fromCharCode","AbstractPredicateTransition","predIndex","isCtxDependent","getPredicate","actionIndex","set","INVALID_TYPE","contains","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Predicate, PrecedencePredicate} = require('./SemanticContext');\n\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\nclass Transition {\n    constructor(target) {\n        // The target of this transition.\n        if (target===undefined || target===null) {\n            throw \"target cannot be null.\";\n        }\n        this.target = target;\n        // Are we epsilon, action, sempred?\n        this.isEpsilon = false;\n        this.label = null;\n    }\n}\n\n// constants for serialization\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\n// e.g., {isType(input.LT(1))}?\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6;\n// ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n    constructor(target, label) {\n        super(target);\n        // The token type or character value; or, signifies special label.\n        this.label_ = label;\n        this.label = this.makeLabel();\n        this.serializationType = Transition.ATOM;\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addOne(this.label_);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label_ === symbol;\n    }\n\n    toString() {\n        return this.label_;\n    }\n}\n\n\nclass RuleTransition extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n        super(ruleStart);\n        // ptr to the rule definition object for this rule ref\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        // what node to begin computations following ref to rule\n        this.followState = followState;\n        this.serializationType = Transition.RULE;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n}\n\nclass EpsilonTransition extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n        super(target);\n        this.serializationType = Transition.EPSILON;\n        this.isEpsilon = true;\n        this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"epsilon\";\n    }\n}\n\n\nclass RangeTransition extends Transition {\n    constructor(target, start, stop) {\n        super(target);\n        this.serializationType = Transition.RANGE;\n        this.start = start;\n        this.stop = stop;\n        this.label = this.makeLabel();\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addRange(this.start, this.stop);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n}\n\n\nclass AbstractPredicateTransition extends Transition {\n    constructor(target) {\n        super(target);\n    }\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.PREDICATE;\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n}\n\n\nclass ActionTransition extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.ACTION;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n}\n\n\n// A transition containing a set of values.\nclass SetTransition extends Transition {\n    constructor(target, set) {\n        super(target);\n        this.serializationType = Transition.SET;\n        if (set !==undefined && set !==null) {\n            this.label = set;\n        } else {\n            this.label = new IntervalSet();\n            this.label.addOne(Token.INVALID_TYPE);\n        }\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label.contains(symbol);\n    }\n\n    toString() {\n        return this.label.toString();\n    }\n}\n\nclass NotSetTransition extends SetTransition {\n    constructor(target, set) {\n        super(target, set);\n        this.serializationType = Transition.NOT_SET;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n                !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n\n    toString() {\n        return '~' + super.toString();\n    }\n}\n\nclass WildcardTransition extends Transition {\n    constructor(target) {\n        super(target);\n        this.serializationType = Transition.WILDCARD;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n\n    toString() {\n        return \".\";\n    }\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n        super(target);\n        this.serializationType = Transition.PRECEDENCE;\n        this.precedence = precedence;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new PrecedencePredicate(this.precedence);\n    }\n\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n}\n\nmodule.exports = {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n}\n"]},"metadata":{},"sourceType":"script"}