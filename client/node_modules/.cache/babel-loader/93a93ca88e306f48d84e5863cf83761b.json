{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\n\n\nclass DFASerializer {\n  constructor(dfa, literalNames, symbolicNames) {\n    this.dfa = dfa;\n    this.literalNames = literalNames || [];\n    this.symbolicNames = symbolicNames || [];\n  }\n\n  toString() {\n    if (this.dfa.s0 === null) {\n      return null;\n    }\n\n    let buf = \"\";\n    const states = this.dfa.sortedStates();\n\n    for (let i = 0; i < states.length; i++) {\n      const s = states[i];\n\n      if (s.edges !== null) {\n        const n = s.edges.length;\n\n        for (let j = 0; j < n; j++) {\n          const t = s.edges[j] || null;\n\n          if (t !== null && t.stateNumber !== 0x7FFFFFFF) {\n            buf = buf.concat(this.getStateString(s));\n            buf = buf.concat(\"-\");\n            buf = buf.concat(this.getEdgeLabel(j));\n            buf = buf.concat(\"->\");\n            buf = buf.concat(this.getStateString(t));\n            buf = buf.concat('\\n');\n          }\n        }\n      }\n    }\n\n    return buf.length === 0 ? null : buf;\n  }\n\n  getEdgeLabel(i) {\n    if (i === 0) {\n      return \"EOF\";\n    } else if (this.literalNames !== null || this.symbolicNames !== null) {\n      return this.literalNames[i - 1] || this.symbolicNames[i - 1];\n    } else {\n      return String.fromCharCode(i - 1);\n    }\n  }\n\n  getStateString(s) {\n    const baseStateStr = (s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + (s.requiresFullContext ? \"^\" : \"\");\n\n    if (s.isAcceptState) {\n      if (s.predicates !== null) {\n        return baseStateStr + \"=>\" + Utils.arrayToString(s.predicates);\n      } else {\n        return baseStateStr + \"=>\" + s.prediction.toString();\n      }\n    } else {\n      return baseStateStr;\n    }\n  }\n\n}\n\nclass LexerDFASerializer extends DFASerializer {\n  constructor(dfa) {\n    super(dfa, null);\n  }\n\n  getEdgeLabel(i) {\n    return \"'\" + String.fromCharCode(i) + \"'\";\n  }\n\n}\n\nmodule.exports = {\n  DFASerializer,\n  LexerDFASerializer\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/dfa/DFASerializer.js"],"names":["Utils","require","DFASerializer","constructor","dfa","literalNames","symbolicNames","toString","s0","buf","states","sortedStates","i","length","s","edges","n","j","t","stateNumber","concat","getStateString","getEdgeLabel","String","fromCharCode","baseStateStr","isAcceptState","requiresFullContext","predicates","arrayToString","prediction","LexerDFASerializer","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\nclass DFASerializer {\n    constructor(dfa, literalNames, symbolicNames) {\n        this.dfa = dfa;\n        this.literalNames = literalNames || [];\n        this.symbolicNames = symbolicNames || [];\n    }\n\n    toString() {\n       if(this.dfa.s0 === null) {\n           return null;\n       }\n       let buf = \"\";\n       const states = this.dfa.sortedStates();\n       for(let i=0; i<states.length; i++) {\n           const s = states[i];\n           if(s.edges!==null) {\n                const n = s.edges.length;\n                for(let j=0;j<n;j++) {\n                    const t = s.edges[j] || null;\n                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                        buf = buf.concat(this.getStateString(s));\n                        buf = buf.concat(\"-\");\n                        buf = buf.concat(this.getEdgeLabel(j));\n                        buf = buf.concat(\"->\");\n                        buf = buf.concat(this.getStateString(t));\n                        buf = buf.concat('\\n');\n                    }\n                }\n           }\n       }\n       return buf.length===0 ? null : buf;\n    }\n\n    getEdgeLabel(i) {\n        if (i===0) {\n            return \"EOF\";\n        } else if(this.literalNames !==null || this.symbolicNames!==null) {\n            return this.literalNames[i-1] || this.symbolicNames[i-1];\n        } else {\n            return String.fromCharCode(i-1);\n        }\n    }\n\n    getStateString(s) {\n        const baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n        if(s.isAcceptState) {\n            if (s.predicates !== null) {\n                return baseStateStr + \"=>\" + Utils.arrayToString(s.predicates);\n            } else {\n                return baseStateStr + \"=>\" + s.prediction.toString();\n            }\n        } else {\n            return baseStateStr;\n        }\n    }\n}\n\nclass LexerDFASerializer extends DFASerializer {\n    constructor(dfa) {\n        super(dfa, null);\n    }\n\n    getEdgeLabel(i) {\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n}\n\nmodule.exports = { DFASerializer , LexerDFASerializer };\n\n"]},"metadata":{},"sourceType":"script"}