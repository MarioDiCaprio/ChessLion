{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./../Token');\n\nconst {\n  Interval\n} = require('./../IntervalSet');\n\nconst INVALID_INTERVAL = new Interval(-1, -2);\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\n\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n  constructor() {\n    super();\n  }\n\n}\n\nclass ParseTree extends SyntaxTree {\n  constructor() {\n    super();\n  }\n\n}\n\nclass RuleNode extends ParseTree {\n  constructor() {\n    super();\n  }\n\n  getRuleContext() {\n    throw new Error(\"missing interface implementation\");\n  }\n\n}\n\nclass TerminalNode extends ParseTree {\n  constructor() {\n    super();\n  }\n\n}\n\nclass ErrorNode extends TerminalNode {\n  constructor() {\n    super();\n  }\n\n}\n\nclass ParseTreeVisitor {\n  visit(ctx) {\n    if (Array.isArray(ctx)) {\n      return ctx.map(function (child) {\n        return child.accept(this);\n      }, this);\n    } else {\n      return ctx.accept(this);\n    }\n  }\n\n  visitChildren(ctx) {\n    if (ctx.children) {\n      return this.visit(ctx.children);\n    } else {\n      return null;\n    }\n  }\n\n  visitTerminal(node) {}\n\n  visitErrorNode(node) {}\n\n}\n\nclass ParseTreeListener {\n  visitTerminal(node) {}\n\n  visitErrorNode(node) {}\n\n  enterEveryRule(node) {}\n\n  exitEveryRule(node) {}\n\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n  constructor(symbol) {\n    super();\n    this.parentCtx = null;\n    this.symbol = symbol;\n  }\n\n  getChild(i) {\n    return null;\n  }\n\n  getSymbol() {\n    return this.symbol;\n  }\n\n  getParent() {\n    return this.parentCtx;\n  }\n\n  getPayload() {\n    return this.symbol;\n  }\n\n  getSourceInterval() {\n    if (this.symbol === null) {\n      return INVALID_INTERVAL;\n    }\n\n    const tokenIndex = this.symbol.tokenIndex;\n    return new Interval(tokenIndex, tokenIndex);\n  }\n\n  getChildCount() {\n    return 0;\n  }\n\n  accept(visitor) {\n    return visitor.visitTerminal(this);\n  }\n\n  getText() {\n    return this.symbol.text;\n  }\n\n  toString() {\n    if (this.symbol.type === Token.EOF) {\n      return \"<EOF>\";\n    } else {\n      return this.symbol.text;\n    }\n  }\n\n}\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\n\n\nclass ErrorNodeImpl extends TerminalNodeImpl {\n  constructor(token) {\n    super(token);\n  }\n\n  isErrorNode() {\n    return true;\n  }\n\n  accept(visitor) {\n    return visitor.visitErrorNode(this);\n  }\n\n}\n\nclass ParseTreeWalker {\n  /**\n   * Performs a walk on the given parse tree starting at the root and going down recursively\n   * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n   * recursively walking down into child nodes, then\n   * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n   * @param listener The listener used by the walker to process grammar rules\n   * @param t The parse tree to be walked on\n   */\n  walk(listener, t) {\n    const errorNode = t instanceof ErrorNode || t.isErrorNode !== undefined && t.isErrorNode();\n\n    if (errorNode) {\n      listener.visitErrorNode(t);\n    } else if (t instanceof TerminalNode) {\n      listener.visitTerminal(t);\n    } else {\n      this.enterRule(listener, t);\n\n      for (let i = 0; i < t.getChildCount(); i++) {\n        const child = t.getChild(i);\n        this.walk(listener, child);\n      }\n\n      this.exitRule(listener, t);\n    }\n  }\n  /**\n   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n   * then by triggering the event specific to the given parse tree node\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */\n\n\n  enterRule(listener, r) {\n    const ctx = r.getRuleContext();\n    listener.enterEveryRule(ctx);\n    ctx.enterRule(listener);\n  }\n  /**\n   * Exits a grammar rule by first triggering the event specific to the given parse tree node\n   * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */\n\n\n  exitRule(listener, r) {\n    const ctx = r.getRuleContext();\n    ctx.exitRule(listener);\n    listener.exitEveryRule(ctx);\n  }\n\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\nmodule.exports = {\n  RuleNode,\n  ErrorNode,\n  TerminalNode,\n  ErrorNodeImpl,\n  TerminalNodeImpl,\n  ParseTreeListener,\n  ParseTreeVisitor,\n  ParseTreeWalker,\n  INVALID_INTERVAL\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/tree/Tree.js"],"names":["Token","require","Interval","INVALID_INTERVAL","Tree","SyntaxTree","constructor","ParseTree","RuleNode","getRuleContext","Error","TerminalNode","ErrorNode","ParseTreeVisitor","visit","ctx","Array","isArray","map","child","accept","visitChildren","children","visitTerminal","node","visitErrorNode","ParseTreeListener","enterEveryRule","exitEveryRule","TerminalNodeImpl","symbol","parentCtx","getChild","i","getSymbol","getParent","getPayload","getSourceInterval","tokenIndex","getChildCount","visitor","getText","text","toString","type","EOF","ErrorNodeImpl","token","isErrorNode","ParseTreeWalker","walk","listener","t","errorNode","undefined","enterRule","exitRule","r","DEFAULT","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {Interval} = require('./../IntervalSet');\nconst INVALID_INTERVAL = new Interval(-1, -2);\n\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTree extends SyntaxTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass RuleNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tgetRuleContext(){\n\t\tthrow new Error(\"missing interface implementation\")\n\t}\n}\n\nclass TerminalNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ErrorNode extends TerminalNode {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTreeVisitor {\n\tvisit(ctx) {\n\t\t if (Array.isArray(ctx)) {\n\t\t\treturn ctx.map(function(child) {\n\t\t\t\treturn child.accept(this);\n\t\t\t}, this);\n\t\t} else {\n\t\t\treturn ctx.accept(this);\n\t\t}\n\t}\n\n\tvisitChildren(ctx) {\n\t\tif (ctx.children) {\n\t\t\treturn this.visit(ctx.children);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n}\n\nclass ParseTreeListener {\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n\n\tenterEveryRule(node) {\n\t}\n\n\texitEveryRule(node) {\n\t}\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n\tconstructor(symbol) {\n\t\tsuper();\n\t\tthis.parentCtx = null;\n\t\tthis.symbol = symbol;\n\t}\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetSymbol() {\n\t\treturn this.symbol;\n\t}\n\n\tgetParent() {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetPayload() {\n\t\treturn this.symbol;\n\t}\n\n\tgetSourceInterval() {\n\t\tif (this.symbol === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t}\n\t\tconst tokenIndex = this.symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\tgetText() {\n\t\treturn this.symbol.text;\n\t}\n\n\ttoString() {\n\t\tif (this.symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else {\n\t\t\treturn this.symbol.text;\n\t\t}\n\t}\n}\n\n\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\nclass ErrorNodeImpl extends TerminalNodeImpl {\n\tconstructor(token) {\n\t\tsuper(token);\n\t}\n\n\tisErrorNode() {\n\t\treturn true;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitErrorNode(this);\n\t}\n}\n\nclass ParseTreeWalker {\n\n\t/**\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\n\t * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n\t * recursively walking down into child nodes, then\n\t * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n\t * @param listener The listener used by the walker to process grammar rules\n\t * @param t The parse tree to be walked on\n\t */\n\twalk(listener, t) {\n\t\tconst errorNode = t instanceof ErrorNode ||\n\t\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\t\tif (errorNode) {\n\t\t\tlistener.visitErrorNode(t);\n\t\t} else if (t instanceof TerminalNode) {\n\t\t\tlistener.visitTerminal(t);\n\t\t} else {\n\t\t\tthis.enterRule(listener, t);\n\t\t\tfor (let i = 0; i < t.getChildCount(); i++) {\n\t\t\t\tconst child = t.getChild(i);\n\t\t\t\tthis.walk(listener, child);\n\t\t\t}\n\t\t\tthis.exitRule(listener, t);\n\t\t}\n\t}\n\n\t/**\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n\t * then by triggering the event specific to the given parse tree node\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\tenterRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tlistener.enterEveryRule(ctx);\n\t\tctx.enterRule(listener);\n\t}\n\n\t/**\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n\t * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\texitRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tctx.exitRule(listener);\n\t\tlistener.exitEveryRule(ctx);\n\t}\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nmodule.exports = {\n\tRuleNode,\n\tErrorNode,\n\tTerminalNode,\n\tErrorNodeImpl,\n\tTerminalNodeImpl,\n\tParseTreeListener,\n\tParseTreeVisitor,\n\tParseTreeWalker,\n\tINVALID_INTERVAL\n}\n"]},"metadata":{},"sourceType":"script"}