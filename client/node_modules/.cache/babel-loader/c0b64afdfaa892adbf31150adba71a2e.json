{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst RuleContext = require('./RuleContext');\n\nconst Tree = require('./tree/Tree');\n\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\n\nconst Interval = require(\"./IntervalSet\").Interval;\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\n\n\nclass ParserRuleContext extends RuleContext {\n  constructor(parent, invokingStateNumber) {\n    parent = parent || null;\n    invokingStateNumber = invokingStateNumber || null;\n    super(parent, invokingStateNumber);\n    this.ruleIndex = -1;\n    /**\n     * If we are debugging or building a parse tree for a visitor,\n     * we need to track all of the tokens and rule invocations associated\n     * with this rule's context. This is empty for parsing w/o tree constr.\n     * operation because we don't the need to track the details about\n     * how we parse this rule.\n     */\n\n    this.children = null;\n    this.start = null;\n    this.stop = null;\n    /**\n     * The exception that forced this rule to return. If the rule successfully\n     * completed, this is {@code null}.\n     */\n\n    this.exception = null;\n  } // COPY a ctx (I'm deliberately not using copy constructor)\n\n\n  copyFrom(ctx) {\n    // from RuleContext\n    this.parentCtx = ctx.parentCtx;\n    this.invokingState = ctx.invokingState;\n    this.children = null;\n    this.start = ctx.start;\n    this.stop = ctx.stop; // copy any error nodes to alt label node\n\n    if (ctx.children) {\n      this.children = []; // reset parent pointer for any error nodes\n\n      ctx.children.map(function (child) {\n        if (child instanceof ErrorNodeImpl) {\n          this.children.push(child);\n          child.parentCtx = this;\n        }\n      }, this);\n    }\n  } // Double dispatch methods for listeners\n\n\n  enterRule(listener) {}\n\n  exitRule(listener) {} // Does not set parent link; other add methods do that\n\n\n  addChild(child) {\n    if (this.children === null) {\n      this.children = [];\n    }\n\n    this.children.push(child);\n    return child;\n  }\n  /** Used by enterOuterAlt to toss out a RuleContext previously added as\n   * we entered a rule. If we have // label, we will need to remove\n   * generic ruleContext object.\n   */\n\n\n  removeLastChild() {\n    if (this.children !== null) {\n      this.children.pop();\n    }\n  }\n\n  addTokenNode(token) {\n    const node = new TerminalNodeImpl(token);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n  }\n\n  addErrorNode(badToken) {\n    const node = new ErrorNodeImpl(badToken);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n  }\n\n  getChild(i, type) {\n    type = type || null;\n\n    if (this.children === null || i < 0 || i >= this.children.length) {\n      return null;\n    }\n\n    if (type === null) {\n      return this.children[i];\n    } else {\n      for (let j = 0; j < this.children.length; j++) {\n        const child = this.children[j];\n\n        if (child instanceof type) {\n          if (i === 0) {\n            return child;\n          } else {\n            i -= 1;\n          }\n        }\n      }\n\n      return null;\n    }\n  }\n\n  getToken(ttype, i) {\n    if (this.children === null || i < 0 || i >= this.children.length) {\n      return null;\n    }\n\n    for (let j = 0; j < this.children.length; j++) {\n      const child = this.children[j];\n\n      if (child instanceof TerminalNode) {\n        if (child.symbol.type === ttype) {\n          if (i === 0) {\n            return child;\n          } else {\n            i -= 1;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  getTokens(ttype) {\n    if (this.children === null) {\n      return [];\n    } else {\n      const tokens = [];\n\n      for (let j = 0; j < this.children.length; j++) {\n        const child = this.children[j];\n\n        if (child instanceof TerminalNode) {\n          if (child.symbol.type === ttype) {\n            tokens.push(child);\n          }\n        }\n      }\n\n      return tokens;\n    }\n  }\n\n  getTypedRuleContext(ctxType, i) {\n    return this.getChild(i, ctxType);\n  }\n\n  getTypedRuleContexts(ctxType) {\n    if (this.children === null) {\n      return [];\n    } else {\n      const contexts = [];\n\n      for (let j = 0; j < this.children.length; j++) {\n        const child = this.children[j];\n\n        if (child instanceof ctxType) {\n          contexts.push(child);\n        }\n      }\n\n      return contexts;\n    }\n  }\n\n  getChildCount() {\n    if (this.children === null) {\n      return 0;\n    } else {\n      return this.children.length;\n    }\n  }\n\n  getSourceInterval() {\n    if (this.start === null || this.stop === null) {\n      return INVALID_INTERVAL;\n    } else {\n      return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n    }\n  }\n\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n  constructor(parent, invokingStateNumber, ruleIndex) {\n    super(parent, invokingStateNumber);\n    this.ruleIndex = ruleIndex;\n  }\n\n}\n\nmodule.exports = ParserRuleContext;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/ParserRuleContext.js"],"names":["RuleContext","require","Tree","INVALID_INTERVAL","TerminalNode","TerminalNodeImpl","ErrorNodeImpl","Interval","ParserRuleContext","constructor","parent","invokingStateNumber","ruleIndex","children","start","stop","exception","copyFrom","ctx","parentCtx","invokingState","map","child","push","enterRule","listener","exitRule","addChild","removeLastChild","pop","addTokenNode","token","node","addErrorNode","badToken","getChild","i","type","length","j","getToken","ttype","symbol","getTokens","tokens","getTypedRuleContext","ctxType","getTypedRuleContexts","contexts","getChildCount","getSourceInterval","tokenIndex","EMPTY","InterpreterRuleContext","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst Tree = require('./tree/Tree');\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\nconst Interval = require(\"./IntervalSet\").Interval;\n\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext {\n\tconstructor(parent, invokingStateNumber) {\n\t\tparent = parent || null;\n\t\tinvokingStateNumber = invokingStateNumber || null;\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = -1;\n\t\t/**\n\t\t * If we are debugging or building a parse tree for a visitor,\n\t\t * we need to track all of the tokens and rule invocations associated\n\t\t * with this rule's context. This is empty for parsing w/o tree constr.\n\t\t * operation because we don't the need to track the details about\n\t\t * how we parse this rule.\n\t\t */\n\t\tthis.children = null;\n\t\tthis.start = null;\n\t\tthis.stop = null;\n\t\t/**\n\t\t * The exception that forced this rule to return. If the rule successfully\n\t\t * completed, this is {@code null}.\n\t\t */\n\t\tthis.exception = null;\n\t}\n\n\t// COPY a ctx (I'm deliberately not using copy constructor)\n\tcopyFrom(ctx) {\n\t\t// from RuleContext\n\t\tthis.parentCtx = ctx.parentCtx;\n\t\tthis.invokingState = ctx.invokingState;\n\t\tthis.children = null;\n\t\tthis.start = ctx.start;\n\t\tthis.stop = ctx.stop;\n\t\t// copy any error nodes to alt label node\n\t\tif(ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tctx.children.map(function(child) {\n\t\t\t\tif (child instanceof ErrorNodeImpl) {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t\tchild.parentCtx = this;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\tenterRule(listener) {\n\t}\n\n\texitRule(listener) {\n\t}\n\n\t// Does not set parent link; other add methods do that\n\taddChild(child) {\n\t\tif (this.children === null) {\n\t\t\tthis.children = [];\n\t\t}\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t * we entered a rule. If we have // label, we will need to remove\n\t * generic ruleContext object.\n\t */\n\tremoveLastChild() {\n\t\tif (this.children !== null) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\taddTokenNode(token) {\n\t\tconst node = new TerminalNodeImpl(token);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\taddErrorNode(badToken) {\n\t\tconst node = new ErrorNodeImpl(badToken);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\tgetChild(i, type) {\n\t\ttype = type || null;\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type === null) {\n\t\t\treturn this.children[i];\n\t\t} else {\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif(child instanceof type) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetToken(ttype, i) {\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\tconst child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetTokens(ttype ) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst tokens = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\t\ttokens.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tgetTypedRuleContext(ctxType, i) {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tgetTypedRuleContexts(ctxType) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst contexts = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof ctxType) {\n\t\t\t\t\tcontexts.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contexts;\n\t\t}\n\t}\n\n\tgetChildCount() {\n\t\tif (this.children=== null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.children.length;\n\t\t}\n\t}\n\n\tgetSourceInterval() {\n\t\tif( this.start === null || this.stop === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t} else {\n\t\t\treturn new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n\t\t}\n\t}\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n\tconstructor(parent, invokingStateNumber, ruleIndex) {\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n}\n\nmodule.exports = ParserRuleContext;\n"]},"metadata":{},"sourceType":"script"}