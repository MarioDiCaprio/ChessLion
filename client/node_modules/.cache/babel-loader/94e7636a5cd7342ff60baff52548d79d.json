{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n  constructor() {\n    this.source = null;\n    this.type = null; // token type of the token\n\n    this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\n    this.start = null; // optional; return -1 if not implemented.\n\n    this.stop = null; // optional; return -1 if not implemented.\n\n    this.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\n    this.line = null; // line=1..n of the 1st character\n\n    this.column = null; // beginning of the line at which it occurs, 0..n-1\n\n    this._text = null; // text of the token.\n  }\n\n  getTokenSource() {\n    return this.source[0];\n  }\n\n  getInputStream() {\n    return this.source[1];\n  }\n\n  get text() {\n    return this._text;\n  }\n\n  set text(text) {\n    this._text = text;\n  }\n\n}\n\nToken.INVALID_TYPE = 0;\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\n\nToken.EPSILON = -2;\nToken.MIN_USER_TOKEN_TYPE = 1;\nToken.EOF = -1;\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\n\nToken.DEFAULT_CHANNEL = 0;\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\n\nToken.HIDDEN_CHANNEL = 1;\n\nclass CommonToken extends Token {\n  constructor(source, type, channel, start, stop) {\n    super();\n    this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n    this.type = type !== undefined ? type : null;\n    this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n    this.start = start !== undefined ? start : -1;\n    this.stop = stop !== undefined ? stop : -1;\n    this.tokenIndex = -1;\n\n    if (this.source[0] !== null) {\n      this.line = source[0].line;\n      this.column = source[0].column;\n    } else {\n      this.column = -1;\n    }\n  }\n  /**\n   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n   *\n   * <p>\n   * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n   * constructed token will share a reference to the {@link //text} field and\n   * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n   * be assigned the result of calling {@link //getText}, and {@link //source}\n   * will be constructed from the result of {@link Token//getTokenSource} and\n   * {@link Token//getInputStream}.</p>\n   *\n   * @param oldToken The token to copy.\n   */\n\n\n  clone() {\n    const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n    t.tokenIndex = this.tokenIndex;\n    t.line = this.line;\n    t.column = this.column;\n    t.text = this.text;\n    return t;\n  }\n\n  toString() {\n    let txt = this.text;\n\n    if (txt !== null) {\n      txt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n    } else {\n      txt = \"<no text>\";\n    }\n\n    return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + this.type + \">\" + (this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" + this.line + \":\" + this.column + \"]\";\n  }\n\n  get text() {\n    if (this._text !== null) {\n      return this._text;\n    }\n\n    const input = this.getInputStream();\n\n    if (input === null) {\n      return null;\n    }\n\n    const n = input.size;\n\n    if (this.start < n && this.stop < n) {\n      return input.getText(this.start, this.stop);\n    } else {\n      return \"<EOF>\";\n    }\n  }\n\n  set text(text) {\n    this._text = text;\n  }\n\n}\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\n\n\nCommonToken.EMPTY_SOURCE = [null, null];\nmodule.exports = {\n  Token,\n  CommonToken\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/Token.js"],"names":["Token","constructor","source","type","channel","start","stop","tokenIndex","line","column","_text","getTokenSource","getInputStream","text","INVALID_TYPE","EPSILON","MIN_USER_TOKEN_TYPE","EOF","DEFAULT_CHANNEL","HIDDEN_CHANNEL","CommonToken","undefined","EMPTY_SOURCE","clone","t","toString","txt","replace","input","n","size","getText","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n\tconstructor() {\n\t\tthis.source = null;\n\t\tthis.type = null; // token type of the token\n\t\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\t\tthis.start = null; // optional; return -1 if not implemented.\n\t\tthis.stop = null; // optional; return -1 if not implemented.\n\t\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\t\tthis.line = null; // line=1..n of the 1st character\n\t\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\t\tthis._text = null; // text of the token.\n\t}\n\n\tgetTokenSource() {\n\t\treturn this.source[0];\n\t}\n\n\tgetInputStream() {\n\t\treturn this.source[1];\n\t}\n\n\tget text(){\n\t\treturn this._text;\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\nToken.INVALID_TYPE = 0;\n\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\nToken.DEFAULT_CHANNEL = 0;\n\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\nToken.HIDDEN_CHANNEL = 1;\n\n\nclass CommonToken extends Token {\n\tconstructor(source, type, channel, start, stop) {\n\t\tsuper();\n\t\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\t\tthis.type = type !== undefined ? type : null;\n\t\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\t\tthis.start = start !== undefined ? start : -1;\n\t\tthis.stop = stop !== undefined ? stop : -1;\n\t\tthis.tokenIndex = -1;\n\t\tif (this.source[0] !== null) {\n\t\t\tthis.line = source[0].line;\n\t\t\tthis.column = source[0].column;\n\t\t} else {\n\t\t\tthis.column = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * <p>\n\t * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link //text} field and\n\t * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n\t * be assigned the result of calling {@link //getText}, and {@link //source}\n\t * will be constructed from the result of {@link Token//getTokenSource} and\n\t * {@link Token//getInputStream}.</p>\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tclone() {\n\t\tconst t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n\t\tt.tokenIndex = this.tokenIndex;\n\t\tt.line = this.line;\n\t\tt.column = this.column;\n\t\tt.text = this.text;\n\t\treturn t;\n\t}\n\n\ttoString() {\n\t\tlet txt = this.text;\n\t\tif (txt !== null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\t\tthis.line + \":\" + this.column + \"]\";\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tconst input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\nmodule.exports = {\n\tToken,\n\tCommonToken\n}\n"]},"metadata":{},"sourceType":"script"}