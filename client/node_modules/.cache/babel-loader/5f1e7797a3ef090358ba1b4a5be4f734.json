{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  ATNConfigSet\n} = require('./../atn/ATNConfigSet');\n\nconst {\n  Hash,\n  Set\n} = require('./../Utils');\n/**\n * Map a predicate to a predicted alternative.\n */\n\n\nclass PredPrediction {\n  constructor(pred, alt) {\n    this.alt = alt;\n    this.pred = pred;\n  }\n\n  toString() {\n    return \"(\" + this.pred + \", \" + this.alt + \")\";\n  }\n\n}\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\n\n\nclass DFAState {\n  constructor(stateNumber, configs) {\n    if (stateNumber === null) {\n      stateNumber = -1;\n    }\n\n    if (configs === null) {\n      configs = new ATNConfigSet();\n    }\n\n    this.stateNumber = stateNumber;\n    this.configs = configs;\n    /**\n     * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n     * {@link Token//EOF} maps to {@code edges[0]}.\n     */\n\n    this.edges = null;\n    this.isAcceptState = false;\n    /**\n     * if accept state, what ttype do we match or alt do we predict?\n     * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n     * {@code !=null} or {@link //requiresFullContext}.\n     */\n\n    this.prediction = 0;\n    this.lexerActionExecutor = null;\n    /**\n     * Indicates that this state was created during SLL prediction that\n     * discovered a conflict between the configurations in the state. Future\n     * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n     * full context prediction if this field is true.\n     */\n\n    this.requiresFullContext = false;\n    /**\n     * During SLL parsing, this is a list of predicates associated with the\n     * ATN configurations of the DFA state. When we have predicates,\n     * {@link //requiresFullContext} is {@code false} since full context\n     * prediction evaluates predicates\n     * on-the-fly. If this is not null, then {@link //prediction} is\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * <p>We only use these for non-{@link //requiresFullContext} but\n     * conflicting states. That\n     * means we know from the context (it's $ or we don't dip into outer\n     * context) that it's an ambiguity not a conflict.</p>\n     *\n     * <p>This list is computed by {@link\n     * ParserATNSimulator//predicateDFAState}.</p>\n     */\n\n    this.predicates = null;\n    return this;\n  }\n  /**\n   * Get the set of all alts mentioned by all ATN configurations in this\n   * DFA state.\n   */\n\n\n  getAltSet() {\n    const alts = new Set();\n\n    if (this.configs !== null) {\n      for (let i = 0; i < this.configs.length; i++) {\n        const c = this.configs[i];\n        alts.add(c.alt);\n      }\n    }\n\n    if (alts.length === 0) {\n      return null;\n    } else {\n      return alts;\n    }\n  }\n  /**\n   * Two {@link DFAState} instances are equal if their ATN configuration sets\n   * are the same. This method is used to see if a state already exists.\n   *\n   * <p>Because the number of alternatives and number of ATN configurations are\n   * finite, there is a finite number of DFA states that can be processed.\n   * This is necessary to show that the algorithm terminates.</p>\n   *\n   * <p>Cannot test the DFA state numbers here because in\n   * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n   * exists that has this exact set of ATN configurations. The\n   * {@link //stateNumber} is irrelevant.</p>\n   */\n\n\n  equals(other) {\n    // compare set of ATN configurations in this set with other\n    return this === other || other instanceof DFAState && this.configs.equals(other.configs);\n  }\n\n  toString() {\n    let s = \"\" + this.stateNumber + \":\" + this.configs;\n\n    if (this.isAcceptState) {\n      s = s + \"=>\";\n      if (this.predicates !== null) s = s + this.predicates;else s = s + this.prediction;\n    }\n\n    return s;\n  }\n\n  hashCode() {\n    const hash = new Hash();\n    hash.update(this.configs);\n    return hash.finish();\n  }\n\n}\n\nmodule.exports = {\n  DFAState,\n  PredPrediction\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/dfa/DFAState.js"],"names":["ATNConfigSet","require","Hash","Set","PredPrediction","constructor","pred","alt","toString","DFAState","stateNumber","configs","edges","isAcceptState","prediction","lexerActionExecutor","requiresFullContext","predicates","getAltSet","alts","i","length","c","add","equals","other","s","hashCode","hash","update","finish","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {Hash, Set} = require('./../Utils');\n\n/**\n * Map a predicate to a predicted alternative.\n */\nclass PredPrediction {\n\tconstructor(pred, alt) {\n\t\tthis.alt = alt;\n\t\tthis.pred = pred;\n\t}\n\n\ttoString() {\n\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n\t}\n}\n\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\nclass DFAState {\n\tconstructor(stateNumber, configs) {\n\t\tif (stateNumber === null) {\n\t\t\tstateNumber = -1;\n\t\t}\n\t\tif (configs === null) {\n\t\t\tconfigs = new ATNConfigSet();\n\t\t}\n\t\tthis.stateNumber = stateNumber;\n\t\tthis.configs = configs;\n\t\t/**\n\t\t * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t\t * {@link Token//EOF} maps to {@code edges[0]}.\n\t\t */\n\t\tthis.edges = null;\n\t\tthis.isAcceptState = false;\n\t\t/**\n\t\t * if accept state, what ttype do we match or alt do we predict?\n\t\t * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n\t\t * {@code !=null} or {@link //requiresFullContext}.\n\t\t */\n\t\tthis.prediction = 0;\n\t\tthis.lexerActionExecutor = null;\n\t\t/**\n\t\t * Indicates that this state was created during SLL prediction that\n\t\t * discovered a conflict between the configurations in the state. Future\n\t\t * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t\t * full context prediction if this field is true.\n\t\t */\n\t\tthis.requiresFullContext = false;\n\t\t/**\n\t\t * During SLL parsing, this is a list of predicates associated with the\n\t\t * ATN configurations of the DFA state. When we have predicates,\n\t\t * {@link //requiresFullContext} is {@code false} since full context\n\t\t * prediction evaluates predicates\n\t\t * on-the-fly. If this is not null, then {@link //prediction} is\n\t\t * {@link ATN//INVALID_ALT_NUMBER}.\n\t\t *\n\t\t * <p>We only use these for non-{@link //requiresFullContext} but\n\t\t * conflicting states. That\n\t\t * means we know from the context (it's $ or we don't dip into outer\n\t\t * context) that it's an ambiguity not a conflict.</p>\n\t\t *\n\t\t * <p>This list is computed by {@link\n\t\t * ParserATNSimulator//predicateDFAState}.</p>\n\t\t */\n\t\tthis.predicates = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the set of all alts mentioned by all ATN configurations in this\n\t * DFA state.\n\t */\n\tgetAltSet() {\n\t\tconst alts = new Set();\n\t\tif (this.configs !== null) {\n\t\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\t\tconst c = this.configs[i];\n\t\t\t\talts.add(c.alt);\n\t\t\t}\n\t\t}\n\t\tif (alts.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn alts;\n\t\t}\n\t}\n\n\t/**\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\n\t * are the same. This method is used to see if a state already exists.\n\t *\n\t * <p>Because the number of alternatives and number of ATN configurations are\n\t * finite, there is a finite number of DFA states that can be processed.\n\t * This is necessary to show that the algorithm terminates.</p>\n\t *\n\t * <p>Cannot test the DFA state numbers here because in\n\t * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n\t * exists that has this exact set of ATN configurations. The\n\t * {@link //stateNumber} is irrelevant.</p>\n\t */\n\tequals(other) {\n\t\t// compare set of ATN configurations in this set with other\n\t\treturn this === other ||\n\t\t\t\t(other instanceof DFAState &&\n\t\t\t\t\tthis.configs.equals(other.configs));\n\t}\n\n\ttoString() {\n\t\tlet s = \"\" + this.stateNumber + \":\" + this.configs;\n\t\tif(this.isAcceptState) {\n\t\t\ts = s + \"=>\";\n\t\t\tif (this.predicates !== null)\n\t\t\t\ts = s + this.predicates;\n\t\t\telse\n\t\t\t\ts = s + this.prediction;\n\t\t}\n\t\treturn s;\n\t}\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n}\n\nmodule.exports = { DFAState, PredPrediction };\n"]},"metadata":{},"sourceType":"script"}