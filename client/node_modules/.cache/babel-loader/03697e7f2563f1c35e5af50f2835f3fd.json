{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst INITIAL_NUM_TRANSITIONS = 4;\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\n\nclass ATNState {\n  constructor() {\n    // Which ATN are we in?\n    this.atn = null;\n    this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n    this.stateType = null;\n    this.ruleIndex = 0; // at runtime, we don't have Rule objects\n\n    this.epsilonOnlyTransitions = false; // Track the transitions emanating from this ATN state.\n\n    this.transitions = []; // Used to cache lookahead during parsing, not used during construction\n\n    this.nextTokenWithinRule = null;\n  }\n\n  toString() {\n    return this.stateNumber;\n  }\n\n  equals(other) {\n    if (other instanceof ATNState) {\n      return this.stateNumber === other.stateNumber;\n    } else {\n      return false;\n    }\n  }\n\n  isNonGreedyExitState() {\n    return false;\n  }\n\n  addTransition(trans, index) {\n    if (index === undefined) {\n      index = -1;\n    }\n\n    if (this.transitions.length === 0) {\n      this.epsilonOnlyTransitions = trans.isEpsilon;\n    } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {\n      this.epsilonOnlyTransitions = false;\n    }\n\n    if (index === -1) {\n      this.transitions.push(trans);\n    } else {\n      this.transitions.splice(index, 1, trans);\n    }\n  }\n\n} // constants for serialization\n\n\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\nATNState.serializationNames = [\"INVALID\", \"BASIC\", \"RULE_START\", \"BLOCK_START\", \"PLUS_BLOCK_START\", \"STAR_BLOCK_START\", \"TOKEN_START\", \"RULE_STOP\", \"BLOCK_END\", \"STAR_LOOP_BACK\", \"STAR_LOOP_ENTRY\", \"PLUS_LOOP_BACK\", \"LOOP_END\"];\nATNState.INVALID_STATE_NUMBER = -1;\n\nclass BasicState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.BASIC;\n  }\n\n}\n\nclass DecisionState extends ATNState {\n  constructor() {\n    super();\n    this.decision = -1;\n    this.nonGreedy = false;\n    return this;\n  }\n\n}\n/**\n *  The start of a regular {@code (...)} block\n */\n\n\nclass BlockStartState extends DecisionState {\n  constructor() {\n    super();\n    this.endState = null;\n    return this;\n  }\n\n}\n\nclass BasicBlockStartState extends BlockStartState {\n  constructor() {\n    super();\n    this.stateType = ATNState.BLOCK_START;\n    return this;\n  }\n\n}\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\n\n\nclass BlockEndState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.BLOCK_END;\n    this.startState = null;\n    return this;\n  }\n\n}\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\n\n\nclass RuleStopState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.RULE_STOP;\n    return this;\n  }\n\n}\n\nclass RuleStartState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.RULE_START;\n    this.stopState = null;\n    this.isPrecedenceRule = false;\n    return this;\n  }\n\n}\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\n\n\nclass PlusLoopbackState extends DecisionState {\n  constructor() {\n    super();\n    this.stateType = ATNState.PLUS_LOOP_BACK;\n    return this;\n  }\n\n}\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\n\n\nclass PlusBlockStartState extends BlockStartState {\n  constructor() {\n    super();\n    this.stateType = ATNState.PLUS_BLOCK_START;\n    this.loopBackState = null;\n    return this;\n  }\n\n}\n/**\n * The block that begins a closure loop\n */\n\n\nclass StarBlockStartState extends BlockStartState {\n  constructor() {\n    super();\n    this.stateType = ATNState.STAR_BLOCK_START;\n    return this;\n  }\n\n}\n\nclass StarLoopbackState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.STAR_LOOP_BACK;\n    return this;\n  }\n\n}\n\nclass StarLoopEntryState extends DecisionState {\n  constructor() {\n    super();\n    this.stateType = ATNState.STAR_LOOP_ENTRY;\n    this.loopBackState = null; // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n\n    this.isPrecedenceDecision = null;\n    return this;\n  }\n\n}\n/**\n * Mark the end of a * or + loop\n */\n\n\nclass LoopEndState extends ATNState {\n  constructor() {\n    super();\n    this.stateType = ATNState.LOOP_END;\n    this.loopBackState = null;\n    return this;\n  }\n\n}\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\n\n\nclass TokensStartState extends DecisionState {\n  constructor() {\n    super();\n    this.stateType = ATNState.TOKEN_START;\n    return this;\n  }\n\n}\n\nmodule.exports = {\n  ATNState,\n  BasicState,\n  DecisionState,\n  BlockStartState,\n  BlockEndState,\n  LoopEndState,\n  RuleStartState,\n  RuleStopState,\n  TokensStartState,\n  PlusLoopbackState,\n  StarLoopbackState,\n  StarLoopEntryState,\n  PlusBlockStartState,\n  StarBlockStartState,\n  BasicBlockStartState\n};","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ATNState.js"],"names":["INITIAL_NUM_TRANSITIONS","ATNState","constructor","atn","stateNumber","INVALID_STATE_NUMBER","stateType","ruleIndex","epsilonOnlyTransitions","transitions","nextTokenWithinRule","toString","equals","other","isNonGreedyExitState","addTransition","trans","index","undefined","length","isEpsilon","push","splice","INVALID_TYPE","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","LOOP_END","serializationNames","BasicState","DecisionState","decision","nonGreedy","BlockStartState","endState","BasicBlockStartState","BlockEndState","startState","RuleStopState","RuleStartState","stopState","isPrecedenceRule","PlusLoopbackState","PlusBlockStartState","loopBackState","StarBlockStartState","StarLoopbackState","StarLoopEntryState","isPrecedenceDecision","LoopEndState","TokensStartState","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst INITIAL_NUM_TRANSITIONS = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        // Which ATN are we in?\n        this.atn = null;\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.stateType = null;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        // Track the transitions emanating from this ATN state.\n        this.transitions = [];\n        // Used to cache lookahead during parsing, not used during construction\n        this.nextTokenWithinRule = null;\n    }\n\n    toString() {\n        return this.stateNumber;\n    }\n\n    equals(other) {\n        if (other instanceof ATNState) {\n            return this.stateNumber===other.stateNumber;\n        } else {\n            return false;\n        }\n    }\n\n    isNonGreedyExitState() {\n        return false;\n    }\n\n    addTransition(trans, index) {\n        if(index===undefined) {\n            index = -1;\n        }\n        if (this.transitions.length===0) {\n            this.epsilonOnlyTransitions = trans.isEpsilon;\n        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n        }\n        if (index===-1) {\n            this.transitions.push(trans);\n        } else {\n            this.transitions.splice(index, 1, trans);\n        }\n    }\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\n\nclass BasicState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BASIC;\n    }\n}\n\nclass DecisionState extends ATNState {\n    constructor() {\n        super();\n        this.decision = -1;\n        this.nonGreedy = false;\n        return this;\n    }\n}\n\n/**\n *  The start of a regular {@code (...)} block\n */\nclass BlockStartState extends DecisionState {\n    constructor() {\n        super();\n        this.endState = null;\n        return this;\n    }\n}\n\nclass BasicBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_START;\n        return this;\n    }\n}\n\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\nclass BlockEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_END;\n        this.startState = null;\n        return this;\n    }\n}\n\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\nclass RuleStopState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_STOP;\n        return this;\n    }\n}\n\nclass RuleStartState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_START;\n        this.stopState = null;\n        this.isPrecedenceRule = false;\n        return this;\n    }\n}\n\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\nclass PlusLoopbackState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_LOOP_BACK;\n        return this;\n    }\n}\n\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\nclass PlusBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_BLOCK_START;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The block that begins a closure loop\n */\nclass StarBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_BLOCK_START;\n        return this;\n    }\n}\n\nclass StarLoopbackState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_BACK;\n        return this;\n    }\n}\n\nclass StarLoopEntryState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_ENTRY;\n        this.loopBackState = null;\n        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n        this.isPrecedenceDecision = null;\n        return this;\n    }\n}\n\n/**\n * Mark the end of a * or + loop\n */\nclass LoopEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.LOOP_END;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\nclass TokensStartState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.TOKEN_START;\n        return this;\n    }\n}\n\nmodule.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n}\n"]},"metadata":{},"sourceType":"script"}