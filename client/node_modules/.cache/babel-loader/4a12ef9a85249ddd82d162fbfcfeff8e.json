{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Map,\n  BitSet,\n  AltDict,\n  hashStuff\n} = require('./../Utils');\n\nconst ATN = require('./ATN');\n\nconst {\n  RuleStopState\n} = require('./ATNState');\n\nconst {\n  ATNConfigSet\n} = require('./ATNConfigSet');\n\nconst {\n  ATNConfig\n} = require('./ATNConfig');\n\nconst {\n  SemanticContext\n} = require('./SemanticContext');\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\n\n\nconst PredictionMode = {\n  /**\n   * The SLL(*) prediction mode. This prediction mode ignores the current\n   * parser context when making predictions. This is the fastest prediction\n   * mode, and provides correct results for many grammars. This prediction\n   * mode is more powerful than the prediction mode provided by ANTLR 3, but\n   * may result in syntax errors for grammar and input combinations which are\n   * not SLL.\n   *\n   * <p>\n   * When using this prediction mode, the parser will either return a correct\n   * parse tree (i.e. the same parse tree that would be returned with the\n   * {@link //LL} prediction mode), or it will report a syntax error. If a\n   * syntax error is encountered when using the {@link //SLL} prediction mode,\n   * it may be due to either an actual syntax error in the input or indicate\n   * that the particular combination of grammar and input requires the more\n   * powerful {@link //LL} prediction abilities to complete successfully.</p>\n   *\n   * <p>\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.</p>\n   */\n  SLL: 0,\n\n  /**\n   * The LL(*) prediction mode. This prediction mode allows the current parser\n   * context to be used for resolving SLL conflicts that occur during\n   * prediction. This is the fastest prediction mode that guarantees correct\n   * parse results for all combinations of grammars with syntactically correct\n   * inputs.\n   *\n   * <p>\n   * When using this prediction mode, the parser will make correct decisions\n   * for all syntactically-correct grammar and input combinations. However, in\n   * cases where the grammar is truly ambiguous this prediction mode might not\n   * report a precise answer for <em>exactly which</em> alternatives are\n   * ambiguous.</p>\n   *\n   * <p>\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.</p>\n   */\n  LL: 1,\n\n  /**\n   *\n   * The LL(*) prediction mode with exact ambiguity detection. In addition to\n   * the correctness guarantees provided by the {@link //LL} prediction mode,\n   * this prediction mode instructs the prediction algorithm to determine the\n   * complete and exact set of ambiguous alternatives for every ambiguous\n   * decision encountered while parsing.\n   *\n   * <p>\n   * This prediction mode may be used for diagnosing ambiguities during\n   * grammar development. Due to the performance overhead of calculating sets\n   * of ambiguous alternatives, this prediction mode should be avoided when\n   * the exact results are not necessary.</p>\n   *\n   * <p>\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.</p>\n   */\n  LL_EXACT_AMBIG_DETECTION: 2,\n\n  /**\n   *\n   * Computes the SLL prediction termination condition.\n   *\n   * <p>\n   * This method computes the SLL prediction termination condition for both of\n   * the following cases.</p>\n   *\n   * <ul>\n   * <li>The usual SLL+LL fallback upon SLL conflict</li>\n   * <li>Pure SLL without LL fallback</li>\n   * </ul>\n   *\n   * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n   *\n   * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n   * ensured regardless of how the termination condition is computed by this\n   * method. Due to the substantially higher cost of LL prediction, the\n   * prediction should only fall back to LL when the additional lookahead\n   * cannot lead to a unique SLL prediction.</p>\n   *\n   * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n   * conflicting subsets should fall back to full LL, even if the\n   * configuration sets don't resolve to the same alternative (e.g.\n   * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n   * configuration, SLL could continue with the hopes that more lookahead will\n   * resolve via one of those non-conflicting configurations.</p>\n   *\n   * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n   * stops when it sees only conflicting configuration subsets. In contrast,\n   * full LL keeps going when there is uncertainty.</p>\n   *\n   * <p><strong>HEURISTIC</strong></p>\n   *\n   * <p>As a heuristic, we stop prediction when we see any conflicting subset\n   * unless we see a state that only has one alternative associated with it.\n   * The single-alt-state thing lets prediction continue upon rules like\n   * (otherwise, it would admit defeat too soon):</p>\n   *\n   * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n   *\n   * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n   * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n   * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n   * processing this node because alternative to has another way to continue,\n   * via {@code [6|2|[]]}.</p>\n   *\n   * <p>It also let's us continue for this rule:</p>\n   *\n   * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n   *\n   * <p>After matching input A, we reach the stop state for rule A, state 1.\n   * State 8 is the state right before B. Clearly alternatives 1 and 2\n   * conflict and no amount of further lookahead will separate the two.\n   * However, alternative 3 will be able to continue and so we do not stop\n   * working on this state. In the previous example, we're concerned with\n   * states associated with the conflicting alternatives. Here alt 3 is not\n   * associated with the conflicting configs, but since we can continue\n   * looking for input reasonably, don't declare the state done.</p>\n   *\n   * <p><strong>PURE SLL PARSING</strong></p>\n   *\n   * <p>To handle pure SLL parsing, all we have to do is make sure that we\n   * combine stack contexts for configurations that differ only by semantic\n   * predicate. From there, we can do the usual SLL termination heuristic.</p>\n   *\n   * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n   *\n   * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n   * states because they need to create the DFA cache that works in all\n   * semantic situations. In contrast, full LL evaluates predicates collected\n   * during start state computation so it can ignore predicates thereafter.\n   * This means that SLL termination detection can totally ignore semantic\n   * predicates.</p>\n   *\n   * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n   * semantic predicate contexts so we might see two configurations like the\n   * following.</p>\n   *\n   * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n   *\n   * <p>Before testing these configurations against others, we have to merge\n   * {@code x} and {@code x'} (without modifying the existing configurations).\n   * For example, we test {@code (x+x')==x''} when looking for conflicts in\n   * the following configurations.</p>\n   *\n   * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n   *\n   * <p>If the configuration set has predicates (as indicated by\n   * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n   * the configurations to strip out all of the predicates so that a standard\n   * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n   */\n  hasSLLConflictTerminatingPrediction: function (mode, configs) {\n    // Configs in rule stop states indicate reaching the end of the decision\n    // rule (local context) or end of start rule (full context). If all\n    // configs meet this condition, then none of the configurations is able\n    // to match additional input so we terminate prediction.\n    //\n    if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n      return true;\n    } // pure SLL mode parsing\n\n\n    if (mode === PredictionMode.SLL) {\n      // Don't bother with combining configs from different semantic\n      // contexts if we can fail over to full LL; costs more time\n      // since we'll often fail over anyway.\n      if (configs.hasSemanticContext) {\n        // dup configs, tossing out semantic predicates\n        const dup = new ATNConfigSet();\n\n        for (let i = 0; i < configs.items.length; i++) {\n          let c = configs.items[i];\n          c = new ATNConfig({\n            semanticContext: SemanticContext.NONE\n          }, c);\n          dup.add(c);\n        }\n\n        configs = dup;\n      } // now we have combined contexts for configs with dissimilar preds\n\n    } // pure SLL or combined SLL+LL mode parsing\n\n\n    const altsets = PredictionMode.getConflictingAltSubsets(configs);\n    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n  },\n\n  /**\n   * Checks if any configuration in {@code configs} is in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @return {@code true} if any configuration in {@code configs} is in a\n   * {@link RuleStopState}, otherwise {@code false}\n   */\n  hasConfigInRuleStopState: function (configs) {\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (c.state instanceof RuleStopState) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Checks if all configurations in {@code configs} are in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @return {@code true} if all configurations in {@code configs} are in a\n   * {@link RuleStopState}, otherwise {@code false}\n   */\n  allConfigsInRuleStopStates: function (configs) {\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (!(c.state instanceof RuleStopState)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   *\n   * Full LL prediction termination.\n   *\n   * <p>Can we stop looking ahead during ATN simulation or is there some\n   * uncertainty as to which alternative we will ultimately pick, after\n   * consuming more input? Even if there are partial conflicts, we might know\n   * that everything is going to resolve to the same minimum alternative. That\n   * means we can stop since no more lookahead will change that fact. On the\n   * other hand, there might be multiple conflicts that resolve to different\n   * minimums. That means we need more look ahead to decide which of those\n   * alternatives we should predict.</p>\n   *\n   * <p>The basic idea is to split the set of configurations {@code C}, into\n   * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n   * non-conflicting configurations. Two configurations conflict if they have\n   * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n   * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n   * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n   *\n   * <p>Reduce these configuration subsets to the set of possible alternatives.\n   * You can compute the alternative subsets in one pass as follows:</p>\n   *\n   * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n   * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n   *\n   * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n   *\n   * <pre>\n   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * </pre>\n   *\n   * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n   *\n   * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n   * {@code s} and {@code ctx}.</p>\n   *\n   * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n   * the union of these alternative subsets is a singleton, then no amount of\n   * more lookahead will help us. We will always pick that alternative. If,\n   * however, there is more than one alternative, then we are uncertain which\n   * alternative to predict and must continue looking for resolution. We may\n   * or may not discover an ambiguity in the future, even if there are no\n   * conflicting subsets this round.</p>\n   *\n   * <p>The biggest sin is to terminate early because it means we've made a\n   * decision but were uncertain as to the eventual outcome. We haven't used\n   * enough lookahead. On the other hand, announcing a conflict too late is no\n   * big deal; you will still have the conflict. It's just inefficient. It\n   * might even look until the end of file.</p>\n   *\n   * <p>No special consideration for semantic predicates is required because\n   * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n   * no configuration contains a semantic context during the termination\n   * check.</p>\n   *\n   * <p><strong>CONFLICTING CONFIGS</strong></p>\n   *\n   * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n   * when {@code i!=j} but {@code x=x'}. Because we merge all\n   * {@code (s, i, _)} configurations together, that means that there are at\n   * most {@code n} configurations associated with state {@code s} for\n   * {@code n} possible alternatives in the decision. The merged stacks\n   * complicate the comparison of configuration contexts {@code x} and\n   * {@code x'}. Sam checks to see if one is a subset of the other by calling\n   * merge and checking to see if the merged result is either {@code x} or\n   * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n   * is the superset, then {@code i} is the only possible prediction since the\n   * others resolve to {@code min(i)} as well. However, if {@code x} is\n   * associated with {@code j>i} then at least one stack configuration for\n   * {@code j} is not in conflict with alternative {@code i}. The algorithm\n   * should keep going, looking for more lookahead due to the uncertainty.</p>\n   *\n   * <p>For simplicity, I'm doing a equality check between {@code x} and\n   * {@code x'} that lets the algorithm continue to consume lookahead longer\n   * than necessary. The reason I like the equality is of course the\n   * simplicity but also because that is the test you need to detect the\n   * alternatives that are actually in conflict.</p>\n   *\n   * <p><strong>CONTINUE/STOP RULE</strong></p>\n   *\n   * <p>Continue if union of resolved alternative sets from non-conflicting and\n   * conflicting alternative subsets has more than one alternative. We are\n   * uncertain about which alternative to predict.</p>\n   *\n   * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n   * alternatives are still in the running for the amount of input we've\n   * consumed at this point. The conflicting sets let us to strip away\n   * configurations that won't lead to more states because we resolve\n   * conflicts to the configuration with a minimum alternate for the\n   * conflicting set.</p>\n   *\n   * <p><strong>CASES</strong></p>\n   *\n   * <ul>\n   *\n   * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n   *\n   * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n   * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n   * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n   * {@code {1,3}} =&gt; continue\n   * </li>\n   *\n   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n   * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n   * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n   * {@code {1}} =&gt; stop and predict 1</li>\n   *\n   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n   * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n   * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n   * ambiguity {@code {1,2}}</li>\n   *\n   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n   * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n   * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n   *\n   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n   * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n   * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n   *\n   * </ul>\n   *\n   * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n   *\n   * <p>If all states report the same conflicting set of alternatives, then we\n   * know we have the exact ambiguity set.</p>\n   *\n   * <p><code>|A_<em>i</em>|&gt;1</code> and\n   * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n   *\n   * <p>In other words, we continue examining lookahead until all {@code A_i}\n   * have more than one alternative and all {@code A_i} are the same. If\n   * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n   * because the resolved set is {@code {1}}. To determine what the real\n   * ambiguity is, we have to know whether the ambiguity is between one and\n   * two or one and three so we keep going. We can only stop prediction when\n   * we need exact ambiguity detection when the sets look like\n   * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n   */\n  resolvesToJustOneViableAlt: function (altsets) {\n    return PredictionMode.getSingleViableAlt(altsets);\n  },\n\n  /**\n   * Determines if every alternative subset in {@code altsets} contains more\n   * than one alternative.\n   *\n   * @param altsets a collection of alternative subsets\n   * @return {@code true} if every {@link BitSet} in {@code altsets} has\n   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n   */\n  allSubsetsConflict: function (altsets) {\n    return !PredictionMode.hasNonConflictingAltSet(altsets);\n  },\n\n  /**\n   * Determines if any single alternative subset in {@code altsets} contains\n   * exactly one alternative.\n   *\n   * @param altsets a collection of alternative subsets\n   * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n   */\n  hasNonConflictingAltSet: function (altsets) {\n    for (let i = 0; i < altsets.length; i++) {\n      const alts = altsets[i];\n\n      if (alts.length === 1) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Determines if any single alternative subset in {@code altsets} contains\n   * more than one alternative.\n   *\n   * @param altsets a collection of alternative subsets\n   * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n   */\n  hasConflictingAltSet: function (altsets) {\n    for (let i = 0; i < altsets.length; i++) {\n      const alts = altsets[i];\n\n      if (alts.length > 1) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Determines if every alternative subset in {@code altsets} is equivalent.\n   *\n   * @param altsets a collection of alternative subsets\n   * @return {@code true} if every member of {@code altsets} is equal to the\n   * others, otherwise {@code false}\n   */\n  allSubsetsEqual: function (altsets) {\n    let first = null;\n\n    for (let i = 0; i < altsets.length; i++) {\n      const alts = altsets[i];\n\n      if (first === null) {\n        first = alts;\n      } else if (alts !== first) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Returns the unique alternative predicted by all alternative subsets in\n   * {@code altsets}. If no such alternative exists, this method returns\n   * {@link ATN//INVALID_ALT_NUMBER}.\n   *\n   * @param altsets a collection of alternative subsets\n   */\n  getUniqueAlt: function (altsets) {\n    const all = PredictionMode.getAlts(altsets);\n\n    if (all.length === 1) {\n      return all.minValue();\n    } else {\n      return ATN.INVALID_ALT_NUMBER;\n    }\n  },\n\n  /**\n   * Gets the complete set of represented alternatives for a collection of\n   * alternative subsets. This method returns the union of each {@link BitSet}\n   * in {@code altsets}.\n   *\n   * @param altsets a collection of alternative subsets\n   * @return the set of represented alternatives in {@code altsets}\n   */\n  getAlts: function (altsets) {\n    const all = new BitSet();\n    altsets.map(function (alts) {\n      all.or(alts);\n    });\n    return all;\n  },\n\n  /**\n   * This function gets the conflicting alt subsets from a configuration set.\n   * For each configuration {@code c} in {@code configs}:\n   *\n   * <pre>\n   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * </pre>\n   */\n  getConflictingAltSubsets: function (configs) {\n    const configToAlts = new Map();\n\n    configToAlts.hashFunction = function (cfg) {\n      hashStuff(cfg.state.stateNumber, cfg.context);\n    };\n\n    configToAlts.equalsFunction = function (c1, c2) {\n      return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);\n    };\n\n    configs.items.map(function (cfg) {\n      let alts = configToAlts.get(cfg);\n\n      if (alts === null) {\n        alts = new BitSet();\n        configToAlts.put(cfg, alts);\n      }\n\n      alts.add(cfg.alt);\n    });\n    return configToAlts.getValues();\n  },\n\n  /**\n   * Get a map from state to alt subset from a configuration set. For each\n   * configuration {@code c} in {@code configs}:\n   *\n   * <pre>\n   * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n   * </pre>\n   */\n  getStateToAltMap: function (configs) {\n    const m = new AltDict();\n    configs.items.map(function (c) {\n      let alts = m.get(c.state);\n\n      if (alts === null) {\n        alts = new BitSet();\n        m.put(c.state, alts);\n      }\n\n      alts.add(c.alt);\n    });\n    return m;\n  },\n  hasStateAssociatedWithOneAlt: function (configs) {\n    const values = PredictionMode.getStateToAltMap(configs).values();\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i].length === 1) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  getSingleViableAlt: function (altsets) {\n    let result = null;\n\n    for (let i = 0; i < altsets.length; i++) {\n      const alts = altsets[i];\n      const minAlt = alts.minValue();\n\n      if (result === null) {\n        result = minAlt;\n      } else if (result !== minAlt) {\n        // more than 1 viable alt\n        return ATN.INVALID_ALT_NUMBER;\n      }\n    }\n\n    return result;\n  }\n};\nmodule.exports = PredictionMode;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/PredictionMode.js"],"names":["Map","BitSet","AltDict","hashStuff","require","ATN","RuleStopState","ATNConfigSet","ATNConfig","SemanticContext","PredictionMode","SLL","LL","LL_EXACT_AMBIG_DETECTION","hasSLLConflictTerminatingPrediction","mode","configs","allConfigsInRuleStopStates","hasSemanticContext","dup","i","items","length","c","semanticContext","NONE","add","altsets","getConflictingAltSubsets","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasConfigInRuleStopState","state","resolvesToJustOneViableAlt","getSingleViableAlt","allSubsetsConflict","hasNonConflictingAltSet","alts","allSubsetsEqual","first","getUniqueAlt","all","getAlts","minValue","INVALID_ALT_NUMBER","map","or","configToAlts","hashFunction","cfg","stateNumber","context","equalsFunction","c1","c2","equals","get","put","alt","getValues","getStateToAltMap","m","values","result","minAlt","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAM;AAACA,EAAAA,GAAD;AAAMC,EAAAA,MAAN;AAAcC,EAAAA,OAAd;AAAuBC,EAAAA;AAAvB,IAAoCC,OAAO,CAAC,YAAD,CAAjD;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAM;AAACE,EAAAA;AAAD,IAAkBF,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM;AAACG,EAAAA;AAAD,IAAiBH,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAM;AAACI,EAAAA;AAAD,IAAcJ,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAM;AAACK,EAAAA;AAAD,IAAoBL,OAAO,CAAC,mBAAD,CAAjC;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,cAAc,GAAG;AACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,GAAG,EAAE,CAtBc;;AAwBnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,EAAE,EAAE,CA1Ce;;AA4CnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,wBAAwB,EAAE,CA9DP;;AAgEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,mCAAmC,EAAE,UAAUC,IAAV,EAAgBC,OAAhB,EAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA,QAAIN,cAAc,CAACO,0BAAf,CAA0CD,OAA1C,CAAJ,EAAwD;AACpD,aAAO,IAAP;AACH,KARyD,CAS1D;;;AACA,QAAID,IAAI,KAAKL,cAAc,CAACC,GAA5B,EAAiC;AAC7B;AACA;AACA;AACA,UAAIK,OAAO,CAACE,kBAAZ,EAAgC;AAC5B;AACA,cAAMC,GAAG,GAAG,IAAIZ,YAAJ,EAAZ;;AACA,aAAI,IAAIa,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACJ,OAAO,CAACK,KAAR,CAAcC,MAA5B,EAAmCF,CAAC,EAApC,EAAwC;AACpC,cAAIG,CAAC,GAAGP,OAAO,CAACK,KAAR,CAAcD,CAAd,CAAR;AACAG,UAAAA,CAAC,GAAG,IAAIf,SAAJ,CAAc;AAACgB,YAAAA,eAAe,EAACf,eAAe,CAACgB;AAAjC,WAAd,EAAsDF,CAAtD,CAAJ;AACAJ,UAAAA,GAAG,CAACO,GAAJ,CAAQH,CAAR;AACH;;AACDP,QAAAA,OAAO,GAAGG,GAAV;AACH,OAb4B,CAc7B;;AACH,KAzByD,CA0B1D;;;AACA,UAAMQ,OAAO,GAAGjB,cAAc,CAACkB,wBAAf,CAAwCZ,OAAxC,CAAhB;AACA,WAAON,cAAc,CAACmB,oBAAf,CAAoCF,OAApC,KAAgD,CAACjB,cAAc,CAACoB,4BAAf,CAA4Cd,OAA5C,CAAxD;AACH,GA1LkB;;AA4LnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIe,EAAAA,wBAAwB,EAAE,UAASf,OAAT,EAAkB;AACxC,SAAI,IAAII,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACJ,OAAO,CAACK,KAAR,CAAcC,MAA5B,EAAmCF,CAAC,EAApC,EAAwC;AACpC,YAAMG,CAAC,GAAGP,OAAO,CAACK,KAAR,CAAcD,CAAd,CAAV;;AACA,UAAIG,CAAC,CAACS,KAAF,YAAmB1B,aAAvB,EAAsC;AAClC,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GA9MkB;;AAgNnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIW,EAAAA,0BAA0B,EAAE,UAASD,OAAT,EAAkB;AAC1C,SAAI,IAAII,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACJ,OAAO,CAACK,KAAR,CAAcC,MAA5B,EAAmCF,CAAC,EAApC,EAAwC;AACpC,YAAMG,CAAC,GAAGP,OAAO,CAACK,KAAR,CAAcD,CAAd,CAAV;;AACA,UAAI,EAAEG,CAAC,CAACS,KAAF,YAAmB1B,aAArB,CAAJ,EAAyC;AACrC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GAlOkB;;AAoOnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI2B,EAAAA,0BAA0B,EAAE,UAASN,OAAT,EAAkB;AAC1C,WAAOjB,cAAc,CAACwB,kBAAf,CAAkCP,OAAlC,CAAP;AACH,GApXkB;;AAsXnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIQ,EAAAA,kBAAkB,EAAE,UAASR,OAAT,EAAkB;AAClC,WAAO,CAAEjB,cAAc,CAAC0B,uBAAf,CAAuCT,OAAvC,CAAT;AACH,GAhYkB;;AAiYnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIS,EAAAA,uBAAuB,EAAE,UAAST,OAAT,EAAkB;AACvC,SAAI,IAAIP,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACO,OAAO,CAACL,MAAtB,EAA6BF,CAAC,EAA9B,EAAkC;AAC9B,YAAMiB,IAAI,GAAGV,OAAO,CAACP,CAAD,CAApB;;AACA,UAAIiB,IAAI,CAACf,MAAL,KAAc,CAAlB,EAAqB;AACjB,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GAjZkB;;AAoZnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIO,EAAAA,oBAAoB,EAAE,UAASF,OAAT,EAAkB;AACpC,SAAI,IAAIP,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACO,OAAO,CAACL,MAAtB,EAA6BF,CAAC,EAA9B,EAAkC;AAC9B,YAAMiB,IAAI,GAAGV,OAAO,CAACP,CAAD,CAApB;;AACA,UAAIiB,IAAI,CAACf,MAAL,GAAY,CAAhB,EAAmB;AACf,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GApakB;;AAuanB;AACJ;AACA;AACA;AACA;AACA;AACA;AACIgB,EAAAA,eAAe,EAAE,UAASX,OAAT,EAAkB;AAC/B,QAAIY,KAAK,GAAG,IAAZ;;AACA,SAAI,IAAInB,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACO,OAAO,CAACL,MAAtB,EAA6BF,CAAC,EAA9B,EAAkC;AAC9B,YAAMiB,IAAI,GAAGV,OAAO,CAACP,CAAD,CAApB;;AACA,UAAImB,KAAK,KAAK,IAAd,EAAoB;AAChBA,QAAAA,KAAK,GAAGF,IAAR;AACH,OAFD,MAEO,IAAIA,IAAI,KAAGE,KAAX,EAAkB;AACrB,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GAzbkB;;AA4bnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,YAAY,EAAE,UAASb,OAAT,EAAkB;AAC5B,UAAMc,GAAG,GAAG/B,cAAc,CAACgC,OAAf,CAAuBf,OAAvB,CAAZ;;AACA,QAAIc,GAAG,CAACnB,MAAJ,KAAa,CAAjB,EAAoB;AAChB,aAAOmB,GAAG,CAACE,QAAJ,EAAP;AACH,KAFD,MAEO;AACH,aAAOtC,GAAG,CAACuC,kBAAX;AACH;AACJ,GA1ckB;;AA4cnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIF,EAAAA,OAAO,EAAE,UAASf,OAAT,EAAkB;AACvB,UAAMc,GAAG,GAAG,IAAIxC,MAAJ,EAAZ;AACA0B,IAAAA,OAAO,CAACkB,GAAR,CAAa,UAASR,IAAT,EAAe;AAAEI,MAAAA,GAAG,CAACK,EAAJ,CAAOT,IAAP;AAAe,KAA7C;AACA,WAAOI,GAAP;AACH,GAxdkB;;AA0dnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIb,EAAAA,wBAAwB,EAAE,UAASZ,OAAT,EAAkB;AACxC,UAAM+B,YAAY,GAAG,IAAI/C,GAAJ,EAArB;;AACA+C,IAAAA,YAAY,CAACC,YAAb,GAA4B,UAASC,GAAT,EAAc;AAAE9C,MAAAA,SAAS,CAAC8C,GAAG,CAACjB,KAAJ,CAAUkB,WAAX,EAAwBD,GAAG,CAACE,OAA5B,CAAT;AAAgD,KAA5F;;AACAJ,IAAAA,YAAY,CAACK,cAAb,GAA8B,UAASC,EAAT,EAAaC,EAAb,EAAiB;AAAE,aAAOD,EAAE,CAACrB,KAAH,CAASkB,WAAT,KAAyBI,EAAE,CAACtB,KAAH,CAASkB,WAAlC,IAAiDG,EAAE,CAACF,OAAH,CAAWI,MAAX,CAAkBD,EAAE,CAACH,OAArB,CAAxD;AAAuF,KAAxI;;AACAnC,IAAAA,OAAO,CAACK,KAAR,CAAcwB,GAAd,CAAkB,UAASI,GAAT,EAAc;AAC5B,UAAIZ,IAAI,GAAGU,YAAY,CAACS,GAAb,CAAiBP,GAAjB,CAAX;;AACA,UAAIZ,IAAI,KAAK,IAAb,EAAmB;AACfA,QAAAA,IAAI,GAAG,IAAIpC,MAAJ,EAAP;AACA8C,QAAAA,YAAY,CAACU,GAAb,CAAiBR,GAAjB,EAAsBZ,IAAtB;AACH;;AACDA,MAAAA,IAAI,CAACX,GAAL,CAASuB,GAAG,CAACS,GAAb;AACH,KAPD;AAQA,WAAOX,YAAY,CAACY,SAAb,EAAP;AACH,GAhfkB;;AAkfnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,gBAAgB,EAAE,UAAS5C,OAAT,EAAkB;AAChC,UAAM6C,CAAC,GAAG,IAAI3D,OAAJ,EAAV;AACAc,IAAAA,OAAO,CAACK,KAAR,CAAcwB,GAAd,CAAkB,UAAStB,CAAT,EAAY;AAC1B,UAAIc,IAAI,GAAGwB,CAAC,CAACL,GAAF,CAAMjC,CAAC,CAACS,KAAR,CAAX;;AACA,UAAIK,IAAI,KAAK,IAAb,EAAmB;AACfA,QAAAA,IAAI,GAAG,IAAIpC,MAAJ,EAAP;AACA4D,QAAAA,CAAC,CAACJ,GAAF,CAAMlC,CAAC,CAACS,KAAR,EAAeK,IAAf;AACH;;AACDA,MAAAA,IAAI,CAACX,GAAL,CAASH,CAAC,CAACmC,GAAX;AACH,KAPD;AAQA,WAAOG,CAAP;AACH,GArgBkB;AAugBnB/B,EAAAA,4BAA4B,EAAE,UAASd,OAAT,EAAkB;AAC5C,UAAM8C,MAAM,GAAGpD,cAAc,CAACkD,gBAAf,CAAgC5C,OAAhC,EAAyC8C,MAAzC,EAAf;;AACA,SAAI,IAAI1C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAAC0C,MAAM,CAACxC,MAArB,EAA4BF,CAAC,EAA7B,EAAiC;AAC7B,UAAI0C,MAAM,CAAC1C,CAAD,CAAN,CAAUE,MAAV,KAAmB,CAAvB,EAA0B;AACtB,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GA/gBkB;AAihBnBY,EAAAA,kBAAkB,EAAE,UAASP,OAAT,EAAkB;AAClC,QAAIoC,MAAM,GAAG,IAAb;;AACA,SAAI,IAAI3C,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACO,OAAO,CAACL,MAAtB,EAA6BF,CAAC,EAA9B,EAAkC;AAC9B,YAAMiB,IAAI,GAAGV,OAAO,CAACP,CAAD,CAApB;AACA,YAAM4C,MAAM,GAAG3B,IAAI,CAACM,QAAL,EAAf;;AACA,UAAGoB,MAAM,KAAG,IAAZ,EAAkB;AACdA,QAAAA,MAAM,GAAGC,MAAT;AACH,OAFD,MAEO,IAAGD,MAAM,KAAGC,MAAZ,EAAoB;AAAE;AACzB,eAAO3D,GAAG,CAACuC,kBAAX;AACH;AACJ;;AACD,WAAOmB,MAAP;AACH;AA7hBkB,CAAvB;AAgiBAE,MAAM,CAACC,OAAP,GAAiBxD,cAAjB","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Map, BitSet, AltDict, hashStuff} = require('./../Utils');\nconst ATN = require('./ATN');\nconst {RuleStopState} = require('./ATNState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {ATNConfig} = require('./ATNConfig');\nconst {SemanticContext} = require('./SemanticContext');\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nconst PredictionMode = {\n    /**\n     * The SLL(*) prediction mode. This prediction mode ignores the current\n     * parser context when making predictions. This is the fastest prediction\n     * mode, and provides correct results for many grammars. This prediction\n     * mode is more powerful than the prediction mode provided by ANTLR 3, but\n     * may result in syntax errors for grammar and input combinations which are\n     * not SLL.\n     *\n     * <p>\n     * When using this prediction mode, the parser will either return a correct\n     * parse tree (i.e. the same parse tree that would be returned with the\n     * {@link //LL} prediction mode), or it will report a syntax error. If a\n     * syntax error is encountered when using the {@link //SLL} prediction mode,\n     * it may be due to either an actual syntax error in the input or indicate\n     * that the particular combination of grammar and input requires the more\n     * powerful {@link //LL} prediction abilities to complete successfully.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    SLL: 0,\n\n    /**\n     * The LL(*) prediction mode. This prediction mode allows the current parser\n     * context to be used for resolving SLL conflicts that occur during\n     * prediction. This is the fastest prediction mode that guarantees correct\n     * parse results for all combinations of grammars with syntactically correct\n     * inputs.\n     *\n     * <p>\n     * When using this prediction mode, the parser will make correct decisions\n     * for all syntactically-correct grammar and input combinations. However, in\n     * cases where the grammar is truly ambiguous this prediction mode might not\n     * report a precise answer for <em>exactly which</em> alternatives are\n     * ambiguous.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL: 1,\n\n    /**\n     *\n     * The LL(*) prediction mode with exact ambiguity detection. In addition to\n     * the correctness guarantees provided by the {@link //LL} prediction mode,\n     * this prediction mode instructs the prediction algorithm to determine the\n     * complete and exact set of ambiguous alternatives for every ambiguous\n     * decision encountered while parsing.\n     *\n     * <p>\n     * This prediction mode may be used for diagnosing ambiguities during\n     * grammar development. Due to the performance overhead of calculating sets\n     * of ambiguous alternatives, this prediction mode should be avoided when\n     * the exact results are not necessary.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL_EXACT_AMBIG_DETECTION: 2,\n\n    /**\n     *\n     * Computes the SLL prediction termination condition.\n     *\n     * <p>\n     * This method computes the SLL prediction termination condition for both of\n     * the following cases.</p>\n     *\n     * <ul>\n     * <li>The usual SLL+LL fallback upon SLL conflict</li>\n     * <li>Pure SLL without LL fallback</li>\n     * </ul>\n     *\n     * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n     *\n     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n     * ensured regardless of how the termination condition is computed by this\n     * method. Due to the substantially higher cost of LL prediction, the\n     * prediction should only fall back to LL when the additional lookahead\n     * cannot lead to a unique SLL prediction.</p>\n     *\n     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n     * conflicting subsets should fall back to full LL, even if the\n     * configuration sets don't resolve to the same alternative (e.g.\n     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n     * configuration, SLL could continue with the hopes that more lookahead will\n     * resolve via one of those non-conflicting configurations.</p>\n     *\n     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n     * stops when it sees only conflicting configuration subsets. In contrast,\n     * full LL keeps going when there is uncertainty.</p>\n     *\n     * <p><strong>HEURISTIC</strong></p>\n     *\n     * <p>As a heuristic, we stop prediction when we see any conflicting subset\n     * unless we see a state that only has one alternative associated with it.\n     * The single-alt-state thing lets prediction continue upon rules like\n     * (otherwise, it would admit defeat too soon):</p>\n     *\n     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n     *\n     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n     * processing this node because alternative to has another way to continue,\n     * via {@code [6|2|[]]}.</p>\n     *\n     * <p>It also let's us continue for this rule:</p>\n     *\n     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n     *\n     * <p>After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not stop\n     * working on this state. In the previous example, we're concerned with\n     * states associated with the conflicting alternatives. Here alt 3 is not\n     * associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, don't declare the state done.</p>\n     *\n     * <p><strong>PURE SLL PARSING</strong></p>\n     *\n     * <p>To handle pure SLL parsing, all we have to do is make sure that we\n     * combine stack contexts for configurations that differ only by semantic\n     * predicate. From there, we can do the usual SLL termination heuristic.</p>\n     *\n     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n     *\n     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n     * states because they need to create the DFA cache that works in all\n     * semantic situations. In contrast, full LL evaluates predicates collected\n     * during start state computation so it can ignore predicates thereafter.\n     * This means that SLL termination detection can totally ignore semantic\n     * predicates.</p>\n     *\n     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n     * semantic predicate contexts so we might see two configurations like the\n     * following.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n     *\n     * <p>Before testing these configurations against others, we have to merge\n     * {@code x} and {@code x'} (without modifying the existing configurations).\n     * For example, we test {@code (x+x')==x''} when looking for conflicts in\n     * the following configurations.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n     *\n     * <p>If the configuration set has predicates (as indicated by\n     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n     * the configurations to strip out all of the predicates so that a standard\n     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n     */\n    hasSLLConflictTerminatingPrediction: function( mode, configs) {\n        // Configs in rule stop states indicate reaching the end of the decision\n        // rule (local context) or end of start rule (full context). If all\n        // configs meet this condition, then none of the configurations is able\n        // to match additional input so we terminate prediction.\n        //\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return true;\n        }\n        // pure SLL mode parsing\n        if (mode === PredictionMode.SLL) {\n            // Don't bother with combining configs from different semantic\n            // contexts if we can fail over to full LL; costs more time\n            // since we'll often fail over anyway.\n            if (configs.hasSemanticContext) {\n                // dup configs, tossing out semantic predicates\n                const dup = new ATNConfigSet();\n                for(let i=0;i<configs.items.length;i++) {\n                    let c = configs.items[i];\n                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n            // now we have combined contexts for configs with dissimilar preds\n        }\n        // pure SLL or combined SLL+LL mode parsing\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n\n    /**\n     * Checks if any configuration in {@code configs} is in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if any configuration in {@code configs} is in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    hasConfigInRuleStopState: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (c.state instanceof RuleStopState) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Checks if all configurations in {@code configs} are in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if all configurations in {@code configs} are in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    allConfigsInRuleStopStates: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (!(c.state instanceof RuleStopState)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     *\n     * Full LL prediction termination.\n     *\n     * <p>Can we stop looking ahead during ATN simulation or is there some\n     * uncertainty as to which alternative we will ultimately pick, after\n     * consuming more input? Even if there are partial conflicts, we might know\n     * that everything is going to resolve to the same minimum alternative. That\n     * means we can stop since no more lookahead will change that fact. On the\n     * other hand, there might be multiple conflicts that resolve to different\n     * minimums. That means we need more look ahead to decide which of those\n     * alternatives we should predict.</p>\n     *\n     * <p>The basic idea is to split the set of configurations {@code C}, into\n     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n     * non-conflicting configurations. Two configurations conflict if they have\n     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n     *\n     * <p>Reduce these configuration subsets to the set of possible alternatives.\n     * You can compute the alternative subsets in one pass as follows:</p>\n     *\n     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n     * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n     *\n     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     *\n     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n     *\n     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n     * {@code s} and {@code ctx}.</p>\n     *\n     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n     * the union of these alternative subsets is a singleton, then no amount of\n     * more lookahead will help us. We will always pick that alternative. If,\n     * however, there is more than one alternative, then we are uncertain which\n     * alternative to predict and must continue looking for resolution. We may\n     * or may not discover an ambiguity in the future, even if there are no\n     * conflicting subsets this round.</p>\n     *\n     * <p>The biggest sin is to terminate early because it means we've made a\n     * decision but were uncertain as to the eventual outcome. We haven't used\n     * enough lookahead. On the other hand, announcing a conflict too late is no\n     * big deal; you will still have the conflict. It's just inefficient. It\n     * might even look until the end of file.</p>\n     *\n     * <p>No special consideration for semantic predicates is required because\n     * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n     * no configuration contains a semantic context during the termination\n     * check.</p>\n     *\n     * <p><strong>CONFLICTING CONFIGS</strong></p>\n     *\n     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n     * when {@code i!=j} but {@code x=x'}. Because we merge all\n     * {@code (s, i, _)} configurations together, that means that there are at\n     * most {@code n} configurations associated with state {@code s} for\n     * {@code n} possible alternatives in the decision. The merged stacks\n     * complicate the comparison of configuration contexts {@code x} and\n     * {@code x'}. Sam checks to see if one is a subset of the other by calling\n     * merge and checking to see if the merged result is either {@code x} or\n     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n     * is the superset, then {@code i} is the only possible prediction since the\n     * others resolve to {@code min(i)} as well. However, if {@code x} is\n     * associated with {@code j>i} then at least one stack configuration for\n     * {@code j} is not in conflict with alternative {@code i}. The algorithm\n     * should keep going, looking for more lookahead due to the uncertainty.</p>\n     *\n     * <p>For simplicity, I'm doing a equality check between {@code x} and\n     * {@code x'} that lets the algorithm continue to consume lookahead longer\n     * than necessary. The reason I like the equality is of course the\n     * simplicity but also because that is the test you need to detect the\n     * alternatives that are actually in conflict.</p>\n     *\n     * <p><strong>CONTINUE/STOP RULE</strong></p>\n     *\n     * <p>Continue if union of resolved alternative sets from non-conflicting and\n     * conflicting alternative subsets has more than one alternative. We are\n     * uncertain about which alternative to predict.</p>\n     *\n     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n     * alternatives are still in the running for the amount of input we've\n     * consumed at this point. The conflicting sets let us to strip away\n     * configurations that won't lead to more states because we resolve\n     * conflicts to the configuration with a minimum alternate for the\n     * conflicting set.</p>\n     *\n     * <p><strong>CASES</strong></p>\n     *\n     * <ul>\n     *\n     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n     *\n     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1,3}} =&gt; continue\n     * </li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1}} =&gt; stop and predict 1</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n     * ambiguity {@code {1,2}}</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n     *\n     * </ul>\n     *\n     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n     *\n     * <p>If all states report the same conflicting set of alternatives, then we\n     * know we have the exact ambiguity set.</p>\n     *\n     * <p><code>|A_<em>i</em>|&gt;1</code> and\n     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n     *\n     * <p>In other words, we continue examining lookahead until all {@code A_i}\n     * have more than one alternative and all {@code A_i} are the same. If\n     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n     * because the resolved set is {@code {1}}. To determine what the real\n     * ambiguity is, we have to know whether the ambiguity is between one and\n     * two or one and three so we keep going. We can only stop prediction when\n     * we need exact ambiguity detection when the sets look like\n     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n     */\n    resolvesToJustOneViableAlt: function(altsets) {\n        return PredictionMode.getSingleViableAlt(altsets);\n    },\n\n    /**\n     * Determines if every alternative subset in {@code altsets} contains more\n     * than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every {@link BitSet} in {@code altsets} has\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    allSubsetsConflict: function(altsets) {\n        return ! PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * exactly one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n     */\n    hasNonConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * more than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    hasConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length>1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if every alternative subset in {@code altsets} is equivalent.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every member of {@code altsets} is equal to the\n     * others, otherwise {@code false}\n     */\n    allSubsetsEqual: function(altsets) {\n        let first = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (first === null) {\n                first = alts;\n            } else if (alts!==first) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n\n    /**\n     * Returns the unique alternative predicted by all alternative subsets in\n     * {@code altsets}. If no such alternative exists, this method returns\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * @param altsets a collection of alternative subsets\n     */\n    getUniqueAlt: function(altsets) {\n        const all = PredictionMode.getAlts(altsets);\n        if (all.length===1) {\n            return all.minValue();\n        } else {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    },\n\n    /**\n     * Gets the complete set of represented alternatives for a collection of\n     * alternative subsets. This method returns the union of each {@link BitSet}\n     * in {@code altsets}.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return the set of represented alternatives in {@code altsets}\n     */\n    getAlts: function(altsets) {\n        const all = new BitSet();\n        altsets.map( function(alts) { all.or(alts); });\n        return all;\n    },\n\n    /**\n     * This function gets the conflicting alt subsets from a configuration set.\n     * For each configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     */\n    getConflictingAltSubsets: function(configs) {\n        const configToAlts = new Map();\n        configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};\n        configs.items.map(function(cfg) {\n            let alts = configToAlts.get(cfg);\n            if (alts === null) {\n                alts = new BitSet();\n                configToAlts.put(cfg, alts);\n            }\n            alts.add(cfg.alt);\n        });\n        return configToAlts.getValues();\n    },\n\n    /**\n     * Get a map from state to alt subset from a configuration set. For each\n     * configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n     * </pre>\n     */\n    getStateToAltMap: function(configs) {\n        const m = new AltDict();\n        configs.items.map(function(c) {\n            let alts = m.get(c.state);\n            if (alts === null) {\n                alts = new BitSet();\n                m.put(c.state, alts);\n            }\n            alts.add(c.alt);\n        });\n        return m;\n    },\n\n    hasStateAssociatedWithOneAlt: function(configs) {\n        const values = PredictionMode.getStateToAltMap(configs).values();\n        for(let i=0;i<values.length;i++) {\n            if (values[i].length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getSingleViableAlt: function(altsets) {\n        let result = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            const minAlt = alts.minValue();\n            if(result===null) {\n                result = minAlt;\n            } else if(result!==minAlt) { // more than 1 viable alt\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = PredictionMode;\n"]},"metadata":{},"sourceType":"script"}