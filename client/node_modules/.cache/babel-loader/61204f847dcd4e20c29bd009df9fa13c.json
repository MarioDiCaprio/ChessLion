{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./Token');\n\nconst Recognizer = require('./Recognizer');\n\nconst CommonTokenFactory = require('./CommonTokenFactory');\n\nconst {\n  RecognitionException\n} = require('./error/Errors');\n\nconst {\n  LexerNoViableAltException\n} = require('./error/Errors');\n\nclass TokenSource {}\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\n\n\nclass Lexer extends Recognizer {\n  constructor(input) {\n    super();\n    this._input = input;\n    this._factory = CommonTokenFactory.DEFAULT;\n    this._tokenFactorySourcePair = [this, input];\n    this._interp = null; // child classes must populate this\n\n    /**\n     * The goal of all lexer rules/methods is to create a token object.\n     * this is an instance variable as multiple rules may collaborate to\n     * create a single token. nextToken will return this object after\n     * matching lexer rule(s). If you subclass to allow multiple token\n     * emissions, then set this to the last token to be matched or\n     * something nonnull so that the auto token emit mechanism will not\n     * emit another token.\n     */\n\n    this._token = null;\n    /**\n     * What character index in the stream did the current token start at?\n     * Needed, for example, to get the text for current token. Set at\n     * the start of nextToken.\n     */\n\n    this._tokenStartCharIndex = -1; // The line on which the first character of the token resides///\n\n    this._tokenStartLine = -1; // The character position of first character within the line///\n\n    this._tokenStartColumn = -1; // Once we see EOF on char stream, next token will be EOF.\n    // If you have DONE : EOF ; then you see DONE EOF.\n\n    this._hitEOF = false; // The channel number for the current token///\n\n    this._channel = Token.DEFAULT_CHANNEL; // The token type for the current token///\n\n    this._type = Token.INVALID_TYPE;\n    this._modeStack = [];\n    this._mode = Lexer.DEFAULT_MODE;\n    /**\n     * You can set the text for the current token to override what is in\n     * the input char buffer. Use setText() or can set this instance var.\n     */\n\n    this._text = null;\n  }\n\n  reset() {\n    // wack Lexer state variables\n    if (this._input !== null) {\n      this._input.seek(0); // rewind the input\n\n    }\n\n    this._token = null;\n    this._type = Token.INVALID_TYPE;\n    this._channel = Token.DEFAULT_CHANNEL;\n    this._tokenStartCharIndex = -1;\n    this._tokenStartColumn = -1;\n    this._tokenStartLine = -1;\n    this._text = null;\n    this._hitEOF = false;\n    this._mode = Lexer.DEFAULT_MODE;\n    this._modeStack = [];\n\n    this._interp.reset();\n  } // Return a token from this source; i.e., match a token on the char stream.\n\n\n  nextToken() {\n    if (this._input === null) {\n      throw \"nextToken requires a non-null input stream.\";\n    }\n    /**\n     * Mark start location in char stream so unbuffered streams are\n     * guaranteed at least have text of current token\n     */\n\n\n    const tokenStartMarker = this._input.mark();\n\n    try {\n      while (true) {\n        if (this._hitEOF) {\n          this.emitEOF();\n          return this._token;\n        }\n\n        this._token = null;\n        this._channel = Token.DEFAULT_CHANNEL;\n        this._tokenStartCharIndex = this._input.index;\n        this._tokenStartColumn = this._interp.column;\n        this._tokenStartLine = this._interp.line;\n        this._text = null;\n        let continueOuter = false;\n\n        while (true) {\n          this._type = Token.INVALID_TYPE;\n          let ttype = Lexer.SKIP;\n\n          try {\n            ttype = this._interp.match(this._input, this._mode);\n          } catch (e) {\n            if (e instanceof RecognitionException) {\n              this.notifyListeners(e); // report error\n\n              this.recover(e);\n            } else {\n              console.log(e.stack);\n              throw e;\n            }\n          }\n\n          if (this._input.LA(1) === Token.EOF) {\n            this._hitEOF = true;\n          }\n\n          if (this._type === Token.INVALID_TYPE) {\n            this._type = ttype;\n          }\n\n          if (this._type === Lexer.SKIP) {\n            continueOuter = true;\n            break;\n          }\n\n          if (this._type !== Lexer.MORE) {\n            break;\n          }\n        }\n\n        if (continueOuter) {\n          continue;\n        }\n\n        if (this._token === null) {\n          this.emit();\n        }\n\n        return this._token;\n      }\n    } finally {\n      // make sure we release marker after match or\n      // unbuffered char stream will keep buffering\n      this._input.release(tokenStartMarker);\n    }\n  }\n  /**\n   * Instruct the lexer to skip creating a token for current lexer rule\n   * and look for another token. nextToken() knows to keep looking when\n   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n   * if token==null at end of any token rule, it creates one for you\n   * and emits it.\n   */\n\n\n  skip() {\n    this._type = Lexer.SKIP;\n  }\n\n  more() {\n    this._type = Lexer.MORE;\n  }\n\n  mode(m) {\n    this._mode = m;\n  }\n\n  pushMode(m) {\n    if (this._interp.debug) {\n      console.log(\"pushMode \" + m);\n    }\n\n    this._modeStack.push(this._mode);\n\n    this.mode(m);\n  }\n\n  popMode() {\n    if (this._modeStack.length === 0) {\n      throw \"Empty Stack\";\n    }\n\n    if (this._interp.debug) {\n      console.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n    }\n\n    this.mode(this._modeStack.pop());\n    return this._mode;\n  }\n  /**\n   * By default does not support multiple emits per nextToken invocation\n   * for efficiency reasons. Subclass and override this method, nextToken,\n   * and getToken (to push tokens into a list and pull from that list\n   * rather than a single variable as this implementation does).\n   */\n\n\n  emitToken(token) {\n    this._token = token;\n  }\n  /**\n   * The standard method called to automatically emit a token at the\n   * outermost lexical rule. The token object should point into the\n   * char buffer start..stop. If there is a text override in 'text',\n   * use that to set the token's text. Override this method to emit\n   * custom Token objects or provide a new factory.\n   */\n\n\n  emit() {\n    const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);\n\n    this.emitToken(t);\n    return t;\n  }\n\n  emitEOF() {\n    const cpos = this.column;\n    const lpos = this.line;\n\n    const eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF, null, Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);\n\n    this.emitToken(eof);\n    return eof;\n  } // What is the index of the current character of lookahead?///\n\n\n  getCharIndex() {\n    return this._input.index;\n  }\n  /**\n   * Return a list of all Token objects in input char stream.\n   * Forces load of all tokens. Does not include EOF token.\n   */\n\n\n  getAllTokens() {\n    const tokens = [];\n    let t = this.nextToken();\n\n    while (t.type !== Token.EOF) {\n      tokens.push(t);\n      t = this.nextToken();\n    }\n\n    return tokens;\n  }\n\n  notifyListeners(e) {\n    const start = this._tokenStartCharIndex;\n    const stop = this._input.index;\n\n    const text = this._input.getText(start, stop);\n\n    const msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n    const listener = this.getErrorListenerDispatch();\n    listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);\n  }\n\n  getErrorDisplay(s) {\n    const d = [];\n\n    for (let i = 0; i < s.length; i++) {\n      d.push(s[i]);\n    }\n\n    return d.join('');\n  }\n\n  getErrorDisplayForChar(c) {\n    if (c.charCodeAt(0) === Token.EOF) {\n      return \"<EOF>\";\n    } else if (c === '\\n') {\n      return \"\\\\n\";\n    } else if (c === '\\t') {\n      return \"\\\\t\";\n    } else if (c === '\\r') {\n      return \"\\\\r\";\n    } else {\n      return c;\n    }\n  }\n\n  getCharErrorDisplay(c) {\n    return \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n  }\n  /**\n   * Lexers can normally match any char in it's vocabulary after matching\n   * a token, so do the easy thing and just kill a character and hope\n   * it all works out. You can instead use the rule invocation stack\n   * to do sophisticated error recovery if you are in a fragment rule.\n   */\n\n\n  recover(re) {\n    if (this._input.LA(1) !== Token.EOF) {\n      if (re instanceof LexerNoViableAltException) {\n        // skip a char and try again\n        this._interp.consume(this._input);\n      } else {\n        // TODO: Do we lose character or line position information?\n        this._input.consume();\n      }\n    }\n  }\n\n  get inputStream() {\n    return this._input;\n  }\n\n  set inputStream(input) {\n    this._input = null;\n    this._tokenFactorySourcePair = [this, this._input];\n    this.reset();\n    this._input = input;\n    this._tokenFactorySourcePair = [this, this._input];\n  }\n\n  get sourceName() {\n    return this._input.sourceName;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n  }\n\n  get line() {\n    return this._interp.line;\n  }\n\n  set line(line) {\n    this._interp.line = line;\n  }\n\n  get column() {\n    return this._interp.column;\n  }\n\n  set column(column) {\n    this._interp.column = column;\n  }\n\n  get text() {\n    if (this._text !== null) {\n      return this._text;\n    } else {\n      return this._interp.getText(this._input);\n    }\n  }\n\n  set text(text) {\n    this._text = text;\n  }\n\n}\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF; // Set the char stream and reset the lexer\n\nmodule.exports = Lexer;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/Lexer.js"],"names":["Token","require","Recognizer","CommonTokenFactory","RecognitionException","LexerNoViableAltException","TokenSource","Lexer","constructor","input","_input","_factory","DEFAULT","_tokenFactorySourcePair","_interp","_token","_tokenStartCharIndex","_tokenStartLine","_tokenStartColumn","_hitEOF","_channel","DEFAULT_CHANNEL","_type","INVALID_TYPE","_modeStack","_mode","DEFAULT_MODE","_text","reset","seek","nextToken","tokenStartMarker","mark","emitEOF","index","column","line","continueOuter","ttype","SKIP","match","e","notifyListeners","recover","console","log","stack","LA","EOF","MORE","emit","release","skip","more","mode","m","pushMode","debug","push","popMode","length","slice","pop","emitToken","token","t","create","getCharIndex","cpos","lpos","eof","getAllTokens","tokens","type","start","stop","text","getText","msg","getErrorDisplay","listener","getErrorListenerDispatch","syntaxError","s","d","i","join","getErrorDisplayForChar","c","charCodeAt","getCharErrorDisplay","re","consume","inputStream","sourceName","DEFAULT_TOKEN_CHANNEL","HIDDEN","HIDDEN_CHANNEL","MIN_CHAR_VALUE","MAX_CHAR_VALUE","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAM;AAACA,EAAAA;AAAD,IAAUC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,sBAAD,CAAlC;;AACA,MAAM;AAACG,EAAAA;AAAD,IAAyBH,OAAO,CAAC,gBAAD,CAAtC;;AACA,MAAM;AAACI,EAAAA;AAAD,IAA8BJ,OAAO,CAAC,gBAAD,CAA3C;;AAEA,MAAMK,WAAN,CAAkB;AAElB;AACA;AACA;AACA;AACA;;;AACA,MAAMC,KAAN,SAAoBL,UAApB,CAA+B;AAC9BM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AAClB;AACA,SAAKC,MAAL,GAAcD,KAAd;AACA,SAAKE,QAAL,GAAgBR,kBAAkB,CAACS,OAAnC;AACA,SAAKC,uBAAL,GAA+B,CAAE,IAAF,EAAQJ,KAAR,CAA/B;AAEA,SAAKK,OAAL,GAAe,IAAf,CANkB,CAMG;;AAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,MAAL,GAAc,IAAd;AAEA;AACF;AACA;AACA;AACA;;AACE,SAAKC,oBAAL,GAA4B,CAAC,CAA7B,CAxBkB,CA0BlB;;AACA,SAAKC,eAAL,GAAuB,CAAC,CAAxB,CA3BkB,CA6BlB;;AACA,SAAKC,iBAAL,GAAyB,CAAC,CAA1B,CA9BkB,CAgClB;AACA;;AACA,SAAKC,OAAL,GAAe,KAAf,CAlCkB,CAoClB;;AACA,SAAKC,QAAL,GAAgBpB,KAAK,CAACqB,eAAtB,CArCkB,CAuClB;;AACA,SAAKC,KAAL,GAAatB,KAAK,CAACuB,YAAnB;AAEA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,KAAL,GAAalB,KAAK,CAACmB,YAAnB;AAEA;AACF;AACA;AACA;;AACE,SAAKC,KAAL,GAAa,IAAb;AACA;;AAEDC,EAAAA,KAAK,GAAG;AACP;AACA,QAAI,KAAKlB,MAAL,KAAgB,IAApB,EAA0B;AACzB,WAAKA,MAAL,CAAYmB,IAAZ,CAAiB,CAAjB,EADyB,CACJ;;AACrB;;AACD,SAAKd,MAAL,GAAc,IAAd;AACA,SAAKO,KAAL,GAAatB,KAAK,CAACuB,YAAnB;AACA,SAAKH,QAAL,GAAgBpB,KAAK,CAACqB,eAAtB;AACA,SAAKL,oBAAL,GAA4B,CAAC,CAA7B;AACA,SAAKE,iBAAL,GAAyB,CAAC,CAA1B;AACA,SAAKD,eAAL,GAAuB,CAAC,CAAxB;AACA,SAAKU,KAAL,GAAa,IAAb;AAEA,SAAKR,OAAL,GAAe,KAAf;AACA,SAAKM,KAAL,GAAalB,KAAK,CAACmB,YAAnB;AACA,SAAKF,UAAL,GAAkB,EAAlB;;AAEA,SAAKV,OAAL,CAAac,KAAb;AACA,GAvE6B,CAyE/B;;;AACCE,EAAAA,SAAS,GAAG;AACX,QAAI,KAAKpB,MAAL,KAAgB,IAApB,EAA0B;AACzB,YAAM,6CAAN;AACA;AAED;AACF;AACA;AACA;;;AACE,UAAMqB,gBAAgB,GAAG,KAAKrB,MAAL,CAAYsB,IAAZ,EAAzB;;AACA,QAAI;AACH,aAAO,IAAP,EAAa;AACZ,YAAI,KAAKb,OAAT,EAAkB;AACjB,eAAKc,OAAL;AACA,iBAAO,KAAKlB,MAAZ;AACA;;AACD,aAAKA,MAAL,GAAc,IAAd;AACA,aAAKK,QAAL,GAAgBpB,KAAK,CAACqB,eAAtB;AACA,aAAKL,oBAAL,GAA4B,KAAKN,MAAL,CAAYwB,KAAxC;AACA,aAAKhB,iBAAL,GAAyB,KAAKJ,OAAL,CAAaqB,MAAtC;AACA,aAAKlB,eAAL,GAAuB,KAAKH,OAAL,CAAasB,IAApC;AACA,aAAKT,KAAL,GAAa,IAAb;AACA,YAAIU,aAAa,GAAG,KAApB;;AACA,eAAO,IAAP,EAAa;AACZ,eAAKf,KAAL,GAAatB,KAAK,CAACuB,YAAnB;AACA,cAAIe,KAAK,GAAG/B,KAAK,CAACgC,IAAlB;;AACA,cAAI;AACHD,YAAAA,KAAK,GAAG,KAAKxB,OAAL,CAAa0B,KAAb,CAAmB,KAAK9B,MAAxB,EAAgC,KAAKe,KAArC,CAAR;AACA,WAFD,CAEE,OAAOgB,CAAP,EAAU;AACX,gBAAGA,CAAC,YAAYrC,oBAAhB,EAAsC;AACrC,mBAAKsC,eAAL,CAAqBD,CAArB,EADqC,CACZ;;AACzB,mBAAKE,OAAL,CAAaF,CAAb;AACA,aAHD,MAGO;AACNG,cAAAA,OAAO,CAACC,GAAR,CAAYJ,CAAC,CAACK,KAAd;AACA,oBAAML,CAAN;AACA;AACD;;AACD,cAAI,KAAK/B,MAAL,CAAYqC,EAAZ,CAAe,CAAf,MAAsB/C,KAAK,CAACgD,GAAhC,EAAqC;AACpC,iBAAK7B,OAAL,GAAe,IAAf;AACA;;AACD,cAAI,KAAKG,KAAL,KAAetB,KAAK,CAACuB,YAAzB,EAAuC;AACtC,iBAAKD,KAAL,GAAagB,KAAb;AACA;;AACD,cAAI,KAAKhB,KAAL,KAAef,KAAK,CAACgC,IAAzB,EAA+B;AAC9BF,YAAAA,aAAa,GAAG,IAAhB;AACA;AACA;;AACD,cAAI,KAAKf,KAAL,KAAef,KAAK,CAAC0C,IAAzB,EAA+B;AAC9B;AACA;AACD;;AACD,YAAIZ,aAAJ,EAAmB;AAClB;AACA;;AACD,YAAI,KAAKtB,MAAL,KAAgB,IAApB,EAA0B;AACzB,eAAKmC,IAAL;AACA;;AACD,eAAO,KAAKnC,MAAZ;AACA;AACD,KAjDD,SAiDU;AACT;AACA;AACA,WAAKL,MAAL,CAAYyC,OAAZ,CAAoBpB,gBAApB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCqB,EAAAA,IAAI,GAAG;AACN,SAAK9B,KAAL,GAAaf,KAAK,CAACgC,IAAnB;AACA;;AAEDc,EAAAA,IAAI,GAAG;AACN,SAAK/B,KAAL,GAAaf,KAAK,CAAC0C,IAAnB;AACA;;AAEDK,EAAAA,IAAI,CAACC,CAAD,EAAI;AACP,SAAK9B,KAAL,GAAa8B,CAAb;AACA;;AAEDC,EAAAA,QAAQ,CAACD,CAAD,EAAI;AACX,QAAI,KAAKzC,OAAL,CAAa2C,KAAjB,EAAwB;AACvBb,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAcU,CAA1B;AACA;;AACD,SAAK/B,UAAL,CAAgBkC,IAAhB,CAAqB,KAAKjC,KAA1B;;AACA,SAAK6B,IAAL,CAAUC,CAAV;AACA;;AAEDI,EAAAA,OAAO,GAAG;AACT,QAAI,KAAKnC,UAAL,CAAgBoC,MAAhB,KAA2B,CAA/B,EAAkC;AACjC,YAAM,aAAN;AACA;;AACD,QAAI,KAAK9C,OAAL,CAAa2C,KAAjB,EAAwB;AACvBb,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqB,KAAKrB,UAAL,CAAgBqC,KAAhB,CAAsB,CAAtB,EAAyB,CAAC,CAA1B,CAAjC;AACA;;AACD,SAAKP,IAAL,CAAU,KAAK9B,UAAL,CAAgBsC,GAAhB,EAAV;AACA,WAAO,KAAKrC,KAAZ;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCsC,EAAAA,SAAS,CAACC,KAAD,EAAQ;AAChB,SAAKjD,MAAL,GAAciD,KAAd;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCd,EAAAA,IAAI,GAAG;AACN,UAAMe,CAAC,GAAG,KAAKtD,QAAL,CAAcuD,MAAd,CAAqB,KAAKrD,uBAA1B,EAAmD,KAAKS,KAAxD,EACR,KAAKK,KADG,EACI,KAAKP,QADT,EACmB,KAAKJ,oBADxB,EAC8C,KACnDmD,YADmD,KAClC,CAFZ,EAEe,KAAKlD,eAFpB,EAGR,KAAKC,iBAHG,CAAV;;AAIA,SAAK6C,SAAL,CAAeE,CAAf;AACA,WAAOA,CAAP;AACA;;AAEDhC,EAAAA,OAAO,GAAG;AACT,UAAMmC,IAAI,GAAG,KAAKjC,MAAlB;AACA,UAAMkC,IAAI,GAAG,KAAKjC,IAAlB;;AACA,UAAMkC,GAAG,GAAG,KAAK3D,QAAL,CAAcuD,MAAd,CAAqB,KAAKrD,uBAA1B,EAAmDb,KAAK,CAACgD,GAAzD,EACV,IADU,EACJhD,KAAK,CAACqB,eADF,EACmB,KAAKX,MAAL,CAAYwB,KAD/B,EAEV,KAAKxB,MAAL,CAAYwB,KAAZ,GAAoB,CAFV,EAEamC,IAFb,EAEmBD,IAFnB,CAAZ;;AAGA,SAAKL,SAAL,CAAeO,GAAf;AACA,WAAOA,GAAP;AACA,GApN6B,CAsN/B;;;AACCH,EAAAA,YAAY,GAAG;AACd,WAAO,KAAKzD,MAAL,CAAYwB,KAAnB;AACA;AAED;AACD;AACA;AACA;;;AACCqC,EAAAA,YAAY,GAAG;AACd,UAAMC,MAAM,GAAG,EAAf;AACA,QAAIP,CAAC,GAAG,KAAKnC,SAAL,EAAR;;AACA,WAAOmC,CAAC,CAACQ,IAAF,KAAWzE,KAAK,CAACgD,GAAxB,EAA6B;AAC5BwB,MAAAA,MAAM,CAACd,IAAP,CAAYO,CAAZ;AACAA,MAAAA,CAAC,GAAG,KAAKnC,SAAL,EAAJ;AACA;;AACD,WAAO0C,MAAP;AACA;;AAED9B,EAAAA,eAAe,CAACD,CAAD,EAAI;AAClB,UAAMiC,KAAK,GAAG,KAAK1D,oBAAnB;AACA,UAAM2D,IAAI,GAAG,KAAKjE,MAAL,CAAYwB,KAAzB;;AACA,UAAM0C,IAAI,GAAG,KAAKlE,MAAL,CAAYmE,OAAZ,CAAoBH,KAApB,EAA2BC,IAA3B,CAAb;;AACA,UAAMG,GAAG,GAAG,kCAAkC,KAAKC,eAAL,CAAqBH,IAArB,CAAlC,GAA+D,GAA3E;AACA,UAAMI,QAAQ,GAAG,KAAKC,wBAAL,EAAjB;AACAD,IAAAA,QAAQ,CAACE,WAAT,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,KAAKjE,eAAtC,EACE,KAAKC,iBADP,EAC0B4D,GAD1B,EAC+BrC,CAD/B;AAEA;;AAEDsC,EAAAA,eAAe,CAACI,CAAD,EAAI;AAClB,UAAMC,CAAC,GAAG,EAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAAC,CAACvB,MAAtB,EAA8ByB,CAAC,EAA/B,EAAmC;AAClCD,MAAAA,CAAC,CAAC1B,IAAF,CAAOyB,CAAC,CAACE,CAAD,CAAR;AACA;;AACD,WAAOD,CAAC,CAACE,IAAF,CAAO,EAAP,CAAP;AACA;;AAEDC,EAAAA,sBAAsB,CAACC,CAAD,EAAI;AACzB,QAAIA,CAAC,CAACC,UAAF,CAAa,CAAb,MAAoBzF,KAAK,CAACgD,GAA9B,EAAmC;AAClC,aAAO,OAAP;AACA,KAFD,MAEO,IAAIwC,CAAC,KAAK,IAAV,EAAgB;AACtB,aAAO,KAAP;AACA,KAFM,MAEA,IAAIA,CAAC,KAAK,IAAV,EAAgB;AACtB,aAAO,KAAP;AACA,KAFM,MAEA,IAAIA,CAAC,KAAK,IAAV,EAAgB;AACtB,aAAO,KAAP;AACA,KAFM,MAEA;AACN,aAAOA,CAAP;AACA;AACD;;AAEDE,EAAAA,mBAAmB,CAACF,CAAD,EAAI;AACtB,WAAO,MAAM,KAAKD,sBAAL,CAA4BC,CAA5B,CAAN,GAAuC,GAA9C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC7C,EAAAA,OAAO,CAACgD,EAAD,EAAK;AACX,QAAI,KAAKjF,MAAL,CAAYqC,EAAZ,CAAe,CAAf,MAAsB/C,KAAK,CAACgD,GAAhC,EAAqC;AACpC,UAAI2C,EAAE,YAAYtF,yBAAlB,EAA6C;AAC5C;AACA,aAAKS,OAAL,CAAa8E,OAAb,CAAqB,KAAKlF,MAA1B;AACA,OAHD,MAGO;AACN;AACA,aAAKA,MAAL,CAAYkF,OAAZ;AACA;AACD;AACD;;AAEc,MAAXC,WAAW,GAAE;AAChB,WAAO,KAAKnF,MAAZ;AACA;;AAEc,MAAXmF,WAAW,CAACpF,KAAD,EAAQ;AACtB,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKG,uBAAL,GAA+B,CAAE,IAAF,EAAQ,KAAKH,MAAb,CAA/B;AACA,SAAKkB,KAAL;AACA,SAAKlB,MAAL,GAAcD,KAAd;AACA,SAAKI,uBAAL,GAA+B,CAAE,IAAF,EAAQ,KAAKH,MAAb,CAA/B;AACA;;AAEa,MAAVoF,UAAU,GAAE;AACf,WAAO,KAAKpF,MAAL,CAAYoF,UAAnB;AACA;;AAEO,MAAJrB,IAAI,GAAE;AACT,WAAO,KAAKnD,KAAZ;AACA;;AAEO,MAAJmD,IAAI,CAACA,IAAD,EAAO;AACd,SAAKnD,KAAL,GAAamD,IAAb;AACA;;AAEO,MAAJrC,IAAI,GAAE;AACT,WAAO,KAAKtB,OAAL,CAAasB,IAApB;AACA;;AAEO,MAAJA,IAAI,CAACA,IAAD,EAAO;AACd,SAAKtB,OAAL,CAAasB,IAAb,GAAoBA,IAApB;AACA;;AAES,MAAND,MAAM,GAAE;AACX,WAAO,KAAKrB,OAAL,CAAaqB,MAApB;AACA;;AAES,MAANA,MAAM,CAACA,MAAD,EAAS;AAClB,SAAKrB,OAAL,CAAaqB,MAAb,GAAsBA,MAAtB;AACA;;AAEO,MAAJyC,IAAI,GAAE;AACT,QAAI,KAAKjD,KAAL,KAAe,IAAnB,EAAyB;AACxB,aAAO,KAAKA,KAAZ;AACA,KAFD,MAEO;AACN,aAAO,KAAKb,OAAL,CAAa+D,OAAb,CAAqB,KAAKnE,MAA1B,CAAP;AACA;AACD;;AAEO,MAAJkE,IAAI,CAACA,IAAD,EAAO;AACd,SAAKjD,KAAL,GAAaiD,IAAb;AACA;;AAjV6B;;AAuV/BrE,KAAK,CAACmB,YAAN,GAAqB,CAArB;AACAnB,KAAK,CAAC0C,IAAN,GAAa,CAAC,CAAd;AACA1C,KAAK,CAACgC,IAAN,GAAa,CAAC,CAAd;AAEAhC,KAAK,CAACwF,qBAAN,GAA8B/F,KAAK,CAACqB,eAApC;AACAd,KAAK,CAACyF,MAAN,GAAehG,KAAK,CAACiG,cAArB;AACA1F,KAAK,CAAC2F,cAAN,GAAuB,MAAvB;AACA3F,KAAK,CAAC4F,cAAN,GAAuB,QAAvB,C,CAEA;;AAGAC,MAAM,CAACC,OAAP,GAAiB9F,KAAjB","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Recognizer = require('./Recognizer');\nconst CommonTokenFactory = require('./CommonTokenFactory');\nconst {RecognitionException} = require('./error/Errors');\nconst {LexerNoViableAltException} = require('./error/Errors');\n\nclass TokenSource {}\n\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\nclass Lexer extends Recognizer {\n\tconstructor(input) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._factory = CommonTokenFactory.DEFAULT;\n\t\tthis._tokenFactorySourcePair = [ this, input ];\n\n\t\tthis._interp = null; // child classes must populate this\n\n\t\t/**\n\t\t * The goal of all lexer rules/methods is to create a token object.\n\t\t * this is an instance variable as multiple rules may collaborate to\n\t\t * create a single token. nextToken will return this object after\n\t\t * matching lexer rule(s). If you subclass to allow multiple token\n\t\t * emissions, then set this to the last token to be matched or\n\t\t * something nonnull so that the auto token emit mechanism will not\n\t\t * emit another token.\n\t\t */\n\t\tthis._token = null;\n\n\t\t/**\n\t\t * What character index in the stream did the current token start at?\n\t\t * Needed, for example, to get the text for current token. Set at\n\t\t * the start of nextToken.\n\t\t */\n\t\tthis._tokenStartCharIndex = -1;\n\n\t\t// The line on which the first character of the token resides///\n\t\tthis._tokenStartLine = -1;\n\n\t\t// The character position of first character within the line///\n\t\tthis._tokenStartColumn = -1;\n\n\t\t// Once we see EOF on char stream, next token will be EOF.\n\t\t// If you have DONE : EOF ; then you see DONE EOF.\n\t\tthis._hitEOF = false;\n\n\t\t// The channel number for the current token///\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t\t// The token type for the current token///\n\t\tthis._type = Token.INVALID_TYPE;\n\n\t\tthis._modeStack = [];\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t\t/**\n\t\t * You can set the text for the current token to override what is in\n\t\t * the input char buffer. Use setText() or can set this instance var.\n\t\t */\n\t\tthis._text = null;\n\t}\n\n\treset() {\n\t\t// wack Lexer state variables\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\t\tthis._token = null;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartColumn = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = null;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack = [];\n\n\t\tthis._interp.reset();\n\t}\n\n// Return a token from this source; i.e., match a token on the char stream.\n\tnextToken() {\n\t\tif (this._input === null) {\n\t\t\tthrow \"nextToken requires a non-null input stream.\";\n\t\t}\n\n\t\t/**\n\t\t * Mark start location in char stream so unbuffered streams are\n\t\t * guaranteed at least have text of current token\n\t\t */\n\t\tconst tokenStartMarker = this._input.mark();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\tthis.emitEOF();\n\t\t\t\t\treturn this._token;\n\t\t\t\t}\n\t\t\t\tthis._token = null;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\t\tthis._text = null;\n\t\t\t\tlet continueOuter = false;\n\t\t\t\twhile (true) {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\t\tlet ttype = Lexer.SKIP;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif(e instanceof RecognitionException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e); // report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(e.stack);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueOuter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._token === null) {\n\t\t\t\t\tthis.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t} finally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/**\n\t * Instruct the lexer to skip creating a token for current lexer rule\n\t * and look for another token. nextToken() knows to keep looking when\n\t * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n\t * if token==null at end of any token rule, it creates one for you\n\t * and emits it.\n\t */\n\tskip() {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tmore() {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tmode(m) {\n\t\tthis._mode = m;\n\t}\n\n\tpushMode(m) {\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpopMode() {\n\t\tif (this._modeStack.length === 0) {\n\t\t\tthrow \"Empty Stack\";\n\t\t}\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * By default does not support multiple emits per nextToken invocation\n\t * for efficiency reasons. Subclass and override this method, nextToken,\n\t * and getToken (to push tokens into a list and pull from that list\n\t * rather than a single variable as this implementation does).\n\t */\n\temitToken(token) {\n\t\tthis._token = token;\n\t}\n\n\t/**\n\t * The standard method called to automatically emit a token at the\n\t * outermost lexical rule. The token object should point into the\n\t * char buffer start..stop. If there is a text override in 'text',\n\t * use that to set the token's text. Override this method to emit\n\t * custom Token objects or provide a new factory.\n\t */\n\temit() {\n\t\tconst t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn);\n\t\tthis.emitToken(t);\n\t\treturn t;\n\t}\n\n\temitEOF() {\n\t\tconst cpos = this.column;\n\t\tconst lpos = this.line;\n\t\tconst eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\t\tthis._input.index - 1, lpos, cpos);\n\t\tthis.emitToken(eof);\n\t\treturn eof;\n\t}\n\n// What is the index of the current character of lookahead?///\n\tgetCharIndex() {\n\t\treturn this._input.index;\n\t}\n\n\t/**\n\t * Return a list of all Token objects in input char stream.\n\t * Forces load of all tokens. Does not include EOF token.\n\t */\n\tgetAllTokens() {\n\t\tconst tokens = [];\n\t\tlet t = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tnotifyListeners(e) {\n\t\tconst start = this._tokenStartCharIndex;\n\t\tconst stop = this._input.index;\n\t\tconst text = this._input.getText(start, stop);\n\t\tconst msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn, msg, e);\n\t}\n\n\tgetErrorDisplay(s) {\n\t\tconst d = [];\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\td.push(s[i]);\n\t\t}\n\t\treturn d.join('');\n\t}\n\n\tgetErrorDisplayForChar(c) {\n\t\tif (c.charCodeAt(0) === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (c === '\\n') {\n\t\t\treturn \"\\\\n\";\n\t\t} else if (c === '\\t') {\n\t\t\treturn \"\\\\t\";\n\t\t} else if (c === '\\r') {\n\t\t\treturn \"\\\\r\";\n\t\t} else {\n\t\t\treturn c;\n\t\t}\n\t}\n\n\tgetCharErrorDisplay(c) {\n\t\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n\t}\n\n\t/**\n\t * Lexers can normally match any char in it's vocabulary after matching\n\t * a token, so do the easy thing and just kill a character and hope\n\t * it all works out. You can instead use the rule invocation stack\n\t * to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\trecover(re) {\n\t\tif (this._input.LA(1) !== Token.EOF) {\n\t\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis._interp.consume(this._input);\n\t\t\t} else {\n\t\t\t\t// TODO: Do we lose character or line position information?\n\t\t\t\tthis._input.consume();\n\t\t\t}\n\t\t}\n\t}\n\n\tget inputStream(){\n\t\treturn this._input;\n\t}\n\n\tset inputStream(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n\n\tget sourceName(){\n\t\treturn this._input.sourceName;\n\t}\n\n\tget type(){\n\t\treturn this._type;\n\t}\n\n\tset type(type) {\n\t\tthis._type = type;\n\t}\n\n\tget line(){\n\t\treturn this._interp.line;\n\t}\n\n\tset line(line) {\n\t\tthis._interp.line = line;\n\t}\n\n\tget column(){\n\t\treturn this._interp.column;\n\t}\n\n\tset column(column) {\n\t\tthis._interp.column = column;\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n\n\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\n// Set the char stream and reset the lexer\n\n\nmodule.exports = Lexer;\n"]},"metadata":{},"sourceType":"script"}