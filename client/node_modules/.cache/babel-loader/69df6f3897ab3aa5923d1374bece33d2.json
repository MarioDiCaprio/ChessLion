{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./../Token');\n\nconst ATN = require('./ATN');\n\nconst ATNType = require('./ATNType');\n\nconst {\n  ATNState,\n  BasicState,\n  DecisionState,\n  BlockStartState,\n  BlockEndState,\n  LoopEndState,\n  RuleStartState,\n  RuleStopState,\n  TokensStartState,\n  PlusLoopbackState,\n  StarLoopbackState,\n  StarLoopEntryState,\n  PlusBlockStartState,\n  StarBlockStartState,\n  BasicBlockStartState\n} = require('./ATNState');\n\nconst {\n  Transition,\n  AtomTransition,\n  SetTransition,\n  NotSetTransition,\n  RuleTransition,\n  RangeTransition,\n  ActionTransition,\n  EpsilonTransition,\n  WildcardTransition,\n  PredicateTransition,\n  PrecedencePredicateTransition\n} = require('./Transition');\n\nconst {\n  IntervalSet\n} = require('./../IntervalSet');\n\nconst ATNDeserializationOptions = require('./ATNDeserializationOptions');\n\nconst {\n  LexerActionType,\n  LexerSkipAction,\n  LexerChannelAction,\n  LexerCustomAction,\n  LexerMoreAction,\n  LexerTypeAction,\n  LexerPushModeAction,\n  LexerPopModeAction,\n  LexerModeAction\n} = require('./LexerAction'); // This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\n\n\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\"; //\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\n\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\"; // This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\n\nconst SUPPORTED_UUIDS = [BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP];\nconst SERIALIZED_VERSION = 3; // This is the current serialized UUID.\n\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray(length, value) {\n  const tmp = [];\n  tmp[length - 1] = value;\n  return tmp.map(function (i) {\n    return value;\n  });\n}\n\nclass ATNDeserializer {\n  constructor(options) {\n    if (options === undefined || options === null) {\n      options = ATNDeserializationOptions.defaultOptions;\n    }\n\n    this.deserializationOptions = options;\n    this.stateFactories = null;\n    this.actionFactories = null;\n  }\n  /**\n   * Determines if a particular serialized representation of an ATN supports\n   * a particular feature, identified by the {@link UUID} used for serializing\n   * the ATN at the time the feature was first introduced.\n   *\n   * @param feature The {@link UUID} marking the first time the feature was\n   * supported in the serialized ATN.\n   * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n   * currently being deserialized.\n   * @return {@code true} if the {@code actualUuid} value represents a\n   * serialized ATN at or after the feature identified by {@code feature} was\n   * introduced; otherwise, {@code false}.\n  */\n\n\n  isFeatureSupported(feature, actualUuid) {\n    const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n\n    if (idx1 < 0) {\n      return false;\n    }\n\n    const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n    return idx2 >= idx1;\n  }\n\n  deserialize(data) {\n    this.reset(data);\n    this.checkVersion();\n    this.checkUUID();\n    const atn = this.readATN();\n    this.readStates(atn);\n    this.readRules(atn);\n    this.readModes(atn);\n    const sets = []; // First, deserialize sets with 16-bit arguments <= U+FFFF.\n\n    this.readSets(atn, sets, this.readInt.bind(this)); // Next, if the ATN was serialized with the Unicode SMP feature,\n    // deserialize sets with 32-bit arguments <= U+10FFFF.\n\n    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n      this.readSets(atn, sets, this.readInt32.bind(this));\n    }\n\n    this.readEdges(atn, sets);\n    this.readDecisions(atn);\n    this.readLexerActions(atn);\n    this.markPrecedenceDecisions(atn);\n    this.verifyATN(atn);\n\n    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {\n      this.generateRuleBypassTransitions(atn); // re-verify after modification\n\n      this.verifyATN(atn);\n    }\n\n    return atn;\n  }\n\n  reset(data) {\n    const adjust = function (c) {\n      const v = c.charCodeAt(0);\n      return v > 1 ? v - 2 : v + 65534;\n    };\n\n    const temp = data.split(\"\").map(adjust); // don't adjust the first value since that's the version number\n\n    temp[0] = data.charCodeAt(0);\n    this.data = temp;\n    this.pos = 0;\n  }\n\n  checkVersion() {\n    const version = this.readInt();\n\n    if (version !== SERIALIZED_VERSION) {\n      throw \"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\";\n    }\n  }\n\n  checkUUID() {\n    const uuid = this.readUUID();\n\n    if (SUPPORTED_UUIDS.indexOf(uuid) < 0) {\n      throw \"Could not deserialize ATN with UUID: \" + uuid + \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID;\n    }\n\n    this.uuid = uuid;\n  }\n\n  readATN() {\n    const grammarType = this.readInt();\n    const maxTokenType = this.readInt();\n    return new ATN(grammarType, maxTokenType);\n  }\n\n  readStates(atn) {\n    let j, pair, stateNumber;\n    const loopBackStateNumbers = [];\n    const endStateNumbers = [];\n    const nstates = this.readInt();\n\n    for (let i = 0; i < nstates; i++) {\n      const stype = this.readInt(); // ignore bad type of states\n\n      if (stype === ATNState.INVALID_TYPE) {\n        atn.addState(null);\n        continue;\n      }\n\n      let ruleIndex = this.readInt();\n\n      if (ruleIndex === 0xFFFF) {\n        ruleIndex = -1;\n      }\n\n      const s = this.stateFactory(stype, ruleIndex);\n\n      if (stype === ATNState.LOOP_END) {\n        // special case\n        const loopBackStateNumber = this.readInt();\n        loopBackStateNumbers.push([s, loopBackStateNumber]);\n      } else if (s instanceof BlockStartState) {\n        const endStateNumber = this.readInt();\n        endStateNumbers.push([s, endStateNumber]);\n      }\n\n      atn.addState(s);\n    } // delay the assignment of loop back and end states until we know all the\n    // state instances have been initialized\n\n\n    for (j = 0; j < loopBackStateNumbers.length; j++) {\n      pair = loopBackStateNumbers[j];\n      pair[0].loopBackState = atn.states[pair[1]];\n    }\n\n    for (j = 0; j < endStateNumbers.length; j++) {\n      pair = endStateNumbers[j];\n      pair[0].endState = atn.states[pair[1]];\n    }\n\n    let numNonGreedyStates = this.readInt();\n\n    for (j = 0; j < numNonGreedyStates; j++) {\n      stateNumber = this.readInt();\n      atn.states[stateNumber].nonGreedy = true;\n    }\n\n    let numPrecedenceStates = this.readInt();\n\n    for (j = 0; j < numPrecedenceStates; j++) {\n      stateNumber = this.readInt();\n      atn.states[stateNumber].isPrecedenceRule = true;\n    }\n  }\n\n  readRules(atn) {\n    let i;\n    const nrules = this.readInt();\n\n    if (atn.grammarType === ATNType.LEXER) {\n      atn.ruleToTokenType = initArray(nrules, 0);\n    }\n\n    atn.ruleToStartState = initArray(nrules, 0);\n\n    for (i = 0; i < nrules; i++) {\n      const s = this.readInt();\n      atn.ruleToStartState[i] = atn.states[s];\n\n      if (atn.grammarType === ATNType.LEXER) {\n        let tokenType = this.readInt();\n\n        if (tokenType === 0xFFFF) {\n          tokenType = Token.EOF;\n        }\n\n        atn.ruleToTokenType[i] = tokenType;\n      }\n    }\n\n    atn.ruleToStopState = initArray(nrules, 0);\n\n    for (i = 0; i < atn.states.length; i++) {\n      const state = atn.states[i];\n\n      if (!(state instanceof RuleStopState)) {\n        continue;\n      }\n\n      atn.ruleToStopState[state.ruleIndex] = state;\n      atn.ruleToStartState[state.ruleIndex].stopState = state;\n    }\n  }\n\n  readModes(atn) {\n    const nmodes = this.readInt();\n\n    for (let i = 0; i < nmodes; i++) {\n      let s = this.readInt();\n      atn.modeToStartState.push(atn.states[s]);\n    }\n  }\n\n  readSets(atn, sets, readUnicode) {\n    const m = this.readInt();\n\n    for (let i = 0; i < m; i++) {\n      const iset = new IntervalSet();\n      sets.push(iset);\n      const n = this.readInt();\n      const containsEof = this.readInt();\n\n      if (containsEof !== 0) {\n        iset.addOne(-1);\n      }\n\n      for (let j = 0; j < n; j++) {\n        const i1 = readUnicode();\n        const i2 = readUnicode();\n        iset.addRange(i1, i2);\n      }\n    }\n  }\n\n  readEdges(atn, sets) {\n    let i, j, state, trans, target;\n    const nedges = this.readInt();\n\n    for (i = 0; i < nedges; i++) {\n      const src = this.readInt();\n      const trg = this.readInt();\n      const ttype = this.readInt();\n      const arg1 = this.readInt();\n      const arg2 = this.readInt();\n      const arg3 = this.readInt();\n      trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n      const srcState = atn.states[src];\n      srcState.addTransition(trans);\n    } // edges for rule stop states can be derived, so they aren't serialized\n\n\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n\n      for (j = 0; j < state.transitions.length; j++) {\n        const t = state.transitions[j];\n\n        if (!(t instanceof RuleTransition)) {\n          continue;\n        }\n\n        let outermostPrecedenceReturn = -1;\n\n        if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n          if (t.precedence === 0) {\n            outermostPrecedenceReturn = t.target.ruleIndex;\n          }\n        }\n\n        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n        atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n      }\n    }\n\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n\n      if (state instanceof BlockStartState) {\n        // we need to know the end state to set its start state\n        if (state.endState === null) {\n          throw \"IllegalState\";\n        } // block end states can only be associated to a single block start\n        // state\n\n\n        if (state.endState.startState !== null) {\n          throw \"IllegalState\";\n        }\n\n        state.endState.startState = state;\n      }\n\n      if (state instanceof PlusLoopbackState) {\n        for (j = 0; j < state.transitions.length; j++) {\n          target = state.transitions[j].target;\n\n          if (target instanceof PlusBlockStartState) {\n            target.loopBackState = state;\n          }\n        }\n      } else if (state instanceof StarLoopbackState) {\n        for (j = 0; j < state.transitions.length; j++) {\n          target = state.transitions[j].target;\n\n          if (target instanceof StarLoopEntryState) {\n            target.loopBackState = state;\n          }\n        }\n      }\n    }\n  }\n\n  readDecisions(atn) {\n    const ndecisions = this.readInt();\n\n    for (let i = 0; i < ndecisions; i++) {\n      const s = this.readInt();\n      const decState = atn.states[s];\n      atn.decisionToState.push(decState);\n      decState.decision = i;\n    }\n  }\n\n  readLexerActions(atn) {\n    if (atn.grammarType === ATNType.LEXER) {\n      const count = this.readInt();\n      atn.lexerActions = initArray(count, null);\n\n      for (let i = 0; i < count; i++) {\n        const actionType = this.readInt();\n        let data1 = this.readInt();\n\n        if (data1 === 0xFFFF) {\n          data1 = -1;\n        }\n\n        let data2 = this.readInt();\n\n        if (data2 === 0xFFFF) {\n          data2 = -1;\n        }\n\n        atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n      }\n    }\n  }\n\n  generateRuleBypassTransitions(atn) {\n    let i;\n    const count = atn.ruleToStartState.length;\n\n    for (i = 0; i < count; i++) {\n      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n    }\n\n    for (i = 0; i < count; i++) {\n      this.generateRuleBypassTransition(atn, i);\n    }\n  }\n\n  generateRuleBypassTransition(atn, idx) {\n    let i, state;\n    const bypassStart = new BasicBlockStartState();\n    bypassStart.ruleIndex = idx;\n    atn.addState(bypassStart);\n    const bypassStop = new BlockEndState();\n    bypassStop.ruleIndex = idx;\n    atn.addState(bypassStop);\n    bypassStart.endState = bypassStop;\n    atn.defineDecisionState(bypassStart);\n    bypassStop.startState = bypassStart;\n    let excludeTransition = null;\n    let endState = null;\n\n    if (atn.ruleToStartState[idx].isPrecedenceRule) {\n      // wrap from the beginning of the rule to the StarLoopEntryState\n      endState = null;\n\n      for (i = 0; i < atn.states.length; i++) {\n        state = atn.states[i];\n\n        if (this.stateIsEndStateFor(state, idx)) {\n          endState = state;\n          excludeTransition = state.loopBackState.transitions[0];\n          break;\n        }\n      }\n\n      if (excludeTransition === null) {\n        throw \"Couldn't identify final state of the precedence rule prefix section.\";\n      }\n    } else {\n      endState = atn.ruleToStopState[idx];\n    } // all non-excluded transitions that currently target end state need to\n    // target blockEnd instead\n\n\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n\n      for (let j = 0; j < state.transitions.length; j++) {\n        const transition = state.transitions[j];\n\n        if (transition === excludeTransition) {\n          continue;\n        }\n\n        if (transition.target === endState) {\n          transition.target = bypassStop;\n        }\n      }\n    } // all transitions leaving the rule start state need to leave blockStart\n    // instead\n\n\n    const ruleToStartState = atn.ruleToStartState[idx];\n    const count = ruleToStartState.transitions.length;\n\n    while (count > 0) {\n      bypassStart.addTransition(ruleToStartState.transitions[count - 1]);\n      ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n    } // link the new states\n\n\n    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n    bypassStop.addTransition(new EpsilonTransition(endState));\n    const matchState = new BasicState();\n    atn.addState(matchState);\n    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n    bypassStart.addTransition(new EpsilonTransition(matchState));\n  }\n\n  stateIsEndStateFor(state, idx) {\n    if (state.ruleIndex !== idx) {\n      return null;\n    }\n\n    if (!(state instanceof StarLoopEntryState)) {\n      return null;\n    }\n\n    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n\n    if (!(maybeLoopEndState instanceof LoopEndState)) {\n      return null;\n    }\n\n    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n      return state;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n   * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n   * correct value.\n   * @param atn The ATN.\n   */\n\n\n  markPrecedenceDecisions(atn) {\n    for (let i = 0; i < atn.states.length; i++) {\n      const state = atn.states[i];\n\n      if (!(state instanceof StarLoopEntryState)) {\n        continue;\n      } // We analyze the ATN to determine if this ATN decision state is the\n      // decision for the closure block that determines whether a\n      // precedence rule should continue or complete.\n\n\n      if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n\n        if (maybeLoopEndState instanceof LoopEndState) {\n          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n            state.isPrecedenceDecision = true;\n          }\n        }\n      }\n    }\n  }\n\n  verifyATN(atn) {\n    if (!this.deserializationOptions.verifyATN) {\n      return;\n    } // verify assumptions\n\n\n    for (let i = 0; i < atn.states.length; i++) {\n      const state = atn.states[i];\n\n      if (state === null) {\n        continue;\n      }\n\n      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n\n      if (state instanceof PlusBlockStartState) {\n        this.checkCondition(state.loopBackState !== null);\n      } else if (state instanceof StarLoopEntryState) {\n        this.checkCondition(state.loopBackState !== null);\n        this.checkCondition(state.transitions.length === 2);\n\n        if (state.transitions[0].target instanceof StarBlockStartState) {\n          this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n          this.checkCondition(!state.nonGreedy);\n        } else if (state.transitions[0].target instanceof LoopEndState) {\n          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n          this.checkCondition(state.nonGreedy);\n        } else {\n          throw \"IllegalState\";\n        }\n      } else if (state instanceof StarLoopbackState) {\n        this.checkCondition(state.transitions.length === 1);\n        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n      } else if (state instanceof LoopEndState) {\n        this.checkCondition(state.loopBackState !== null);\n      } else if (state instanceof RuleStartState) {\n        this.checkCondition(state.stopState !== null);\n      } else if (state instanceof BlockStartState) {\n        this.checkCondition(state.endState !== null);\n      } else if (state instanceof BlockEndState) {\n        this.checkCondition(state.startState !== null);\n      } else if (state instanceof DecisionState) {\n        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n      } else {\n        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);\n      }\n    }\n  }\n\n  checkCondition(condition, message) {\n    if (!condition) {\n      if (message === undefined || message === null) {\n        message = \"IllegalState\";\n      }\n\n      throw message;\n    }\n  }\n\n  readInt() {\n    return this.data[this.pos++];\n  }\n\n  readInt32() {\n    const low = this.readInt();\n    const high = this.readInt();\n    return low | high << 16;\n  }\n\n  readLong() {\n    const low = this.readInt32();\n    const high = this.readInt32();\n    return low & 0x00000000FFFFFFFF | high << 32;\n  }\n\n  readUUID() {\n    const bb = [];\n\n    for (let i = 7; i >= 0; i--) {\n      const int = this.readInt();\n      /* jshint bitwise: false */\n\n      bb[2 * i + 1] = int & 0xFF;\n      bb[2 * i] = int >> 8 & 0xFF;\n    }\n\n    return byteToHex[bb[0]] + byteToHex[bb[1]] + byteToHex[bb[2]] + byteToHex[bb[3]] + '-' + byteToHex[bb[4]] + byteToHex[bb[5]] + '-' + byteToHex[bb[6]] + byteToHex[bb[7]] + '-' + byteToHex[bb[8]] + byteToHex[bb[9]] + '-' + byteToHex[bb[10]] + byteToHex[bb[11]] + byteToHex[bb[12]] + byteToHex[bb[13]] + byteToHex[bb[14]] + byteToHex[bb[15]];\n  }\n\n  edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n    const target = atn.states[trg];\n\n    switch (type) {\n      case Transition.EPSILON:\n        return new EpsilonTransition(target);\n\n      case Transition.RANGE:\n        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n\n      case Transition.RULE:\n        return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n\n      case Transition.PREDICATE:\n        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n\n      case Transition.PRECEDENCE:\n        return new PrecedencePredicateTransition(target, arg1);\n\n      case Transition.ATOM:\n        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n\n      case Transition.ACTION:\n        return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n\n      case Transition.SET:\n        return new SetTransition(target, sets[arg1]);\n\n      case Transition.NOT_SET:\n        return new NotSetTransition(target, sets[arg1]);\n\n      case Transition.WILDCARD:\n        return new WildcardTransition(target);\n\n      default:\n        throw \"The specified transition type: \" + type + \" is not valid.\";\n    }\n  }\n\n  stateFactory(type, ruleIndex) {\n    if (this.stateFactories === null) {\n      const sf = [];\n      sf[ATNState.INVALID_TYPE] = null;\n\n      sf[ATNState.BASIC] = () => new BasicState();\n\n      sf[ATNState.RULE_START] = () => new RuleStartState();\n\n      sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n\n      sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n\n      sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n\n      sf[ATNState.TOKEN_START] = () => new TokensStartState();\n\n      sf[ATNState.RULE_STOP] = () => new RuleStopState();\n\n      sf[ATNState.BLOCK_END] = () => new BlockEndState();\n\n      sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n\n      sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n\n      sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n\n      sf[ATNState.LOOP_END] = () => new LoopEndState();\n\n      this.stateFactories = sf;\n    }\n\n    if (type > this.stateFactories.length || this.stateFactories[type] === null) {\n      throw \"The specified state type \" + type + \" is not valid.\";\n    } else {\n      const s = this.stateFactories[type]();\n\n      if (s !== null) {\n        s.ruleIndex = ruleIndex;\n        return s;\n      }\n    }\n  }\n\n  lexerActionFactory(type, data1, data2) {\n    if (this.actionFactories === null) {\n      const af = [];\n\n      af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n\n      af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n\n      af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n\n      af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n\n      af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n\n      af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n\n      af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n\n      af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n\n      this.actionFactories = af;\n    }\n\n    if (type > this.actionFactories.length || this.actionFactories[type] === null) {\n      throw \"The specified lexer action type \" + type + \" is not valid.\";\n    } else {\n      return this.actionFactories[type](data1, data2);\n    }\n  }\n\n}\n\nfunction createByteToHex() {\n  const bth = [];\n\n  for (let i = 0; i < 256; i++) {\n    bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n  }\n\n  return bth;\n}\n\nconst byteToHex = createByteToHex();\nmodule.exports = ATNDeserializer;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js"],"names":["Token","require","ATN","ATNType","ATNState","BasicState","DecisionState","BlockStartState","BlockEndState","LoopEndState","RuleStartState","RuleStopState","TokensStartState","PlusLoopbackState","StarLoopbackState","StarLoopEntryState","PlusBlockStartState","StarBlockStartState","BasicBlockStartState","Transition","AtomTransition","SetTransition","NotSetTransition","RuleTransition","RangeTransition","ActionTransition","EpsilonTransition","WildcardTransition","PredicateTransition","PrecedencePredicateTransition","IntervalSet","ATNDeserializationOptions","LexerActionType","LexerSkipAction","LexerChannelAction","LexerCustomAction","LexerMoreAction","LexerTypeAction","LexerPushModeAction","LexerPopModeAction","LexerModeAction","BASE_SERIALIZED_UUID","ADDED_UNICODE_SMP","SUPPORTED_UUIDS","SERIALIZED_VERSION","SERIALIZED_UUID","initArray","length","value","tmp","map","i","ATNDeserializer","constructor","options","undefined","defaultOptions","deserializationOptions","stateFactories","actionFactories","isFeatureSupported","feature","actualUuid","idx1","indexOf","idx2","deserialize","data","reset","checkVersion","checkUUID","atn","readATN","readStates","readRules","readModes","sets","readSets","readInt","bind","uuid","readInt32","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","verifyATN","generateRuleBypassTransitions","grammarType","PARSER","adjust","c","v","charCodeAt","temp","split","pos","version","readUUID","maxTokenType","j","pair","stateNumber","loopBackStateNumbers","endStateNumbers","nstates","stype","INVALID_TYPE","addState","ruleIndex","s","stateFactory","LOOP_END","loopBackStateNumber","push","endStateNumber","loopBackState","states","endState","numNonGreedyStates","nonGreedy","numPrecedenceStates","isPrecedenceRule","nrules","LEXER","ruleToTokenType","ruleToStartState","tokenType","EOF","ruleToStopState","state","stopState","nmodes","modeToStartState","readUnicode","m","iset","n","containsEof","addOne","i1","i2","addRange","trans","target","nedges","src","trg","ttype","arg1","arg2","arg3","edgeFactory","srcState","addTransition","transitions","t","outermostPrecedenceReturn","precedence","followState","startState","ndecisions","decState","decisionToState","decision","count","lexerActions","actionType","data1","data2","lexerActionFactory","generateRuleBypassTransition","idx","bypassStart","bypassStop","defineDecisionState","excludeTransition","stateIsEndStateFor","transition","slice","matchState","maybeLoopEndState","epsilonOnlyTransitions","isPrecedenceDecision","checkCondition","condition","message","low","high","readLong","bb","int","byteToHex","type","EPSILON","RANGE","RULE","PREDICATE","PRECEDENCE","ATOM","ACTION","SET","NOT_SET","WILDCARD","sf","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","af","CHANNEL","CUSTOM","MODE","MORE","INSTANCE","POP_MODE","PUSH_MODE","SKIP","TYPE","createByteToHex","bth","toString","substr","toUpperCase","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst ATN = require('./ATN');\nconst ATNType = require('./ATNType');\n\nconst {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n} = require('./ATNState');\n\nconst {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n} = require('./Transition')\n\nconst {IntervalSet} = require('./../IntervalSet');\nconst ATNDeserializationOptions = require('./ATNDeserializationOptions');\n\nconst {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction,\n} = require('./LexerAction');\n\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nconst SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nconst SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tconst tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nclass ATNDeserializer {\n    constructor(options) {\n\n        if ( options=== undefined || options === null ) {\n            options = ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = options;\n        this.stateFactories = null;\n        this.actionFactories = null;\n    }\n\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @return {@code true} if the {@code actualUuid} value represents a\n     * serialized ATN at or after the feature identified by {@code feature} was\n     * introduced; otherwise, {@code false}.\n    */\n    isFeatureSupported(feature, actualUuid) {\n        const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n        if (idx1<0) {\n            return false;\n        }\n        const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n        return idx2 >= idx1;\n    }\n\n    deserialize(data) {\n        this.reset(data);\n        this.checkVersion();\n        this.checkUUID();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        // First, deserialize sets with 16-bit arguments <= U+FFFF.\n        this.readSets(atn, sets, this.readInt.bind(this));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n            this.readSets(atn, sets, this.readInt32.bind(this));\n        }\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n            this.generateRuleBypassTransitions(atn);\n            // re-verify after modification\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n\n    reset(data) {\n        const adjust = function(c) {\n            const v = c.charCodeAt(0);\n            return v>1  ? v-2 : v + 65534;\n        };\n        const temp = data.split(\"\").map(adjust);\n        // don't adjust the first value since that's the version number\n        temp[0] = data.charCodeAt(0);\n        this.data = temp;\n        this.pos = 0;\n    }\n\n    checkVersion() {\n        const version = this.readInt();\n        if ( version !== SERIALIZED_VERSION ) {\n            throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n        }\n    }\n\n    checkUUID() {\n        const uuid = this.readUUID();\n        if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n            throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                            \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n        }\n        this.uuid = uuid;\n    }\n\n    readATN() {\n        const grammarType = this.readInt();\n        const maxTokenType = this.readInt();\n        return new ATN(grammarType, maxTokenType);\n    }\n\n    readStates(atn) {\n        let j, pair, stateNumber;\n        const  loopBackStateNumbers = [];\n        const  endStateNumbers = [];\n        const  nstates = this.readInt();\n        for(let i=0; i<nstates; i++) {\n            const  stype = this.readInt();\n            // ignore bad type of states\n            if (stype===ATNState.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            let ruleIndex = this.readInt();\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            const  s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNState.LOOP_END) { // special case\n                const  loopBackStateNumber = this.readInt();\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            } else if(s instanceof BlockStartState) {\n                const  endStateNumber = this.readInt();\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the\n        // state instances have been initialized\n        for (j=0; j<loopBackStateNumbers.length; j++) {\n            pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n\n        for (j=0; j<endStateNumbers.length; j++) {\n            pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n\n        let numNonGreedyStates = this.readInt();\n        for (j=0; j<numNonGreedyStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].nonGreedy = true;\n        }\n\n        let numPrecedenceStates = this.readInt();\n        for (j=0; j<numPrecedenceStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n    }\n\n    readRules(atn) {\n        let i;\n        const nrules = this.readInt();\n        if (atn.grammarType === ATNType.LEXER ) {\n            atn.ruleToTokenType = initArray(nrules, 0);\n        }\n        atn.ruleToStartState = initArray(nrules, 0);\n        for (i=0; i<nrules; i++) {\n            const s = this.readInt();\n            atn.ruleToStartState[i] = atn.states[s];\n            if ( atn.grammarType === ATNType.LEXER ) {\n                let tokenType = this.readInt();\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = initArray(nrules, 0);\n        for (i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!(state instanceof RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n\n    readModes(atn) {\n        const nmodes = this.readInt();\n        for (let i=0; i<nmodes; i++) {\n            let s = this.readInt();\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n\n    readSets(atn, sets, readUnicode) {\n        const m = this.readInt();\n        for (let i=0; i<m; i++) {\n            const iset = new IntervalSet();\n            sets.push(iset);\n            const n = this.readInt();\n            const containsEof = this.readInt();\n            if (containsEof!==0) {\n                iset.addOne(-1);\n            }\n            for (let j=0; j<n; j++) {\n                const i1 = readUnicode();\n                const i2 = readUnicode();\n                iset.addRange(i1, i2);\n            }\n        }\n    }\n\n    readEdges(atn, sets) {\n        let i, j, state, trans, target;\n        const nedges = this.readInt();\n        for (i=0; i<nedges; i++) {\n            const src = this.readInt();\n            const trg = this.readInt();\n            const ttype = this.readInt();\n            const arg1 = this.readInt();\n            const arg2 = this.readInt();\n            const arg3 = this.readInt();\n            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        // edges for rule stop states can be derived, so they aren't serialized\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for (j=0; j<state.transitions.length; j++) {\n                const t = state.transitions[j];\n                if (!(t instanceof RuleTransition)) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n                    if (t.precedence === 0) {\n                        outermostPrecedenceReturn = t.target.ruleIndex;\n                    }\n                }\n\n                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (state instanceof BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState === null) {\n                    throw (\"IllegalState\");\n                }\n                // block end states can only be associated to a single block start\n                // state\n                if ( state.endState.startState !== null) {\n                    throw (\"IllegalState\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof PlusBlockStartState) {\n                        target.loopBackState = state;\n                    }\n                }\n            } else if (state instanceof StarLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof StarLoopEntryState) {\n                        target.loopBackState = state;\n                    }\n                }\n            }\n        }\n    }\n\n    readDecisions(atn) {\n        const ndecisions = this.readInt();\n        for (let i=0; i<ndecisions; i++) {\n            const s = this.readInt();\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n\n    readLexerActions(atn) {\n        if (atn.grammarType === ATNType.LEXER) {\n            const count = this.readInt();\n            atn.lexerActions = initArray(count, null);\n            for (let i=0; i<count; i++) {\n                const actionType = this.readInt();\n                let data1 = this.readInt();\n                if (data1 === 0xFFFF) {\n                    data1 = -1;\n                }\n                let data2 = this.readInt();\n                if (data2 === 0xFFFF) {\n                    data2 = -1;\n                }\n\n                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n            }\n        }\n    }\n\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i=0; i<count; i++) {\n            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for(i=0; i<count; i++) {\n            this.generateRuleBypassTransition(atn, i);\n        }\n    }\n\n    generateRuleBypassTransition(atn, idx) {\n        let i, state;\n        const bypassStart = new BasicBlockStartState();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n\n        const bypassStop = new BlockEndState();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n\n        bypassStop.startState = bypassStart;\n\n        let excludeTransition = null;\n        let endState = null;\n\n        if (atn.ruleToStartState[idx].isPrecedenceRule) {\n            // wrap from the beginning of the rule to the StarLoopEntryState\n            endState = null;\n            for(i=0; i<atn.states.length; i++) {\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) {\n                throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n        } else {\n            endState = atn.ruleToStopState[idx];\n        }\n\n        // all non-excluded transitions that currently target end state need to\n        // target blockEnd instead\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for(let j=0; j<state.transitions.length; j++) {\n                const transition = state.transitions[j];\n                if (transition === excludeTransition) {\n                    continue;\n                }\n                if (transition.target === endState) {\n                    transition.target = bypassStop;\n                }\n            }\n        }\n\n        // all transitions leaving the rule start state need to leave blockStart\n        // instead\n        const ruleToStartState = atn.ruleToStartState[idx];\n        const count = ruleToStartState.transitions.length;\n        while ( count > 0) {\n            bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n        }\n        // link the new states\n        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n        bypassStop.addTransition(new EpsilonTransition(endState));\n\n        const matchState = new BasicState();\n        atn.addState(matchState);\n        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n\n    stateIsEndStateFor(state, idx) {\n        if ( state.ruleIndex !== idx) {\n            return null;\n        }\n        if (!( state instanceof StarLoopEntryState)) {\n            return null;\n        }\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!( maybeLoopEndState instanceof LoopEndState)) {\n            return null;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions &&\n            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n            return state;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n     * correct value.\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!( state instanceof StarLoopEntryState)) {\n                continue;\n            }\n            // We analyze the ATN to determine if this ATN decision state is the\n            // decision for the closure block that determines whether a\n            // precedence rule should continue or complete.\n            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof LoopEndState) {\n                    if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                        state.isPrecedenceDecision = true;\n                    }\n                }\n            }\n        }\n    }\n\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) {\n            return;\n        }\n        // verify assumptions\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (state === null) {\n                continue;\n            }\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof PlusBlockStartState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else  if (state instanceof StarLoopEntryState) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof StarBlockStartState) {\n                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof LoopEndState) {\n                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                    this.checkCondition(state.nonGreedy);\n                } else {\n                    throw(\"IllegalState\");\n                }\n            } else if (state instanceof StarLoopbackState) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n            } else if (state instanceof LoopEndState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else if (state instanceof RuleStartState) {\n                this.checkCondition(state.stopState !== null);\n            } else if (state instanceof BlockStartState) {\n                this.checkCondition(state.endState !== null);\n            } else if (state instanceof BlockEndState) {\n                this.checkCondition(state.startState !== null);\n            } else if (state instanceof DecisionState) {\n                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            } else {\n                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n            }\n        }\n    }\n\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === undefined || message===null) {\n                message = \"IllegalState\";\n            }\n            throw (message);\n        }\n    }\n\n    readInt() {\n        return this.data[this.pos++];\n    }\n\n    readInt32() {\n        const low = this.readInt();\n        const high = this.readInt();\n        return low | (high << 16);\n    }\n\n    readLong() {\n        const low = this.readInt32();\n        const high = this.readInt32();\n        return (low & 0x00000000FFFFFFFF) | (high << 32);\n    }\n\n    readUUID() {\n        const bb = [];\n        for(let i=7;i>=0;i--) {\n            const int = this.readInt();\n            /* jshint bitwise: false */\n            bb[(2*i)+1] = int & 0xFF;\n            bb[2*i] = (int >> 8) & 0xFF;\n        }\n        return byteToHex[bb[0]] + byteToHex[bb[1]] +\n        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n        byteToHex[bb[10]] + byteToHex[bb[11]] +\n        byteToHex[bb[12]] + byteToHex[bb[13]] +\n        byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n            return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n            return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw \"The specified transition type: \" + type + \" is not valid.\";\n        }\n    }\n\n    stateFactory(type, ruleIndex) {\n        if (this.stateFactories === null) {\n            const sf = [];\n            sf[ATNState.INVALID_TYPE] = null;\n            sf[ATNState.BASIC] = () => new BasicState();\n            sf[ATNState.RULE_START] = () => new RuleStartState();\n            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n            sf[ATNState.TOKEN_START] = () => new TokensStartState();\n            sf[ATNState.RULE_STOP] = () => new RuleStopState();\n            sf[ATNState.BLOCK_END] = () => new BlockEndState();\n            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n            sf[ATNState.LOOP_END] = () => new LoopEndState();\n            this.stateFactories = sf;\n        }\n        if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n            throw(\"The specified state type \" + type + \" is not valid.\");\n        } else {\n            const s = this.stateFactories[type]();\n            if (s!==null) {\n                s.ruleIndex = ruleIndex;\n                return s;\n            }\n        }\n    }\n\n    lexerActionFactory(type, data1, data2) {\n        if (this.actionFactories === null) {\n            const af = [];\n            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n            this.actionFactories = af;\n        }\n        if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n            throw(\"The specified lexer action type \" + type + \" is not valid.\");\n        } else {\n            return this.actionFactories[type](data1, data2);\n        }\n    }\n}\n\nfunction createByteToHex() {\n\tconst bth = [];\n\tfor (let i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nconst byteToHex = createByteToHex();\n\n\nmodule.exports = ATNDeserializer;\n"]},"metadata":{},"sourceType":"script"}