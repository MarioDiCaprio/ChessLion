{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Token = require('./Token').Token;\n\nconst BufferedTokenStream = require('./BufferedTokenStream');\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\n\n\nclass CommonTokenStream extends BufferedTokenStream {\n  constructor(lexer, channel) {\n    super(lexer);\n    this.channel = channel === undefined ? Token.DEFAULT_CHANNEL : channel;\n  }\n\n  adjustSeekIndex(i) {\n    return this.nextTokenOnChannel(i, this.channel);\n  }\n\n  LB(k) {\n    if (k === 0 || this.index - k < 0) {\n      return null;\n    }\n\n    let i = this.index;\n    let n = 1; // find k good tokens looking backwards\n\n    while (n <= k) {\n      // skip off-channel tokens\n      i = this.previousTokenOnChannel(i - 1, this.channel);\n      n += 1;\n    }\n\n    if (i < 0) {\n      return null;\n    }\n\n    return this.tokens[i];\n  }\n\n  LT(k) {\n    this.lazyInit();\n\n    if (k === 0) {\n      return null;\n    }\n\n    if (k < 0) {\n      return this.LB(-k);\n    }\n\n    let i = this.index;\n    let n = 1; // we know tokens[pos] is a good one\n    // find k good tokens\n\n    while (n < k) {\n      // skip off-channel tokens, but make sure to not look past EOF\n      if (this.sync(i + 1)) {\n        i = this.nextTokenOnChannel(i + 1, this.channel);\n      }\n\n      n += 1;\n    }\n\n    return this.tokens[i];\n  } // Count EOF just once.\n\n\n  getNumberOfOnChannelTokens() {\n    let n = 0;\n    this.fill();\n\n    for (let i = 0; i < this.tokens.length; i++) {\n      const t = this.tokens[i];\n\n      if (t.channel === this.channel) {\n        n += 1;\n      }\n\n      if (t.type === Token.EOF) {\n        break;\n      }\n    }\n\n    return n;\n  }\n\n}\n\nmodule.exports = CommonTokenStream;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/CommonTokenStream.js"],"names":["Token","require","BufferedTokenStream","CommonTokenStream","constructor","lexer","channel","undefined","DEFAULT_CHANNEL","adjustSeekIndex","i","nextTokenOnChannel","LB","k","index","n","previousTokenOnChannel","tokens","LT","lazyInit","sync","getNumberOfOnChannelTokens","fill","length","t","type","EOF","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAGA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,KAAjC;;AACA,MAAME,mBAAmB,GAAGD,OAAO,CAAC,uBAAD,CAAnC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,iBAAN,SAAgCD,mBAAhC,CAAoD;AAChDE,EAAAA,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiB;AACxB,UAAMD,KAAN;AACA,SAAKC,OAAL,GAAeA,OAAO,KAAGC,SAAV,GAAsBP,KAAK,CAACQ,eAA5B,GAA8CF,OAA7D;AACH;;AAEDG,EAAAA,eAAe,CAACC,CAAD,EAAI;AACf,WAAO,KAAKC,kBAAL,CAAwBD,CAAxB,EAA2B,KAAKJ,OAAhC,CAAP;AACH;;AAEDM,EAAAA,EAAE,CAACC,CAAD,EAAI;AACF,QAAIA,CAAC,KAAG,CAAJ,IAAS,KAAKC,KAAL,GAAWD,CAAX,GAAa,CAA1B,EAA6B;AACzB,aAAO,IAAP;AACH;;AACD,QAAIH,CAAC,GAAG,KAAKI,KAAb;AACA,QAAIC,CAAC,GAAG,CAAR,CALE,CAMF;;AACA,WAAOA,CAAC,IAAIF,CAAZ,EAAe;AACX;AACAH,MAAAA,CAAC,GAAG,KAAKM,sBAAL,CAA4BN,CAAC,GAAG,CAAhC,EAAmC,KAAKJ,OAAxC,CAAJ;AACAS,MAAAA,CAAC,IAAI,CAAL;AACH;;AACD,QAAIL,CAAC,GAAG,CAAR,EAAW;AACP,aAAO,IAAP;AACH;;AACD,WAAO,KAAKO,MAAL,CAAYP,CAAZ,CAAP;AACH;;AAEDQ,EAAAA,EAAE,CAACL,CAAD,EAAI;AACF,SAAKM,QAAL;;AACA,QAAIN,CAAC,KAAK,CAAV,EAAa;AACT,aAAO,IAAP;AACH;;AACD,QAAIA,CAAC,GAAG,CAAR,EAAW;AACP,aAAO,KAAKD,EAAL,CAAQ,CAACC,CAAT,CAAP;AACH;;AACD,QAAIH,CAAC,GAAG,KAAKI,KAAb;AACA,QAAIC,CAAC,GAAG,CAAR,CATE,CASS;AACX;;AACA,WAAOA,CAAC,GAAGF,CAAX,EAAc;AACV;AACA,UAAI,KAAKO,IAAL,CAAUV,CAAC,GAAG,CAAd,CAAJ,EAAsB;AAClBA,QAAAA,CAAC,GAAG,KAAKC,kBAAL,CAAwBD,CAAC,GAAG,CAA5B,EAA+B,KAAKJ,OAApC,CAAJ;AACH;;AACDS,MAAAA,CAAC,IAAI,CAAL;AACH;;AACD,WAAO,KAAKE,MAAL,CAAYP,CAAZ,CAAP;AACH,GA/C+C,CAiDhD;;;AACAW,EAAAA,0BAA0B,GAAG;AACzB,QAAIN,CAAC,GAAG,CAAR;AACA,SAAKO,IAAL;;AACA,SAAK,IAAIZ,CAAC,GAAE,CAAZ,EAAeA,CAAC,GAAE,KAAKO,MAAL,CAAYM,MAA9B,EAAqCb,CAAC,EAAtC,EAA0C;AACtC,YAAMc,CAAC,GAAG,KAAKP,MAAL,CAAYP,CAAZ,CAAV;;AACA,UAAIc,CAAC,CAAClB,OAAF,KAAY,KAAKA,OAArB,EAA8B;AAC1BS,QAAAA,CAAC,IAAI,CAAL;AACH;;AACD,UAAIS,CAAC,CAACC,IAAF,KAASzB,KAAK,CAAC0B,GAAnB,EAAwB;AACpB;AACH;AACJ;;AACD,WAAOX,CAAP;AACH;;AA/D+C;;AAkEpDY,MAAM,CAACC,OAAP,GAAiBzB,iBAAjB","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n\nconst Token = require('./Token').Token;\nconst BufferedTokenStream = require('./BufferedTokenStream');\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\nclass CommonTokenStream extends BufferedTokenStream {\n    constructor(lexer, channel) {\n        super(lexer);\n        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    }\n\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n\n    LB(k) {\n        if (k===0 || this.index-k<0) {\n            return null;\n        }\n        let i = this.index;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n += 1;\n        }\n        if (i < 0) {\n            return null;\n        }\n        return this.tokens[i];\n    }\n\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) {\n            return null;\n        }\n        if (k < 0) {\n            return this.LB(-k);\n        }\n        let i = this.index;\n        let n = 1; // we know tokens[pos] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n += 1;\n        }\n        return this.tokens[i];\n    }\n\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let i =0; i< this.tokens.length;i++) {\n            const t = this.tokens[i];\n            if( t.channel===this.channel) {\n                n += 1;\n            }\n            if( t.type===Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n}\n\nmodule.exports = CommonTokenStream;\n"]},"metadata":{},"sourceType":"script"}