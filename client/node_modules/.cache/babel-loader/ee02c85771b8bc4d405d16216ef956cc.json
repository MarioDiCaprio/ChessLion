{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst LL1Analyzer = require('./../LL1Analyzer');\n\nconst {\n  IntervalSet\n} = require('./../IntervalSet');\n\nconst {\n  Token\n} = require('./../Token');\n\nclass ATN {\n  constructor(grammarType, maxTokenType) {\n    /**\n     * Used for runtime deserialization of ATNs from strings\n     * The type of the ATN.\n    */\n    this.grammarType = grammarType; // The maximum value for any symbol recognized by a transition in the ATN.\n\n    this.maxTokenType = maxTokenType;\n    this.states = [];\n    /**\n     * Each subrule/rule is a decision point and we must track them so we\n     * can go back later and build DFA predictors for them.  This includes\n     * all the rules, subrules, optional blocks, ()+, ()* etc...\n     */\n\n    this.decisionToState = []; // Maps from rule index to starting state number.\n\n    this.ruleToStartState = []; // Maps from rule index to stop state number.\n\n    this.ruleToStopState = null;\n    this.modeNameToStartState = {};\n    /**\n     * For lexer ATNs, this maps the rule index to the resulting token type.\n     * For parser ATNs, this maps the rule index to the generated bypass token\n     * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n     * deserialization option was specified; otherwise, this is {@code null}\n     */\n\n    this.ruleToTokenType = null;\n    /**\n     * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n     * be referenced by action transitions in the ATN\n     */\n\n    this.lexerActions = null;\n    this.modeToStartState = [];\n  }\n  /**\n   * Compute the set of valid tokens that can occur starting in state {@code s}.\n   * If {@code ctx} is null, the set of tokens will not include what can follow\n   * the rule surrounding {@code s}. In other words, the set will be\n   * restricted to tokens reachable staying within {@code s}'s rule\n   */\n\n\n  nextTokensInContext(s, ctx) {\n    const anal = new LL1Analyzer(this);\n    return anal.LOOK(s, null, ctx);\n  }\n  /**\n   * Compute the set of valid tokens that can occur starting in {@code s} and\n   * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n   * rule\n   */\n\n\n  nextTokensNoContext(s) {\n    if (s.nextTokenWithinRule !== null) {\n      return s.nextTokenWithinRule;\n    }\n\n    s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n    s.nextTokenWithinRule.readOnly = true;\n    return s.nextTokenWithinRule;\n  }\n\n  nextTokens(s, ctx) {\n    if (ctx === undefined) {\n      return this.nextTokensNoContext(s);\n    } else {\n      return this.nextTokensInContext(s, ctx);\n    }\n  }\n\n  addState(state) {\n    if (state !== null) {\n      state.atn = this;\n      state.stateNumber = this.states.length;\n    }\n\n    this.states.push(state);\n  }\n\n  removeState(state) {\n    this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n  }\n\n  defineDecisionState(s) {\n    this.decisionToState.push(s);\n    s.decision = this.decisionToState.length - 1;\n    return s.decision;\n  }\n\n  getDecisionState(decision) {\n    if (this.decisionToState.length === 0) {\n      return null;\n    } else {\n      return this.decisionToState[decision];\n    }\n  }\n  /**\n   * Computes the set of input symbols which could follow ATN state number\n   * {@code stateNumber} in the specified full {@code context}. This method\n   * considers the complete parser context, but does not evaluate semantic\n   * predicates (i.e. all predicates encountered during the calculation are\n   * assumed true). If a path in the ATN exists from the starting state to the\n   * {@link RuleStopState} of the outermost context without matching any\n   * symbols, {@link Token//EOF} is added to the returned set.\n   *\n   * <p>If {@code context} is {@code null}, it is treated as\n   * {@link ParserRuleContext//EMPTY}.</p>\n   *\n   * @param stateNumber the ATN state number\n   * @param ctx the full parse context\n   *\n   * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n   * specified state in the specified context.\n   *\n   * @throws IllegalArgumentException if the ATN does not contain a state with\n   * number {@code stateNumber}\n   */\n\n\n  getExpectedTokens(stateNumber, ctx) {\n    if (stateNumber < 0 || stateNumber >= this.states.length) {\n      throw \"Invalid state number.\";\n    }\n\n    const s = this.states[stateNumber];\n    let following = this.nextTokens(s);\n\n    if (!following.contains(Token.EPSILON)) {\n      return following;\n    }\n\n    const expected = new IntervalSet();\n    expected.addSet(following);\n    expected.removeOne(Token.EPSILON);\n\n    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n      const invokingState = this.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      following = this.nextTokens(rt.followState);\n      expected.addSet(following);\n      expected.removeOne(Token.EPSILON);\n      ctx = ctx.parentCtx;\n    }\n\n    if (following.contains(Token.EPSILON)) {\n      expected.addOne(Token.EOF);\n    }\n\n    return expected;\n  }\n\n}\n\nATN.INVALID_ALT_NUMBER = 0;\nmodule.exports = ATN;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ATN.js"],"names":["LL1Analyzer","require","IntervalSet","Token","ATN","constructor","grammarType","maxTokenType","states","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","ruleToTokenType","lexerActions","modeToStartState","nextTokensInContext","s","ctx","anal","LOOK","nextTokensNoContext","nextTokenWithinRule","readOnly","nextTokens","undefined","addState","state","atn","stateNumber","length","push","removeState","defineDecisionState","decision","getDecisionState","getExpectedTokens","following","contains","EPSILON","expected","addSet","removeOne","invokingState","rt","transitions","followState","parentCtx","addOne","EOF","INVALID_ALT_NUMBER","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,kBAAD,CAA3B;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAgBD,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAM;AAACE,EAAAA;AAAD,IAAUF,OAAO,CAAC,YAAD,CAAvB;;AAEA,MAAMG,GAAN,CAAU;AAENC,EAAAA,WAAW,CAACC,WAAD,EAAeC,YAAf,EAA6B;AACpC;AACR;AACA;AACA;AACQ,SAAKD,WAAL,GAAmBA,WAAnB,CALoC,CAMpC;;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,MAAL,GAAc,EAAd;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,EAAvB,CAdoC,CAepC;;AACA,SAAKC,gBAAL,GAAwB,EAAxB,CAhBoC,CAiBpC;;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,oBAAL,GAA4B,EAA5B;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,IAAvB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,mBAAmB,CAACC,CAAD,EAAIC,GAAJ,EAAS;AACxB,UAAMC,IAAI,GAAG,IAAInB,WAAJ,CAAgB,IAAhB,CAAb;AACA,WAAOmB,IAAI,CAACC,IAAL,CAAUH,CAAV,EAAa,IAAb,EAAmBC,GAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIG,EAAAA,mBAAmB,CAACJ,CAAD,EAAI;AACnB,QAAIA,CAAC,CAACK,mBAAF,KAA0B,IAA9B,EAAqC;AACjC,aAAOL,CAAC,CAACK,mBAAT;AACH;;AACDL,IAAAA,CAAC,CAACK,mBAAF,GAAwB,KAAKN,mBAAL,CAAyBC,CAAzB,EAA4B,IAA5B,CAAxB;AACAA,IAAAA,CAAC,CAACK,mBAAF,CAAsBC,QAAtB,GAAiC,IAAjC;AACA,WAAON,CAAC,CAACK,mBAAT;AACH;;AAEDE,EAAAA,UAAU,CAACP,CAAD,EAAIC,GAAJ,EAAS;AACf,QAAKA,GAAG,KAAGO,SAAX,EAAuB;AACnB,aAAO,KAAKJ,mBAAL,CAAyBJ,CAAzB,CAAP;AACH,KAFD,MAEO;AACH,aAAO,KAAKD,mBAAL,CAAyBC,CAAzB,EAA4BC,GAA5B,CAAP;AACH;AACJ;;AAEDQ,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,QAAKA,KAAK,KAAK,IAAf,EAAsB;AAClBA,MAAAA,KAAK,CAACC,GAAN,GAAY,IAAZ;AACAD,MAAAA,KAAK,CAACE,WAAN,GAAoB,KAAKrB,MAAL,CAAYsB,MAAhC;AACH;;AACD,SAAKtB,MAAL,CAAYuB,IAAZ,CAAiBJ,KAAjB;AACH;;AAEDK,EAAAA,WAAW,CAACL,KAAD,EAAQ;AACf,SAAKnB,MAAL,CAAYmB,KAAK,CAACE,WAAlB,IAAiC,IAAjC,CADe,CACwB;AAC1C;;AAEDI,EAAAA,mBAAmB,CAAChB,CAAD,EAAI;AACnB,SAAKR,eAAL,CAAqBsB,IAArB,CAA0Bd,CAA1B;AACAA,IAAAA,CAAC,CAACiB,QAAF,GAAa,KAAKzB,eAAL,CAAqBqB,MAArB,GAA4B,CAAzC;AACA,WAAOb,CAAC,CAACiB,QAAT;AACH;;AAEDC,EAAAA,gBAAgB,CAACD,QAAD,EAAW;AACvB,QAAI,KAAKzB,eAAL,CAAqBqB,MAArB,KAA8B,CAAlC,EAAqC;AACjC,aAAO,IAAP;AACH,KAFD,MAEO;AACH,aAAO,KAAKrB,eAAL,CAAqByB,QAArB,CAAP;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,iBAAiB,CAACP,WAAD,EAAcX,GAAd,EAAoB;AACjC,QAAKW,WAAW,GAAG,CAAd,IAAmBA,WAAW,IAAI,KAAKrB,MAAL,CAAYsB,MAAnD,EAA4D;AACxD,YAAM,uBAAN;AACH;;AACD,UAAMb,CAAC,GAAG,KAAKT,MAAL,CAAYqB,WAAZ,CAAV;AACA,QAAIQ,SAAS,GAAG,KAAKb,UAAL,CAAgBP,CAAhB,CAAhB;;AACA,QAAI,CAACoB,SAAS,CAACC,QAAV,CAAmBnC,KAAK,CAACoC,OAAzB,CAAL,EAAwC;AACpC,aAAOF,SAAP;AACH;;AACD,UAAMG,QAAQ,GAAG,IAAItC,WAAJ,EAAjB;AACAsC,IAAAA,QAAQ,CAACC,MAAT,CAAgBJ,SAAhB;AACAG,IAAAA,QAAQ,CAACE,SAAT,CAAmBvC,KAAK,CAACoC,OAAzB;;AACA,WAAOrB,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACyB,aAAJ,IAAqB,CAArC,IAA0CN,SAAS,CAACC,QAAV,CAAmBnC,KAAK,CAACoC,OAAzB,CAAjD,EAAoF;AAChF,YAAMI,aAAa,GAAG,KAAKnC,MAAL,CAAYU,GAAG,CAACyB,aAAhB,CAAtB;AACA,YAAMC,EAAE,GAAGD,aAAa,CAACE,WAAd,CAA0B,CAA1B,CAAX;AACAR,MAAAA,SAAS,GAAG,KAAKb,UAAL,CAAgBoB,EAAE,CAACE,WAAnB,CAAZ;AACAN,MAAAA,QAAQ,CAACC,MAAT,CAAgBJ,SAAhB;AACAG,MAAAA,QAAQ,CAACE,SAAT,CAAmBvC,KAAK,CAACoC,OAAzB;AACArB,MAAAA,GAAG,GAAGA,GAAG,CAAC6B,SAAV;AACH;;AACD,QAAIV,SAAS,CAACC,QAAV,CAAmBnC,KAAK,CAACoC,OAAzB,CAAJ,EAAuC;AACnCC,MAAAA,QAAQ,CAACQ,MAAT,CAAgB7C,KAAK,CAAC8C,GAAtB;AACH;;AACD,WAAOT,QAAP;AACH;;AA7IK;;AAgJVpC,GAAG,CAAC8C,kBAAJ,GAAyB,CAAzB;AAEAC,MAAM,CAACC,OAAP,GAAiBhD,GAAjB","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LL1Analyzer = require('./../LL1Analyzer');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Token} = require('./../Token');\n\nclass ATN {\n\n    constructor(grammarType , maxTokenType) {\n        /**\n         * Used for runtime deserialization of ATNs from strings\n         * The type of the ATN.\n        */\n        this.grammarType = grammarType;\n        // The maximum value for any symbol recognized by a transition in the ATN.\n        this.maxTokenType = maxTokenType;\n        this.states = [];\n        /**\n         * Each subrule/rule is a decision point and we must track them so we\n         * can go back later and build DFA predictors for them.  This includes\n         * all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        // Maps from rule index to starting state number.\n        this.ruleToStartState = [];\n        // Maps from rule index to stop state number.\n        this.ruleToStopState = null;\n        this.modeNameToStartState = {};\n        /**\n         * For lexer ATNs, this maps the rule index to the resulting token type.\n         * For parser ATNs, this maps the rule index to the generated bypass token\n         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n         * deserialization option was specified; otherwise, this is {@code null}\n         */\n        this.ruleToTokenType = null;\n        /**\n         * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n         * be referenced by action transitions in the ATN\n         */\n        this.lexerActions = null;\n        this.modeToStartState = [];\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in state {@code s}.\n     * If {@code ctx} is null, the set of tokens will not include what can follow\n     * the rule surrounding {@code s}. In other words, the set will be\n     * restricted to tokens reachable staying within {@code s}'s rule\n     */\n    nextTokensInContext(s, ctx) {\n        const anal = new LL1Analyzer(this);\n        return anal.LOOK(s, null, ctx);\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in {@code s} and\n     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n     * rule\n     */\n    nextTokensNoContext(s) {\n        if (s.nextTokenWithinRule !== null ) {\n            return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n        s.nextTokenWithinRule.readOnly = true;\n        return s.nextTokenWithinRule;\n    }\n\n    nextTokens(s, ctx) {\n        if ( ctx===undefined ) {\n            return this.nextTokensNoContext(s);\n        } else {\n            return this.nextTokensInContext(s, ctx);\n        }\n    }\n\n    addState(state) {\n        if ( state !== null ) {\n            state.atn = this;\n            state.stateNumber = this.states.length;\n        }\n        this.states.push(state);\n    }\n\n    removeState(state) {\n        this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n    }\n\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length-1;\n        return s.decision;\n    }\n\n    getDecisionState(decision) {\n        if (this.decisionToState.length===0) {\n            return null;\n        } else {\n            return this.decisionToState[decision];\n        }\n    }\n\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * {@code stateNumber} in the specified full {@code context}. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token//EOF} is added to the returned set.\n     *\n     * <p>If {@code context} is {@code null}, it is treated as\n     * {@link ParserRuleContext//EMPTY}.</p>\n     *\n     * @param stateNumber the ATN state number\n     * @param ctx the full parse context\n     *\n     * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     *\n     * @throws IllegalArgumentException if the ATN does not contain a state with\n     * number {@code stateNumber}\n     */\n    getExpectedTokens(stateNumber, ctx ) {\n        if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n            throw(\"Invalid state number.\");\n        }\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token.EPSILON)) {\n            return following;\n        }\n        const expected = new IntervalSet();\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne(Token.EPSILON);\n            ctx = ctx.parentCtx;\n        }\n        if (following.contains(Token.EPSILON)) {\n            expected.addOne(Token.EOF);\n        }\n        return expected;\n    }\n}\n\nATN.INVALID_ALT_NUMBER = 0;\n\nmodule.exports = ATN;\n"]},"metadata":{},"sourceType":"script"}