{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  Token\n} = require('./Token');\n\nconst {\n  ParseTreeListener,\n  TerminalNode,\n  ErrorNode\n} = require('./tree/Tree');\n\nconst Recognizer = require('./Recognizer');\n\nconst {\n  DefaultErrorStrategy\n} = require('./error/ErrorStrategy');\n\nconst ATNDeserializer = require('./atn/ATNDeserializer');\n\nconst ATNDeserializationOptions = require('./atn/ATNDeserializationOptions');\n\nconst Lexer = require('./Lexer');\n\nclass TraceListener extends ParseTreeListener {\n  constructor(parser) {\n    super();\n    this.parser = parser;\n  }\n\n  enterEveryRule(ctx) {\n    console.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n  }\n\n  visitTerminal(node) {\n    console.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n  }\n\n  exitEveryRule(ctx) {\n    console.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n  }\n\n}\n\nclass Parser extends Recognizer {\n  /**\n   * this is all the parsing support code essentially; most of it is error\n   * recovery stuff.\n   */\n  constructor(input) {\n    super(); // The input stream.\n\n    this._input = null;\n    /**\n     * The error handling strategy for the parser. The default value is a new\n     * instance of {@link DefaultErrorStrategy}.\n     */\n\n    this._errHandler = new DefaultErrorStrategy();\n    this._precedenceStack = [];\n\n    this._precedenceStack.push(0);\n    /**\n     * The {@link ParserRuleContext} object for the currently executing rule.\n     * this is always non-null during the parsing process.\n     */\n\n\n    this._ctx = null;\n    /**\n     * Specifies whether or not the parser should construct a parse tree during\n     * the parsing process. The default value is {@code true}.\n     */\n\n    this.buildParseTrees = true;\n    /**\n     * When {@link //setTrace}{@code (true)} is called, a reference to the\n     * {@link TraceListener} is stored here so it can be easily removed in a\n     * later call to {@link //setTrace}{@code (false)}. The listener itself is\n     * implemented as a parser listener so this field is not directly used by\n     * other parser methods.\n     */\n\n    this._tracer = null;\n    /**\n     * The list of {@link ParseTreeListener} listeners registered to receive\n     * events during the parse.\n     */\n\n    this._parseListeners = null;\n    /**\n     * The number of syntax errors reported during parsing. this value is\n     * incremented each time {@link //notifyErrorListeners} is called.\n     */\n\n    this._syntaxErrors = 0;\n    this.setInputStream(input);\n  } // reset the parser's state\n\n\n  reset() {\n    if (this._input !== null) {\n      this._input.seek(0);\n    }\n\n    this._errHandler.reset(this);\n\n    this._ctx = null;\n    this._syntaxErrors = 0;\n    this.setTrace(false);\n    this._precedenceStack = [];\n\n    this._precedenceStack.push(0);\n\n    if (this._interp !== null) {\n      this._interp.reset();\n    }\n  }\n  /**\n   * Match current input symbol against {@code ttype}. If the symbol type\n   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n   * called to complete the match process.\n   *\n   * <p>If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link //getBuildParseTree} is\n   * {@code true} and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n   *\n   * @param ttype the token type to match\n   * @return the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * {@code ttype} and the error strategy could not recover from the\n   * mismatched symbol\n   */\n\n\n  match(ttype) {\n    let t = this.getCurrentToken();\n\n    if (t.type === ttype) {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    } else {\n      t = this._errHandler.recoverInline(this);\n\n      if (this.buildParseTrees && t.tokenIndex === -1) {\n        // we must have conjured up a new token during single token\n        // insertion\n        // if it's not the current symbol\n        this._ctx.addErrorNode(t);\n      }\n    }\n\n    return t;\n  }\n  /**\n   * Match current input symbol as a wildcard. If the symbol type matches\n   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n   * and {@link //consume} are called to complete the match process.\n   *\n   * <p>If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link //getBuildParseTree} is\n   * {@code true} and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n   *\n   * @return the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * a wildcard and the error strategy could not recover from the mismatched\n   * symbol\n   */\n\n\n  matchWildcard() {\n    let t = this.getCurrentToken();\n\n    if (t.type > 0) {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    } else {\n      t = this._errHandler.recoverInline(this);\n\n      if (this._buildParseTrees && t.tokenIndex === -1) {\n        // we must have conjured up a new token during single token\n        // insertion\n        // if it's not the current symbol\n        this._ctx.addErrorNode(t);\n      }\n    }\n\n    return t;\n  }\n\n  getParseListeners() {\n    return this._parseListeners || [];\n  }\n  /**\n   * Registers {@code listener} to receive events during the parsing process.\n   *\n   * <p>To support output-preserving grammar transformations (including but not\n   * limited to left-recursion removal, automated left-factoring, and\n   * optimized code generation), calls to listener methods during the parse\n   * may differ substantially from calls made by\n   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n   * particular, rule entry and exit events may occur in a different order\n   * during the parse than after the parser. In addition, calls to certain\n   * rule entry methods may be omitted.</p>\n   *\n   * <p>With the following specific exceptions, calls to listener events are\n   * <em>deterministic</em>, i.e. for identical input the calls to listener\n   * methods will be the same.</p>\n   *\n   * <ul>\n   * <li>Alterations to the grammar used to generate code may change the\n   * behavior of the listener calls.</li>\n   * <li>Alterations to the command line options passed to ANTLR 4 when\n   * generating the parser may change the behavior of the listener calls.</li>\n   * <li>Changing the version of the ANTLR Tool used to generate the parser\n   * may change the behavior of the listener calls.</li>\n   * </ul>\n   *\n   * @param listener the listener to add\n   *\n   * @throws NullPointerException if {@code} listener is {@code null}\n   */\n\n\n  addParseListener(listener) {\n    if (listener === null) {\n      throw \"listener\";\n    }\n\n    if (this._parseListeners === null) {\n      this._parseListeners = [];\n    }\n\n    this._parseListeners.push(listener);\n  }\n  /**\n   * Remove {@code listener} from the list of parse listeners.\n   *\n   * <p>If {@code listener} is {@code null} or has not been added as a parse\n   * listener, this method does nothing.</p>\n   * @param listener the listener to remove\n   */\n\n\n  removeParseListener(listener) {\n    if (this._parseListeners !== null) {\n      const idx = this._parseListeners.indexOf(listener);\n\n      if (idx >= 0) {\n        this._parseListeners.splice(idx, 1);\n      }\n\n      if (this._parseListeners.length === 0) {\n        this._parseListeners = null;\n      }\n    }\n  } // Remove all parse listeners.\n\n\n  removeParseListeners() {\n    this._parseListeners = null;\n  } // Notify any parse listeners of an enter rule event.\n\n\n  triggerEnterRuleEvent() {\n    if (this._parseListeners !== null) {\n      const ctx = this._ctx;\n\n      this._parseListeners.forEach(function (listener) {\n        listener.enterEveryRule(ctx);\n        ctx.enterRule(listener);\n      });\n    }\n  }\n  /**\n   * Notify any parse listeners of an exit rule event.\n   * @see //addParseListener\n   */\n\n\n  triggerExitRuleEvent() {\n    if (this._parseListeners !== null) {\n      // reverse order walk of listeners\n      const ctx = this._ctx;\n\n      this._parseListeners.slice(0).reverse().forEach(function (listener) {\n        ctx.exitRule(listener);\n        listener.exitEveryRule(ctx);\n      });\n    }\n  }\n\n  getTokenFactory() {\n    return this._input.tokenSource._factory;\n  } // Tell our token source and error strategy about a new way to create tokens.\n\n\n  setTokenFactory(factory) {\n    this._input.tokenSource._factory = factory;\n  }\n  /**\n   * The ATN with bypass alternatives is expensive to create so we create it\n   * lazily.\n   *\n   * @throws UnsupportedOperationException if the current parser does not\n   * implement the {@link //getSerializedATN()} method.\n   */\n\n\n  getATNWithBypassAlts() {\n    const serializedAtn = this.getSerializedATN();\n\n    if (serializedAtn === null) {\n      throw \"The current parser does not support an ATN with bypass alternatives.\";\n    }\n\n    let result = this.bypassAltsAtnCache[serializedAtn];\n\n    if (result === null) {\n      const deserializationOptions = new ATNDeserializationOptions();\n      deserializationOptions.generateRuleBypassTransitions = true;\n      result = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);\n      this.bypassAltsAtnCache[serializedAtn] = result;\n    }\n\n    return result;\n  }\n  /**\n   * The preferred method of getting a tree pattern. For example, here's a\n   * sample use:\n   *\n   * <pre>\n   * ParseTree t = parser.expr();\n   * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n   * MyParser.RULE_expr);\n   * ParseTreeMatch m = p.match(t);\n   * String id = m.get(\"ID\");\n   * </pre>\n   */\n\n\n  compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n    lexer = lexer || null;\n\n    if (lexer === null) {\n      if (this.getTokenStream() !== null) {\n        const tokenSource = this.getTokenStream().tokenSource;\n\n        if (tokenSource instanceof Lexer) {\n          lexer = tokenSource;\n        }\n      }\n    }\n\n    if (lexer === null) {\n      throw \"Parser can't discover a lexer to use\";\n    }\n\n    const m = new ParseTreePatternMatcher(lexer, this);\n    return m.compile(pattern, patternRuleIndex);\n  }\n\n  getInputStream() {\n    return this.getTokenStream();\n  }\n\n  setInputStream(input) {\n    this.setTokenStream(input);\n  }\n\n  getTokenStream() {\n    return this._input;\n  } // Set the token stream and reset the parser.\n\n\n  setTokenStream(input) {\n    this._input = null;\n    this.reset();\n    this._input = input;\n  }\n  /**\n   * Match needs to return the current input symbol, which gets put\n   * into the label for the associated token ref; e.g., x=ID.\n   */\n\n\n  getCurrentToken() {\n    return this._input.LT(1);\n  }\n\n  notifyErrorListeners(msg, offendingToken, err) {\n    offendingToken = offendingToken || null;\n    err = err || null;\n\n    if (offendingToken === null) {\n      offendingToken = this.getCurrentToken();\n    }\n\n    this._syntaxErrors += 1;\n    const line = offendingToken.line;\n    const column = offendingToken.column;\n    const listener = this.getErrorListenerDispatch();\n    listener.syntaxError(this, offendingToken, line, column, msg, err);\n  }\n  /**\n   * Consume and return the {@linkplain //getCurrentToken current symbol}.\n   *\n   * <p>E.g., given the following input with {@code A} being the current\n   * lookahead symbol, this function moves the cursor to {@code B} and returns\n   * {@code A}.</p>\n   *\n   * <pre>\n   * A B\n   * ^\n   * </pre>\n   *\n   * If the parser is not in error recovery mode, the consumed symbol is added\n   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n   * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n   * added to the parse tree using\n   * {@link ParserRuleContext//addErrorNode(Token)}, and\n   * {@link ParseTreeListener//visitErrorNode} is called on any parse\n   * listeners.\n   */\n\n\n  consume() {\n    const o = this.getCurrentToken();\n\n    if (o.type !== Token.EOF) {\n      this.getInputStream().consume();\n    }\n\n    const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\n    if (this.buildParseTrees || hasListener) {\n      let node;\n\n      if (this._errHandler.inErrorRecoveryMode(this)) {\n        node = this._ctx.addErrorNode(o);\n      } else {\n        node = this._ctx.addTokenNode(o);\n      }\n\n      node.invokingState = this.state;\n\n      if (hasListener) {\n        this._parseListeners.forEach(function (listener) {\n          if (node instanceof ErrorNode || node.isErrorNode !== undefined && node.isErrorNode()) {\n            listener.visitErrorNode(node);\n          } else if (node instanceof TerminalNode) {\n            listener.visitTerminal(node);\n          }\n        });\n      }\n    }\n\n    return o;\n  }\n\n  addContextToParseTree() {\n    // add current context to parent if we have a parent\n    if (this._ctx.parentCtx !== null) {\n      this._ctx.parentCtx.addChild(this._ctx);\n    }\n  }\n  /**\n   * Always called by generated parsers upon entry to a rule. Access field\n   * {@link //_ctx} get the current context.\n   */\n\n\n  enterRule(localctx, state, ruleIndex) {\n    this.state = state;\n    this._ctx = localctx;\n    this._ctx.start = this._input.LT(1);\n\n    if (this.buildParseTrees) {\n      this.addContextToParseTree();\n    }\n\n    this.triggerEnterRuleEvent();\n  }\n\n  exitRule() {\n    this._ctx.stop = this._input.LT(-1); // trigger event on _ctx, before it reverts to parent\n\n    this.triggerExitRuleEvent();\n    this.state = this._ctx.invokingState;\n    this._ctx = this._ctx.parentCtx;\n  }\n\n  enterOuterAlt(localctx, altNum) {\n    localctx.setAltNumber(altNum); // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n\n    if (this.buildParseTrees && this._ctx !== localctx) {\n      if (this._ctx.parentCtx !== null) {\n        this._ctx.parentCtx.removeLastChild();\n\n        this._ctx.parentCtx.addChild(localctx);\n      }\n    }\n\n    this._ctx = localctx;\n  }\n  /**\n   * Get the precedence level for the top-most precedence rule.\n   *\n   * @return The precedence level for the top-most precedence rule, or -1 if\n   * the parser context is not nested within a precedence rule.\n   */\n\n\n  getPrecedence() {\n    if (this._precedenceStack.length === 0) {\n      return -1;\n    } else {\n      return this._precedenceStack[this._precedenceStack.length - 1];\n    }\n  }\n\n  enterRecursionRule(localctx, state, ruleIndex, precedence) {\n    this.state = state;\n\n    this._precedenceStack.push(precedence);\n\n    this._ctx = localctx;\n    this._ctx.start = this._input.LT(1);\n    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n  } // Like {@link //enterRule} but for recursive rules.\n\n\n  pushNewRecursionContext(localctx, state, ruleIndex) {\n    const previous = this._ctx;\n    previous.parentCtx = localctx;\n    previous.invokingState = state;\n    previous.stop = this._input.LT(-1);\n    this._ctx = localctx;\n    this._ctx.start = previous.start;\n\n    if (this.buildParseTrees) {\n      this._ctx.addChild(previous);\n    }\n\n    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n  }\n\n  unrollRecursionContexts(parentCtx) {\n    this._precedenceStack.pop();\n\n    this._ctx.stop = this._input.LT(-1);\n    const retCtx = this._ctx; // save current ctx (return value)\n    // unroll so _ctx is as it was before call to recursive method\n\n    const parseListeners = this.getParseListeners();\n\n    if (parseListeners !== null && parseListeners.length > 0) {\n      while (this._ctx !== parentCtx) {\n        this.triggerExitRuleEvent();\n        this._ctx = this._ctx.parentCtx;\n      }\n    } else {\n      this._ctx = parentCtx;\n    } // hook into tree\n\n\n    retCtx.parentCtx = parentCtx;\n\n    if (this.buildParseTrees && parentCtx !== null) {\n      // add return ctx into invoking rule's tree\n      parentCtx.addChild(retCtx);\n    }\n  }\n\n  getInvokingContext(ruleIndex) {\n    let ctx = this._ctx;\n\n    while (ctx !== null) {\n      if (ctx.ruleIndex === ruleIndex) {\n        return ctx;\n      }\n\n      ctx = ctx.parentCtx;\n    }\n\n    return null;\n  }\n\n  precpred(localctx, precedence) {\n    return precedence >= this._precedenceStack[this._precedenceStack.length - 1];\n  }\n\n  inContext(context) {\n    // TODO: useful in parser?\n    return false;\n  }\n  /**\n   * Checks whether or not {@code symbol} can follow the current state in the\n   * ATN. The behavior of this method is equivalent to the following, but is\n   * implemented such that the complete context-sensitive follow set does not\n   * need to be explicitly constructed.\n   *\n   * <pre>\n   * return getExpectedTokens().contains(symbol);\n   * </pre>\n   *\n   * @param symbol the symbol type to check\n   * @return {@code true} if {@code symbol} can follow the current state in\n   * the ATN, otherwise {@code false}.\n   */\n\n\n  isExpectedToken(symbol) {\n    const atn = this._interp.atn;\n    let ctx = this._ctx;\n    const s = atn.states[this.state];\n    let following = atn.nextTokens(s);\n\n    if (following.contains(symbol)) {\n      return true;\n    }\n\n    if (!following.contains(Token.EPSILON)) {\n      return false;\n    }\n\n    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n      const invokingState = atn.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      following = atn.nextTokens(rt.followState);\n\n      if (following.contains(symbol)) {\n        return true;\n      }\n\n      ctx = ctx.parentCtx;\n    }\n\n    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Computes the set of input symbols which could follow the current parser\n   * state and context, as given by {@link //getState} and {@link //getContext},\n   * respectively.\n   *\n   * @see ATN//getExpectedTokens(int, RuleContext)\n   */\n\n\n  getExpectedTokens() {\n    return this._interp.atn.getExpectedTokens(this.state, this._ctx);\n  }\n\n  getExpectedTokensWithinCurrentRule() {\n    const atn = this._interp.atn;\n    const s = atn.states[this.state];\n    return atn.nextTokens(s);\n  } // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\n\n  getRuleIndex(ruleName) {\n    const ruleIndex = this.getRuleIndexMap()[ruleName];\n\n    if (ruleIndex !== null) {\n      return ruleIndex;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Return List&lt;String&gt; of the rule names in your parser instance\n   * leading up to a call to the current rule. You could override if\n   * you want more details such as the file/line info of where\n   * in the ATN a rule is invoked.\n   *\n   * this is very useful for error messages.\n   */\n\n\n  getRuleInvocationStack(p) {\n    p = p || null;\n\n    if (p === null) {\n      p = this._ctx;\n    }\n\n    const stack = [];\n\n    while (p !== null) {\n      // compute what follows who invoked us\n      const ruleIndex = p.ruleIndex;\n\n      if (ruleIndex < 0) {\n        stack.push(\"n/a\");\n      } else {\n        stack.push(this.ruleNames[ruleIndex]);\n      }\n\n      p = p.parentCtx;\n    }\n\n    return stack;\n  } // For debugging and other purposes.\n\n\n  getDFAStrings() {\n    return this._interp.decisionToDFA.toString();\n  } // For debugging and other purposes.\n\n\n  dumpDFA() {\n    let seenOne = false;\n\n    for (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n      const dfa = this._interp.decisionToDFA[i];\n\n      if (dfa.states.length > 0) {\n        if (seenOne) {\n          console.log();\n        }\n\n        this.printer.println(\"Decision \" + dfa.decision + \":\");\n        this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n        seenOne = true;\n      }\n    }\n  }\n  /*\n  \t\"\t\t\tprinter = function() {\\r\\n\" +\n  \t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n  \t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n  \t\"\t\t\t};\\r\\n\" +\n  \t*/\n\n\n  getSourceName() {\n    return this._input.sourceName;\n  }\n  /**\n   * During a parse is sometimes useful to listen in on the rule entry and exit\n   * events as well as token matches. this is for quick and dirty debugging.\n   */\n\n\n  setTrace(trace) {\n    if (!trace) {\n      this.removeParseListener(this._tracer);\n      this._tracer = null;\n    } else {\n      if (this._tracer !== null) {\n        this.removeParseListener(this._tracer);\n      }\n\n      this._tracer = new TraceListener(this);\n      this.addParseListener(this._tracer);\n    }\n  }\n\n}\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\n\n\nParser.bypassAltsAtnCache = {};\nmodule.exports = Parser;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/Parser.js"],"names":["Token","require","ParseTreeListener","TerminalNode","ErrorNode","Recognizer","DefaultErrorStrategy","ATNDeserializer","ATNDeserializationOptions","Lexer","TraceListener","constructor","parser","enterEveryRule","ctx","console","log","ruleNames","ruleIndex","_input","LT","text","visitTerminal","node","symbol","_ctx","exitEveryRule","Parser","input","_errHandler","_precedenceStack","push","buildParseTrees","_tracer","_parseListeners","_syntaxErrors","setInputStream","reset","seek","setTrace","_interp","match","ttype","t","getCurrentToken","type","reportMatch","consume","recoverInline","tokenIndex","addErrorNode","matchWildcard","_buildParseTrees","getParseListeners","addParseListener","listener","removeParseListener","idx","indexOf","splice","length","removeParseListeners","triggerEnterRuleEvent","forEach","enterRule","triggerExitRuleEvent","slice","reverse","exitRule","getTokenFactory","tokenSource","_factory","setTokenFactory","factory","getATNWithBypassAlts","serializedAtn","getSerializedATN","result","bypassAltsAtnCache","deserializationOptions","generateRuleBypassTransitions","deserialize","compileParseTreePattern","pattern","patternRuleIndex","lexer","getTokenStream","m","ParseTreePatternMatcher","compile","getInputStream","setTokenStream","notifyErrorListeners","msg","offendingToken","err","line","column","getErrorListenerDispatch","syntaxError","o","EOF","hasListener","inErrorRecoveryMode","addTokenNode","invokingState","state","isErrorNode","undefined","visitErrorNode","addContextToParseTree","parentCtx","addChild","localctx","start","stop","enterOuterAlt","altNum","setAltNumber","removeLastChild","getPrecedence","enterRecursionRule","precedence","pushNewRecursionContext","previous","unrollRecursionContexts","pop","retCtx","parseListeners","getInvokingContext","precpred","inContext","context","isExpectedToken","atn","s","states","following","nextTokens","contains","EPSILON","rt","transitions","followState","getExpectedTokens","getExpectedTokensWithinCurrentRule","getRuleIndex","ruleName","getRuleIndexMap","getRuleInvocationStack","p","stack","getDFAStrings","decisionToDFA","toString","dumpDFA","seenOne","i","dfa","printer","println","decision","print","literalNames","symbolicNames","getSourceName","sourceName","trace","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ParseTreeListener, TerminalNode, ErrorNode} = require('./tree/Tree');\nconst Recognizer = require('./Recognizer');\nconst {DefaultErrorStrategy} = require('./error/ErrorStrategy');\nconst ATNDeserializer = require('./atn/ATNDeserializer');\nconst ATNDeserializationOptions = require('./atn/ATNDeserializationOptions');\nconst Lexer = require('./Lexer');\n\nclass TraceListener extends ParseTreeListener {\n\tconstructor(parser) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t}\n\n\tenterEveryRule(ctx) {\n\t\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n\n\tvisitTerminal(node) {\n\t\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n\t}\n\n\texitEveryRule(ctx) {\n\t\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n}\n\nclass Parser extends Recognizer {\n\t/**\n\t * this is all the parsing support code essentially; most of it is error\n\t * recovery stuff.\n\t */\n\tconstructor(input) {\n\t\tsuper();\n\t\t// The input stream.\n\t\tthis._input = null;\n\t\t/**\n\t\t * The error handling strategy for the parser. The default value is a new\n\t\t * instance of {@link DefaultErrorStrategy}.\n\t\t */\n\t\tthis._errHandler = new DefaultErrorStrategy();\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\t/**\n\t\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t\t * this is always non-null during the parsing process.\n\t\t */\n\t\tthis._ctx = null;\n\t\t/**\n\t\t * Specifies whether or not the parser should construct a parse tree during\n\t\t * the parsing process. The default value is {@code true}.\n\t\t */\n\t\tthis.buildParseTrees = true;\n\t\t/**\n\t\t * When {@link //setTrace}{@code (true)} is called, a reference to the\n\t\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t\t * later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t\t * implemented as a parser listener so this field is not directly used by\n\t\t * other parser methods.\n\t\t */\n\t\tthis._tracer = null;\n\t\t/**\n\t\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t\t * events during the parse.\n\t\t */\n\t\tthis._parseListeners = null;\n\t\t/**\n\t\t * The number of syntax errors reported during parsing. this value is\n\t\t * incremented each time {@link //notifyErrorListeners} is called.\n\t\t */\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setInputStream(input);\n\t}\n\n\t// reset the parser's state\n\treset() {\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0);\n\t\t}\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = null;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setTrace(false);\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\tif (this._interp !== null) {\n\t\t\tthis._interp.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against {@code ttype}. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n\t * called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @param ttype the token type to match\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * {@code ttype} and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\tmatch(ttype) {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type === ttype) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n\t * and {@link //consume} are called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\tmatchWildcard() {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tgetParseListeners() {\n\t\treturn this._parseListeners || [];\n\t}\n\n\t/**\n\t * Registers {@code listener} to receive events during the parsing process.\n\t *\n\t * <p>To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.</p>\n\t *\n\t * <p>With the following specific exceptions, calls to listener events are\n\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n\t * methods will be the same.</p>\n\t *\n\t * <ul>\n\t * <li>Alterations to the grammar used to generate code may change the\n\t * behavior of the listener calls.</li>\n\t * <li>Alterations to the command line options passed to ANTLR 4 when\n\t * generating the parser may change the behavior of the listener calls.</li>\n\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n\t * may change the behavior of the listener calls.</li>\n\t * </ul>\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws NullPointerException if {@code} listener is {@code null}\n\t */\n\taddParseListener(listener) {\n\t\tif (listener === null) {\n\t\t\tthrow \"listener\";\n\t\t}\n\t\tif (this._parseListeners === null) {\n\t\t\tthis._parseListeners = [];\n\t\t}\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove {@code listener} from the list of parse listeners.\n\t *\n\t * <p>If {@code listener} is {@code null} or has not been added as a parse\n\t * listener, this method does nothing.</p>\n\t * @param listener the listener to remove\n\t */\n\tremoveParseListener(listener) {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst idx = this._parseListeners.indexOf(listener);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t\t}\n\t\t\tif (this._parseListeners.length === 0) {\n\t\t\t\tthis._parseListeners = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove all parse listeners.\n\tremoveParseListeners() {\n\t\tthis._parseListeners = null;\n\t}\n\n\t// Notify any parse listeners of an enter rule event.\n\ttriggerEnterRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\tlistener.enterEveryRule(ctx);\n\t\t\t\tctx.enterRule(listener);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t * @see //addParseListener\n\t */\n\ttriggerExitRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\t// reverse order walk of listeners\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.slice(0).reverse().forEach(function(listener) {\n\t\t\t\tctx.exitRule(listener);\n\t\t\t\tlistener.exitEveryRule(ctx);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetTokenFactory() {\n\t\treturn this._input.tokenSource._factory;\n\t}\n\n\t// Tell our token source and error strategy about a new way to create tokens.\n\tsetTokenFactory(factory) {\n\t\tthis._input.tokenSource._factory = factory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @throws UnsupportedOperationException if the current parser does not\n\t * implement the {@link //getSerializedATN()} method.\n\t */\n\tgetATNWithBypassAlts() {\n\t\tconst serializedAtn = this.getSerializedATN();\n\t\tif (serializedAtn === null) {\n\t\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t\t}\n\t\tlet result = this.bypassAltsAtnCache[serializedAtn];\n\t\tif (result === null) {\n\t\t\tconst deserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t\t.deserialize(serializedAtn);\n\t\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * <pre>\n\t * ParseTree t = parser.expr();\n\t * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n\t * MyParser.RULE_expr);\n\t * ParseTreeMatch m = p.match(t);\n\t * String id = m.get(\"ID\");\n\t * </pre>\n\t */\n\tcompileParseTreePattern(pattern, patternRuleIndex, lexer) {\n\t\tlexer = lexer || null;\n\t\tif (lexer === null) {\n\t\t\tif (this.getTokenStream() !== null) {\n\t\t\t\tconst tokenSource = this.getTokenStream().tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lexer === null) {\n\t\t\tthrow \"Parser can't discover a lexer to use\";\n\t\t}\n\t\tconst m = new ParseTreePatternMatcher(lexer, this);\n\t\treturn m.compile(pattern, patternRuleIndex);\n\t}\n\n\tgetInputStream() {\n\t\treturn this.getTokenStream();\n\t}\n\n\tsetInputStream(input) {\n\t\tthis.setTokenStream(input);\n\t}\n\n\tgetTokenStream() {\n\t\treturn this._input;\n\t}\n\n\t// Set the token stream and reset the parser.\n\tsetTokenStream(input) {\n\t\tthis._input = null;\n\t\tthis.reset();\n\t\tthis._input = input;\n\t}\n\n\t/**\n\t * Match needs to return the current input symbol, which gets put\n\t * into the label for the associated token ref; e.g., x=ID.\n\t */\n\tgetCurrentToken() {\n\t\treturn this._input.LT(1);\n\t}\n\n\tnotifyErrorListeners(msg, offendingToken, err) {\n\t\toffendingToken = offendingToken || null;\n\t\terr = err || null;\n\t\tif (offendingToken === null) {\n\t\t\toffendingToken = this.getCurrentToken();\n\t\t}\n\t\tthis._syntaxErrors += 1;\n\t\tconst line = offendingToken.line;\n\t\tconst column = offendingToken.column;\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n\t}\n\n\t/**\n\t * Consume and return the {@linkplain //getCurrentToken current symbol}.\n\t *\n\t * <p>E.g., given the following input with {@code A} being the current\n\t * lookahead symbol, this function moves the cursor to {@code B} and returns\n\t * {@code A}.</p>\n\t *\n\t * <pre>\n\t * A B\n\t * ^\n\t * </pre>\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n\t * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n\t * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n\t * added to the parse tree using\n\t * {@link ParserRuleContext//addErrorNode(Token)}, and\n\t * {@link ParseTreeListener//visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tconsume() {\n\t\tconst o = this.getCurrentToken();\n\t\tif (o.type !== Token.EOF) {\n\t\t\tthis.getInputStream().consume();\n\t\t}\n\t\tconst hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\t\tif (this.buildParseTrees || hasListener) {\n\t\t\tlet node;\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t\t} else {\n\t\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t\t}\n\t\t\tnode.invokingState = this.state;\n\t\t\tif (hasListener) {\n\t\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\taddContextToParseTree() {\n\t\t// add current context to parent if we have a parent\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link //_ctx} get the current context.\n\t */\n\tenterRule(localctx, state, ruleIndex) {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = this._input.LT(1);\n\t\tif (this.buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\texitRule() {\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tthis.triggerExitRuleEvent();\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx.parentCtx;\n\t}\n\n\tenterOuterAlt(localctx, altNum) {\n\t\tlocalctx.setAltNumber(altNum);\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\t\tif (this._ctx.parentCtx !== null) {\n\t\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @return The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tgetPrecedence() {\n\t\tif (this._precedenceStack.length === 0) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t\t}\n\t}\n\n\tenterRecursionRule(localctx, state, ruleIndex, precedence) {\n\t   this.state = state;\n\t   this._precedenceStack.push(precedence);\n\t   this._ctx = localctx;\n\t   this._ctx.start = this._input.LT(1);\n\t   this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n   }\n\n\t// Like {@link //enterRule} but for recursive rules.\n\tpushNewRecursionContext(localctx, state, ruleIndex) {\n\t\tconst previous = this._ctx;\n\t\tprevious.parentCtx = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious.stop = this._input.LT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = previous.start;\n\t\tif (this.buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\tunrollRecursionContexts(parentCtx) {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\tconst retCtx = this._ctx; // save current ctx (return value)\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tconst parseListeners = this.getParseListeners();\n\t\tif (parseListeners !== null && parseListeners.length > 0) {\n\t\t\twhile (this._ctx !== parentCtx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._ctx = parentCtx;\n\t\t}\n\t\t// hook into tree\n\t\tretCtx.parentCtx = parentCtx;\n\t\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\tparentCtx.addChild(retCtx);\n\t\t}\n\t}\n\n\tgetInvokingContext(ruleIndex) {\n\t\tlet ctx = this._ctx;\n\t\twhile (ctx !== null) {\n\t\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprecpred(localctx, precedence) {\n\t\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n\t}\n\n\tinContext(context) {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not {@code symbol} can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * <pre>\n\t * return getExpectedTokens().contains(symbol);\n\t * </pre>\n\t *\n\t * @param symbol the symbol type to check\n\t * @return {@code true} if {@code symbol} can follow the current state in\n\t * the ATN, otherwise {@code false}.\n\t */\n\tisExpectedToken(symbol) {\n\t\tconst atn = this._interp.atn;\n\t\tlet ctx = this._ctx;\n\t\tconst s = atn.states[this.state];\n\t\tlet following = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tconst invokingState = atn.states[ctx.invokingState];\n\t\t\tconst rt = invokingState.transitions[0];\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link //getState} and {@link //getContext},\n\t * respectively.\n\t *\n\t * @see ATN//getExpectedTokens(int, RuleContext)\n\t */\n\tgetExpectedTokens() {\n\t\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n\t}\n\n\tgetExpectedTokensWithinCurrentRule() {\n\t\tconst atn = this._interp.atn;\n\t\tconst s = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\tgetRuleIndex(ruleName) {\n\t\tconst ruleIndex = this.getRuleIndexMap()[ruleName];\n\t\tif (ruleIndex !== null) {\n\t\t\treturn ruleIndex;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/**\n\t * Return List&lt;String&gt; of the rule names in your parser instance\n\t * leading up to a call to the current rule. You could override if\n\t * you want more details such as the file/line info of where\n\t * in the ATN a rule is invoked.\n\t *\n\t * this is very useful for error messages.\n\t */\n\tgetRuleInvocationStack(p) {\n\t\tp = p || null;\n\t\tif (p === null) {\n\t\t\tp = this._ctx;\n\t\t}\n\t\tconst stack = [];\n\t\twhile (p !== null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tconst ruleIndex = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t// For debugging and other purposes.\n\tgetDFAStrings() {\n\t\treturn this._interp.decisionToDFA.toString();\n\t}\n\n\t// For debugging and other purposes.\n\tdumpDFA() {\n\t\tlet seenOne = false;\n\t\tfor (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\t\tconst dfa = this._interp.decisionToDFA[i];\n\t\t\tif (dfa.states.length > 0) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\t\"\t\t\tprinter = function() {\\r\\n\" +\n\t\t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\t\t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\t\t\"\t\t\t};\\r\\n\" +\n\t\t*/\n\tgetSourceName() {\n\t\treturn this._input.sourceName;\n\t}\n\n\t/**\n\t * During a parse is sometimes useful to listen in on the rule entry and exit\n\t * events as well as token matches. this is for quick and dirty debugging.\n\t */\n\tsetTrace(trace) {\n\t\tif (!trace) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t\tthis._tracer = null;\n\t\t} else {\n\t\t\tif (this._tracer !== null) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t}\n\t\t\tthis._tracer = new TraceListener(this);\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n}\n\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\nParser.bypassAltsAtnCache = {};\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}