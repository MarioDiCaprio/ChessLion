{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst {\n  BitSet\n} = require('./../Utils');\n\nconst {\n  ErrorListener\n} = require('./ErrorListener');\n\nconst {\n  Interval\n} = require('./../IntervalSet');\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\n\n\nclass DiagnosticErrorListener extends ErrorListener {\n  constructor(exactOnly) {\n    super();\n    exactOnly = exactOnly || true; // whether all ambiguities or only exact ambiguities are reported.\n\n    this.exactOnly = exactOnly;\n  }\n\n  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    if (this.exactOnly && !exact) {\n      return;\n    }\n\n    const msg = \"reportAmbiguity d=\" + this.getDecisionDescription(recognizer, dfa) + \": ambigAlts=\" + this.getConflictingAlts(ambigAlts, configs) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(msg);\n  }\n\n  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    const msg = \"reportAttemptingFullContext d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(msg);\n  }\n\n  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    const msg = \"reportContextSensitivity d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(msg);\n  }\n\n  getDecisionDescription(recognizer, dfa) {\n    const decision = dfa.decision;\n    const ruleIndex = dfa.atnStartState.ruleIndex;\n    const ruleNames = recognizer.ruleNames;\n\n    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n      return \"\" + decision;\n    }\n\n    const ruleName = ruleNames[ruleIndex] || null;\n\n    if (ruleName === null || ruleName.length === 0) {\n      return \"\" + decision;\n    }\n\n    return `${decision} (${ruleName})`;\n  }\n  /**\n   * Computes the set of conflicting or ambiguous alternatives from a\n   * configuration set, if that information was not already provided by the\n   * parser.\n   *\n   * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n   * reported by the parser.\n   * @param configs The conflicting or ambiguous configuration set.\n   * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n   * returns the set of alternatives represented in {@code configs}.\n      */\n\n\n  getConflictingAlts(reportedAlts, configs) {\n    if (reportedAlts !== null) {\n      return reportedAlts;\n    }\n\n    const result = new BitSet();\n\n    for (let i = 0; i < configs.items.length; i++) {\n      result.add(configs.items[i].alt);\n    }\n\n    return `{${result.values().join(\", \")}}`;\n  }\n\n}\n\nmodule.exports = DiagnosticErrorListener;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js"],"names":["BitSet","require","ErrorListener","Interval","DiagnosticErrorListener","constructor","exactOnly","reportAmbiguity","recognizer","dfa","startIndex","stopIndex","exact","ambigAlts","configs","msg","getDecisionDescription","getConflictingAlts","getTokenStream","getText","notifyErrorListeners","reportAttemptingFullContext","conflictingAlts","reportContextSensitivity","prediction","decision","ruleIndex","atnStartState","ruleNames","length","ruleName","reportedAlts","result","i","items","add","alt","values","join","module","exports"],"mappings":"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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {BitSet} = require('./../Utils');\nconst {ErrorListener} = require('./ErrorListener')\nconst {Interval} = require('./../IntervalSet')\n\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\nclass DiagnosticErrorListener extends ErrorListener {\n\tconstructor(exactOnly) {\n\t\tsuper();\n\t\texactOnly = exactOnly || true;\n\t\t// whether all ambiguities or only exact ambiguities are reported.\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\treportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\t\tconst msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\t\tconst msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\t\tconst msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\tgetDecisionDescription(recognizer, dfa) {\n\t\tconst decision = dfa.decision\n\t\tconst ruleIndex = dfa.atnStartState.ruleIndex\n\n\t\tconst ruleNames = recognizer.ruleNames\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\tconst ruleName = ruleNames[ruleIndex] || null\n\t\tif (ruleName === null || ruleName.length === 0) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n\t * returns the set of alternatives represented in {@code configs}.\n     */\n\tgetConflictingAlts(reportedAlts, configs) {\n\t\tif (reportedAlts !== null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\t\tconst result = new BitSet()\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tresult.add(configs.items[i].alt);\n\t\t}\n\t\treturn `{${result.values().join(\", \")}}`;\n\t}\n}\n\nmodule.exports = DiagnosticErrorListener\n"]},"metadata":{},"sourceType":"script"}