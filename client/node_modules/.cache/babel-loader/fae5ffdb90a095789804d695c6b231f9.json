{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\nconst {\n  Set,\n  BitSet,\n  DoubleDict\n} = Utils;\n\nconst ATN = require('./ATN');\n\nconst {\n  ATNState,\n  RuleStopState\n} = require('./ATNState');\n\nconst {\n  ATNConfig\n} = require('./ATNConfig');\n\nconst {\n  ATNConfigSet\n} = require('./ATNConfigSet');\n\nconst {\n  Token\n} = require('./../Token');\n\nconst {\n  DFAState,\n  PredPrediction\n} = require('./../dfa/DFAState');\n\nconst ATNSimulator = require('./ATNSimulator');\n\nconst PredictionMode = require('./PredictionMode');\n\nconst RuleContext = require('./../RuleContext');\n\nconst ParserRuleContext = require('./../ParserRuleContext');\n\nconst {\n  SemanticContext\n} = require('./SemanticContext');\n\nconst {\n  PredictionContext\n} = require('./../PredictionContext');\n\nconst {\n  Interval\n} = require('./../IntervalSet');\n\nconst {\n  Transition,\n  SetTransition,\n  NotSetTransition,\n  RuleTransition,\n  ActionTransition\n} = require('./Transition');\n\nconst {\n  NoViableAltException\n} = require('./../error/Errors');\n\nconst {\n  SingletonPredictionContext,\n  predictionContextFromRuleContext\n} = require('./../PredictionContext');\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\n\n\nclass ParserATNSimulator extends ATNSimulator {\n  constructor(parser, atn, decisionToDFA, sharedContextCache) {\n    super(atn, sharedContextCache);\n    this.parser = parser;\n    this.decisionToDFA = decisionToDFA; // SLL, LL, or LL + exact ambig detection?//\n\n    this.predictionMode = PredictionMode.LL; // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n\n    this._input = null;\n    this._startIndex = 0;\n    this._outerContext = null;\n    this._dfa = null;\n    /**\n     * Each prediction operation uses a cache for merge of prediction contexts.\n     *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n     *  isn't synchronized but we're ok since two threads shouldn't reuse same\n     *  parser/atnsim object because it can only handle one input at a time.\n     *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n     *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n     *  also be examined during cache lookup.\n     */\n\n    this.mergeCache = null;\n    this.debug = false;\n    this.debug_closure = false;\n    this.debug_add = false;\n    this.debug_list_atn_decisions = false;\n    this.dfa_debug = false;\n    this.retry_debug = false;\n  }\n\n  reset() {}\n\n  adaptivePredict(input, decision, outerContext) {\n    if (this.debug || this.debug_list_atn_decisions) {\n      console.log(\"adaptivePredict decision \" + decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n    }\n\n    this._input = input;\n    this._startIndex = input.index;\n    this._outerContext = outerContext;\n    const dfa = this.decisionToDFA[decision];\n    this._dfa = dfa;\n    const m = input.mark();\n    const index = input.index; // Now we are certain to have a specific decision's DFA\n    // But, do we still need an initial state?\n\n    try {\n      let s0;\n\n      if (dfa.precedenceDfa) {\n        // the start state for a precedence DFA depends on the current\n        // parser precedence, and is provided by a DFA method.\n        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n      } else {\n        // the start state for a \"regular\" DFA is just s0\n        s0 = dfa.s0;\n      }\n\n      if (s0 === null) {\n        if (outerContext === null) {\n          outerContext = RuleContext.EMPTY;\n        }\n\n        if (this.debug || this.debug_list_atn_decisions) {\n          console.log(\"predictATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n        }\n\n        const fullCtx = false;\n        let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n        if (dfa.precedenceDfa) {\n          // If this is a precedence DFA, we use applyPrecedenceFilter\n          // to convert the computed start state to a precedence start\n          // state. We then use DFA.setPrecedenceStartState to set the\n          // appropriate start state for the precedence level rather\n          // than simply setting DFA.s0.\n          //\n          dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n\n          s0_closure = this.applyPrecedenceFilter(s0_closure);\n          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n        } else {\n          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n          dfa.s0 = s0;\n        }\n      }\n\n      const alt = this.execATN(dfa, s0, input, index, outerContext);\n\n      if (this.debug) {\n        console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));\n      }\n\n      return alt;\n    } finally {\n      this._dfa = null;\n      this.mergeCache = null; // wack cache after each prediction\n\n      input.seek(index);\n      input.release(m);\n    }\n  }\n  /**\n   * Performs ATN simulation to compute a predicted alternative based\n   *  upon the remaining input, but also updates the DFA cache to avoid\n   *  having to traverse the ATN again for the same input sequence.\n   *\n   * There are some key conditions we're looking for after computing a new\n   * set of ATN configs (proposed DFA state):\n   *       if the set is empty, there is no viable alternative for current symbol\n   *       does the state uniquely predict an alternative?\n   *       does the state have a conflict that would prevent us from\n   *         putting it on the work list?\n   *\n   * We also have some key operations to do:\n   *       add an edge from previous DFA state to potentially new DFA state, D,\n   *         upon current symbol but only if adding to work list, which means in all\n   *         cases except no viable alternative (and possibly non-greedy decisions?)\n   *       collecting predicates and adding semantic context to DFA accept states\n   *       adding rule context to context-sensitive DFA accept states\n   *       consuming an input symbol\n   *       reporting a conflict\n   *       reporting an ambiguity\n   *       reporting a context sensitivity\n   *       reporting insufficient predicates\n   *\n   * cover these cases:\n   *    dead end\n   *    single alt\n   *    single alt + preds\n   *    conflict\n   *    conflict + preds\n   *\n   */\n\n\n  execATN(dfa, s0, input, startIndex, outerContext) {\n    if (this.debug || this.debug_list_atn_decisions) {\n      console.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n    }\n\n    let alt;\n    let previousD = s0;\n\n    if (this.debug) {\n      console.log(\"s0 = \" + s0);\n    }\n\n    let t = input.LA(1);\n\n    while (true) {\n      // while more work\n      let D = this.getExistingTargetState(previousD, t);\n\n      if (D === null) {\n        D = this.computeTargetState(dfa, previousD, t);\n      }\n\n      if (D === ATNSimulator.ERROR) {\n        // if any configs in previous dipped into outer context, that\n        // means that input up to t actually finished entry rule\n        // at least for SLL decision. Full LL doesn't dip into outer\n        // so don't need special case.\n        // We will get an error no matter what so delay until after\n        // decision; better error message. Also, no reachable target\n        // ATN states in SLL implies LL will also get nowhere.\n        // If conflict in states that dip out, choose min since we\n        // will get error no matter what.\n        const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n        input.seek(startIndex);\n        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n\n        if (alt !== ATN.INVALID_ALT_NUMBER) {\n          return alt;\n        } else {\n          throw e;\n        }\n      }\n\n      if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n        // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n        let conflictingAlts = null;\n\n        if (D.predicates !== null) {\n          if (this.debug) {\n            console.log(\"DFA state has preds in DFA sim LL failover\");\n          }\n\n          const conflictIndex = input.index;\n\n          if (conflictIndex !== startIndex) {\n            input.seek(startIndex);\n          }\n\n          conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n\n          if (conflictingAlts.length === 1) {\n            if (this.debug) {\n              console.log(\"Full LL avoided\");\n            }\n\n            return conflictingAlts.minValue();\n          }\n\n          if (conflictIndex !== startIndex) {\n            // restore the index so reporting the fallback to full\n            // context occurs with the index at the correct spot\n            input.seek(conflictIndex);\n          }\n        }\n\n        if (this.dfa_debug) {\n          console.log(\"ctx sensitive state \" + outerContext + \" in \" + D);\n        }\n\n        const fullCtx = true;\n        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n        this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n        alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n        return alt;\n      }\n\n      if (D.isAcceptState) {\n        if (D.predicates === null) {\n          return D.prediction;\n        }\n\n        const stopIndex = input.index;\n        input.seek(startIndex);\n        const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n\n        if (alts.length === 0) {\n          throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n        } else if (alts.length === 1) {\n          return alts.minValue();\n        } else {\n          // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n          this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n          return alts.minValue();\n        }\n      }\n\n      previousD = D;\n\n      if (t !== Token.EOF) {\n        input.consume();\n        t = input.LA(1);\n      }\n    }\n  }\n  /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns {@code null}.\n   *\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   * @return The existing target DFA state for the given input symbol\n   * {@code t}, or {@code null} if the target state for this edge is not\n   * already cached\n   */\n\n\n  getExistingTargetState(previousD, t) {\n    const edges = previousD.edges;\n\n    if (edges === null) {\n      return null;\n    } else {\n      return edges[t + 1] || null;\n    }\n  }\n  /**\n   * Compute a target state for an edge in the DFA, and attempt to add the\n   * computed state and corresponding edge to the DFA.\n   *\n   * @param dfa The DFA\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   *\n   * @return The computed target DFA state for the given input symbol\n   * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n   * returns {@link //ERROR\n   */\n\n\n  computeTargetState(dfa, previousD, t) {\n    const reach = this.computeReachSet(previousD.configs, t, false);\n\n    if (reach === null) {\n      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n      return ATNSimulator.ERROR;\n    } // create new target state; we'll add to DFA after it's complete\n\n\n    let D = new DFAState(null, reach);\n    const predictedAlt = this.getUniqueAlt(reach);\n\n    if (this.debug) {\n      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n      console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n      /*\", previous=\" + previousD.configs + */\n      \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + this.getConflictingAlts(reach));\n    }\n\n    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n      // NO CONFLICT, UNIQUELY PREDICTED ALT\n      D.isAcceptState = true;\n      D.configs.uniqueAlt = predictedAlt;\n      D.prediction = predictedAlt;\n    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n      // MORE THAN ONE VIABLE ALTERNATIVE\n      D.configs.conflictingAlts = this.getConflictingAlts(reach);\n      D.requiresFullContext = true; // in SLL-only mode, we will stop at this state and return the minimum alt\n\n      D.isAcceptState = true;\n      D.prediction = D.configs.conflictingAlts.minValue();\n    }\n\n    if (D.isAcceptState && D.configs.hasSemanticContext) {\n      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n\n      if (D.predicates !== null) {\n        D.prediction = ATN.INVALID_ALT_NUMBER;\n      }\n    } // all adds to dfa are done after we've created full D state\n\n\n    D = this.addDFAEdge(dfa, previousD, t, D);\n    return D;\n  }\n\n  predicateDFAState(dfaState, decisionState) {\n    // We need to test all predicates, even in DFA states that\n    // uniquely predict alternative.\n    const nalts = decisionState.transitions.length; // Update DFA so reach becomes accept state with (predicate,alt)\n    // pairs if preds found for conflicting alts\n\n    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n\n    if (altToPred !== null) {\n      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n      dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n    } else {\n      // There are preds in configs but they might go away\n      // when OR'd together like {p}? || NONE == NONE. If neither\n      // alt has preds, resolve to min alt\n      dfaState.prediction = altsToCollectPredsFrom.minValue();\n    }\n  } // comes back with reach.uniqueAlt set to a valid alt\n\n\n  execATNWithFullContext(dfa, D, // how far we got before failing over\n  s0, input, startIndex, outerContext) {\n    if (this.debug || this.debug_list_atn_decisions) {\n      console.log(\"execATNWithFullContext \" + s0);\n    }\n\n    const fullCtx = true;\n    let foundExactAmbig = false;\n    let reach;\n    let previous = s0;\n    input.seek(startIndex);\n    let t = input.LA(1);\n    let predictedAlt = -1;\n\n    while (true) {\n      // while more work\n      reach = this.computeReachSet(previous, t, fullCtx);\n\n      if (reach === null) {\n        // if any configs in previous dipped into outer context, that\n        // means that input up to t actually finished entry rule\n        // at least for LL decision. Full LL doesn't dip into outer\n        // so don't need special case.\n        // We will get an error no matter what so delay until after\n        // decision; better error message. Also, no reachable target\n        // ATN states in SLL implies LL will also get nowhere.\n        // If conflict in states that dip out, choose min since we\n        // will get error no matter what.\n        const e = this.noViableAlt(input, outerContext, previous, startIndex);\n        input.seek(startIndex);\n        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n\n        if (alt !== ATN.INVALID_ALT_NUMBER) {\n          return alt;\n        } else {\n          throw e;\n        }\n      }\n\n      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\n      if (this.debug) {\n        console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n      }\n\n      reach.uniqueAlt = this.getUniqueAlt(reach); // unique prediction?\n\n      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n        predictedAlt = reach.uniqueAlt;\n        break;\n      } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n        predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\n        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n          break;\n        }\n      } else {\n        // In exact ambiguity mode, we never try to terminate early.\n        // Just keeps scarfing until we know what the conflict is\n        if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n          foundExactAmbig = true;\n          predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n          break;\n        } // else there are multiple non-conflicting subsets or\n        // we're not sure what the ambiguity is yet.\n        // So, keep going.\n\n      }\n\n      previous = reach;\n\n      if (t !== Token.EOF) {\n        input.consume();\n        t = input.LA(1);\n      }\n    } // If the configuration set uniquely predicts an alternative,\n    // without conflict, then we know that it's a full LL decision\n    // not SLL.\n\n\n    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n      return predictedAlt;\n    } // We do not check predicates here because we have checked them\n    // on-the-fly when doing full context prediction.\n    //\n    // In non-exact ambiguity detection mode, we might\tactually be able to\n    // detect an exact ambiguity, but I'm not going to spend the cycles\n    // needed to check. We only emit ambiguity warnings in exact ambiguity\n    // mode.\n    //\n    // For example, we might know that we have conflicting configurations.\n    // But, that does not mean that there is no way forward without a\n    // conflict. It's possible to have nonconflicting alt subsets as in:\n    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n    // from\n    //\n    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n    //\n    // In this case, (17,1,[5 $]) indicates there is some next sequence that\n    // would resolve this without conflict to alternative 1. Any other viable\n    // next sequence, however, is associated with a conflict.  We stop\n    // looking for input because no amount of further lookahead will alter\n    // the fact that we should predict alternative 1.  We just can't say for\n    // sure that there is an ambiguity without looking further.\n\n\n    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n    return predictedAlt;\n  }\n\n  computeReachSet(closure, t, fullCtx) {\n    if (this.debug) {\n      console.log(\"in computeReachSet, starting closure: \" + closure);\n    }\n\n    if (this.mergeCache === null) {\n      this.mergeCache = new DoubleDict();\n    }\n\n    const intermediate = new ATNConfigSet(fullCtx); // Configurations already in a rule stop state indicate reaching the end\n    // of the decision rule (local context) or end of the start rule (full\n    // context). Once reached, these configurations are never updated by a\n    // closure operation, so they are handled separately for the performance\n    // advantage of having a smaller intermediate set when calling closure.\n    //\n    // For full-context reach operations, separate handling is required to\n    // ensure that the alternative matching the longest overall sequence is\n    // chosen when multiple such configurations can match the input.\n\n    let skippedStopStates = null; // First figure out where we can reach on input t\n\n    for (let i = 0; i < closure.items.length; i++) {\n      const c = closure.items[i];\n\n      if (this.debug) {\n        console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n      }\n\n      if (c.state instanceof RuleStopState) {\n        if (fullCtx || t === Token.EOF) {\n          if (skippedStopStates === null) {\n            skippedStopStates = [];\n          }\n\n          skippedStopStates.push(c);\n\n          if (this.debug_add) {\n            console.log(\"added \" + c + \" to skippedStopStates\");\n          }\n        }\n\n        continue;\n      }\n\n      for (let j = 0; j < c.state.transitions.length; j++) {\n        const trans = c.state.transitions[j];\n        const target = this.getReachableTarget(trans, t);\n\n        if (target !== null) {\n          const cfg = new ATNConfig({\n            state: target\n          }, c);\n          intermediate.add(cfg, this.mergeCache);\n\n          if (this.debug_add) {\n            console.log(\"added \" + cfg + \" to intermediate\");\n          }\n        }\n      }\n    } // Now figure out where the reach operation can take us...\n\n\n    let reach = null; // This block optimizes the reach operation for intermediate sets which\n    // trivially indicate a termination state for the overall\n    // adaptivePredict operation.\n    //\n    // The conditions assume that intermediate\n    // contains all configurations relevant to the reach set, but this\n    // condition is not true when one or more configurations have been\n    // withheld in skippedStopStates, or when the current symbol is EOF.\n    //\n\n    if (skippedStopStates === null && t !== Token.EOF) {\n      if (intermediate.items.length === 1) {\n        // Don't pursue the closure if there is just one state.\n        // It can only have one alternative; just add to result\n        // Also don't pursue the closure if there is unique alternative\n        // among the configurations.\n        reach = intermediate;\n      } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {\n        // Also don't pursue the closure if there is unique alternative\n        // among the configurations.\n        reach = intermediate;\n      }\n    } // If the reach set could not be trivially determined, perform a closure\n    // operation on the intermediate set to compute its initial value.\n    //\n\n\n    if (reach === null) {\n      reach = new ATNConfigSet(fullCtx);\n      const closureBusy = new Set();\n      const treatEofAsEpsilon = t === Token.EOF;\n\n      for (let k = 0; k < intermediate.items.length; k++) {\n        this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n      }\n    }\n\n    if (t === Token.EOF) {\n      // After consuming EOF no additional input is possible, so we are\n      // only interested in configurations which reached the end of the\n      // decision rule (local context) or end of the start rule (full\n      // context). Update reach to contain only these configurations. This\n      // handles both explicit EOF transitions in the grammar and implicit\n      // EOF transitions following the end of the decision or start rule.\n      //\n      // When reach==intermediate, no closure operation was performed. In\n      // this case, removeAllConfigsNotInRuleStopState needs to check for\n      // reachable rule stop states as well as configurations already in\n      // a rule stop state.\n      //\n      // This is handled before the configurations in skippedStopStates,\n      // because any configurations potentially added from that list are\n      // already guaranteed to meet this condition whether or not it's\n      // required.\n      //\n      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n    } // If skippedStopStates!==null, then it contains at least one\n    // configuration. For full-context reach operations, these\n    // configurations reached the end of the start rule, in which case we\n    // only add them back to reach if no configuration during the current\n    // closure operation reached such a state. This ensures adaptivePredict\n    // chooses an alternative matching the longest overall sequence when\n    // multiple alternatives are viable.\n    //\n\n\n    if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n      for (let l = 0; l < skippedStopStates.length; l++) {\n        reach.add(skippedStopStates[l], this.mergeCache);\n      }\n    }\n\n    if (reach.items.length === 0) {\n      return null;\n    } else {\n      return reach;\n    }\n  }\n  /**\n   * Return a configuration set containing only the configurations from\n   * {@code configs} which are in a {@link RuleStopState}. If all\n   * configurations in {@code configs} are already in a rule stop state, this\n   * method simply returns {@code configs}.\n   *\n   * <p>When {@code lookToEndOfRule} is true, this method uses\n   * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n   * not already in a rule stop state to see if a rule stop state is reachable\n   * from the configuration via epsilon-only transitions.</p>\n   *\n   * @param configs the configuration set to update\n   * @param lookToEndOfRule when true, this method checks for rule stop states\n   * reachable by epsilon-only transitions from each configuration in\n   * {@code configs}.\n   *\n   * @return {@code configs} if all configurations in {@code configs} are in a\n   * rule stop state, otherwise return a new configuration set containing only\n   * the configurations from {@code configs} which are in a rule stop state\n   */\n\n\n  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n    if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n      return configs;\n    }\n\n    const result = new ATNConfigSet(configs.fullCtx);\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const config = configs.items[i];\n\n      if (config.state instanceof RuleStopState) {\n        result.add(config, this.mergeCache);\n        continue;\n      }\n\n      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n        const nextTokens = this.atn.nextTokens(config.state);\n\n        if (nextTokens.contains(Token.EPSILON)) {\n          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n          result.add(new ATNConfig({\n            state: endOfRuleState\n          }, config), this.mergeCache);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  computeStartState(p, ctx, fullCtx) {\n    // always at least the implicit call to start rule\n    const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n    const configs = new ATNConfigSet(fullCtx);\n\n    for (let i = 0; i < p.transitions.length; i++) {\n      const target = p.transitions[i].target;\n      const c = new ATNConfig({\n        state: target,\n        alt: i + 1,\n        context: initialContext\n      }, null);\n      const closureBusy = new Set();\n      this.closure(c, configs, closureBusy, true, fullCtx, false);\n    }\n\n    return configs;\n  }\n  /**\n   * This method transforms the start state computed by\n   * {@link //computeStartState} to the special start state used by a\n   * precedence DFA for a particular precedence value. The transformation\n   * process applies the following changes to the start state's configuration\n   * set.\n   *\n   * <ol>\n   * <li>Evaluate the precedence predicates for each configuration using\n   * {@link SemanticContext//evalPrecedence}.</li>\n   * <li>Remove all configurations which predict an alternative greater than\n   * 1, for which another configuration that predicts alternative 1 is in the\n   * same ATN state with the same prediction context. This transformation is\n   * valid for the following reasons:\n   * <ul>\n   * <li>The closure block cannot contain any epsilon transitions which bypass\n   * the body of the closure, so all states reachable via alternative 1 are\n   * part of the precedence alternatives of the transformed left-recursive\n   * rule.</li>\n   * <li>The \"primary\" portion of a left recursive rule cannot contain an\n   * epsilon transition, so the only way an alternative other than 1 can exist\n   * in a state that is also reachable via alternative 1 is by nesting calls\n   * to the left-recursive rule, with the outer calls not being at the\n   * preferred precedence level.</li>\n   * </ul>\n   * </li>\n   * </ol>\n   *\n   * <p>\n   * The prediction context must be considered by this filter to address\n   * situations like the following.\n   * </p>\n   * <code>\n   * <pre>\n   * grammar TA;\n   * prog: statement* EOF;\n   * statement: letterA | statement letterA 'b' ;\n   * letterA: 'a';\n   * </pre>\n   * </code>\n   * <p>\n   * If the above grammar, the ATN state immediately before the token\n   * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n   * of both the primary and closure blocks of the left-recursive rule\n   * {@code statement}. The prediction context associated with each of these\n   * configurations distinguishes between them, and prevents the alternative\n   * which stepped out to {@code prog} (and then back in to {@code statement}\n   * from being eliminated by the filter.\n   * </p>\n   *\n   * @param configs The configuration set computed by\n   * {@link //computeStartState} as the start state for the DFA.\n   * @return The transformed configuration set representing the start state\n   * for a precedence DFA at a particular precedence level (determined by\n   * calling {@link Parser//getPrecedence})\n   */\n\n\n  applyPrecedenceFilter(configs) {\n    let config;\n    const statesFromAlt1 = [];\n    const configSet = new ATNConfigSet(configs.fullCtx);\n\n    for (let i = 0; i < configs.items.length; i++) {\n      config = configs.items[i]; // handle alt 1 first\n\n      if (config.alt !== 1) {\n        continue;\n      }\n\n      const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n\n      if (updatedContext === null) {\n        // the configuration was eliminated\n        continue;\n      }\n\n      statesFromAlt1[config.state.stateNumber] = config.context;\n\n      if (updatedContext !== config.semanticContext) {\n        configSet.add(new ATNConfig({\n          semanticContext: updatedContext\n        }, config), this.mergeCache);\n      } else {\n        configSet.add(config, this.mergeCache);\n      }\n    }\n\n    for (let i = 0; i < configs.items.length; i++) {\n      config = configs.items[i];\n\n      if (config.alt === 1) {\n        // already handled\n        continue;\n      } // In the future, this elimination step could be updated to also\n      // filter the prediction context for alternatives predicting alt>1\n      // (basically a graph subtraction algorithm).\n\n\n      if (!config.precedenceFilterSuppressed) {\n        const context = statesFromAlt1[config.state.stateNumber] || null;\n\n        if (context !== null && context.equals(config.context)) {\n          // eliminated\n          continue;\n        }\n      }\n\n      configSet.add(config, this.mergeCache);\n    }\n\n    return configSet;\n  }\n\n  getReachableTarget(trans, ttype) {\n    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n      return trans.target;\n    } else {\n      return null;\n    }\n  }\n\n  getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n    // altToPred starts as an array of all null contexts. The entry at index i\n    // corresponds to alternative i. altToPred[i] may have one of three values:\n    //   1. null: no ATNConfig c is found such that c.alt==i\n    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n    //      alt i has at least one unpredicated config.\n    //   3. Non-NONE Semantic Context: There exists at least one, and for all\n    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n    //\n    // From this, it is clear that NONE||anything==NONE.\n    //\n    let altToPred = [];\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (ambigAlts.contains(c.alt)) {\n        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n      }\n    }\n\n    let nPredAlts = 0;\n\n    for (let i = 1; i < nalts + 1; i++) {\n      const pred = altToPred[i] || null;\n\n      if (pred === null) {\n        altToPred[i] = SemanticContext.NONE;\n      } else if (pred !== SemanticContext.NONE) {\n        nPredAlts += 1;\n      }\n    } // nonambig alts are null in altToPred\n\n\n    if (nPredAlts === 0) {\n      altToPred = null;\n    }\n\n    if (this.debug) {\n      console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n    }\n\n    return altToPred;\n  }\n\n  getPredicatePredictions(ambigAlts, altToPred) {\n    const pairs = [];\n    let containsPredicate = false;\n\n    for (let i = 1; i < altToPred.length; i++) {\n      const pred = altToPred[i]; // unpredicated is indicated by SemanticContext.NONE\n\n      if (ambigAlts !== null && ambigAlts.contains(i)) {\n        pairs.push(new PredPrediction(pred, i));\n      }\n\n      if (pred !== SemanticContext.NONE) {\n        containsPredicate = true;\n      }\n    }\n\n    if (!containsPredicate) {\n      return null;\n    }\n\n    return pairs;\n  }\n  /**\n   * This method is used to improve the localization of error messages by\n   * choosing an alternative rather than throwing a\n   * {@link NoViableAltException} in particular prediction scenarios where the\n   * {@link //ERROR} state was reached during ATN simulation.\n   *\n   * <p>\n   * The default implementation of this method uses the following\n   * algorithm to identify an ATN configuration which successfully parsed the\n   * decision entry rule. Choosing such an alternative ensures that the\n   * {@link ParserRuleContext} returned by the calling rule will be complete\n   * and valid, and the syntax error will be reported later at a more\n   * localized location.</p>\n   *\n   * <ul>\n   * <li>If a syntactically valid path or paths reach the end of the decision rule and\n   * they are semantically valid if predicated, return the min associated alt.</li>\n   * <li>Else, if a semantically invalid but syntactically valid path exist\n   * or paths exist, return the minimum associated alt.\n   * </li>\n   * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n   * </ul>\n   *\n   * <p>\n   * In some scenarios, the algorithm described above could predict an\n   * alternative which will result in a {@link FailedPredicateException} in\n   * the parser. Specifically, this could occur if the <em>only</em> configuration\n   * capable of successfully parsing to the end of the decision rule is\n   * blocked by a semantic predicate. By choosing this alternative within\n   * {@link //adaptivePredict} instead of throwing a\n   * {@link NoViableAltException}, the resulting\n   * {@link FailedPredicateException} in the parser will identify the specific\n   * predicate which is preventing the parser from successfully parsing the\n   * decision rule, which helps developers identify and correct logic errors\n   * in semantic predicates.\n   * </p>\n   *\n   * @param configs The ATN configurations which were valid immediately before\n   * the {@link //ERROR} state was reached\n   * @param outerContext The is the \\gamma_0 initial parser context from the paper\n   * or the parser stack at the instant before prediction commences.\n   *\n   * @return The value to return from {@link //adaptivePredict}, or\n   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n   * identified and {@link //adaptivePredict} should report an error instead\n   */\n\n\n  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n    const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n    const semValidConfigs = cfgs[0];\n    const semInvalidConfigs = cfgs[1];\n    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n\n    if (alt !== ATN.INVALID_ALT_NUMBER) {\n      // semantically/syntactically viable path exists\n      return alt;\n    } // Is there a syntactically valid path with a failed pred?\n\n\n    if (semInvalidConfigs.items.length > 0) {\n      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n\n      if (alt !== ATN.INVALID_ALT_NUMBER) {\n        // syntactically viable path exists\n        return alt;\n      }\n    }\n\n    return ATN.INVALID_ALT_NUMBER;\n  }\n\n  getAltThatFinishedDecisionEntryRule(configs) {\n    const alts = [];\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {\n        if (alts.indexOf(c.alt) < 0) {\n          alts.push(c.alt);\n        }\n      }\n    }\n\n    if (alts.length === 0) {\n      return ATN.INVALID_ALT_NUMBER;\n    } else {\n      return Math.min.apply(null, alts);\n    }\n  }\n  /**\n   * Walk the list of configurations and split them according to\n   * those that have preds evaluating to true/false.  If no pred, assume\n   * true pred and include in succeeded set.  Returns Pair of sets.\n   *\n   * Create a new set so as not to alter the incoming parameter.\n   *\n   * Assumption: the input stream has been restored to the starting point\n   * prediction, which is where predicates need to evaluate.*/\n\n\n  splitAccordingToSemanticValidity(configs, outerContext) {\n    const succeeded = new ATNConfigSet(configs.fullCtx);\n    const failed = new ATNConfigSet(configs.fullCtx);\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (c.semanticContext !== SemanticContext.NONE) {\n        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n\n        if (predicateEvaluationResult) {\n          succeeded.add(c);\n        } else {\n          failed.add(c);\n        }\n      } else {\n        succeeded.add(c);\n      }\n    }\n\n    return [succeeded, failed];\n  }\n  /**\n   * Look through a list of predicate/alt pairs, returning alts for the\n   * pairs that win. A {@code NONE} predicate indicates an alt containing an\n   * unpredicated config which behaves as \"always true.\" If !complete\n   * then we stop at the first predicate that evaluates to true. This\n   * includes pairs with null predicates.\n   */\n\n\n  evalSemanticContext(predPredictions, outerContext, complete) {\n    const predictions = new BitSet();\n\n    for (let i = 0; i < predPredictions.length; i++) {\n      const pair = predPredictions[i];\n\n      if (pair.pred === SemanticContext.NONE) {\n        predictions.add(pair.alt);\n\n        if (!complete) {\n          break;\n        }\n\n        continue;\n      }\n\n      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n\n      if (this.debug || this.dfa_debug) {\n        console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n      }\n\n      if (predicateEvaluationResult) {\n        if (this.debug || this.dfa_debug) {\n          console.log(\"PREDICT \" + pair.alt);\n        }\n\n        predictions.add(pair.alt);\n\n        if (!complete) {\n          break;\n        }\n      }\n    }\n\n    return predictions;\n  } // TODO: If we are doing predicates, there is no point in pursuing\n  //     closure operations if we reach a DFA state that uniquely predicts\n  //     alternative. We will not be caching that DFA state and it is a\n  //     waste to pursue the closure. Might have to advance when we do\n  //     ambig detection thought :(\n  //\n\n\n  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n    const initialDepth = 0;\n    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);\n  }\n\n  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    if (this.debug || this.debug_closure) {\n      console.log(\"closure(\" + config.toString(this.parser, true) + \")\"); // console.log(\"configs(\" + configs.toString() + \")\");\n\n      if (config.reachesIntoOuterContext > 50) {\n        throw \"problem\";\n      }\n    }\n\n    if (config.state instanceof RuleStopState) {\n      // We hit rule end. If we have context info, use it\n      // run thru all possible stack tops in ctx\n      if (!config.context.isEmpty()) {\n        for (let i = 0; i < config.context.length; i++) {\n          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n            if (fullCtx) {\n              configs.add(new ATNConfig({\n                state: config.state,\n                context: PredictionContext.EMPTY\n              }, config), this.mergeCache);\n              continue;\n            } else {\n              // we have no context info, just chase follow links (if greedy)\n              if (this.debug) {\n                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n              }\n\n              this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n            }\n\n            continue;\n          }\n\n          const returnState = this.atn.states[config.context.getReturnState(i)];\n          const newContext = config.context.getParent(i); // \"pop\" return state\n\n          const parms = {\n            state: returnState,\n            alt: config.alt,\n            context: newContext,\n            semanticContext: config.semanticContext\n          };\n          const c = new ATNConfig(parms, null); // While we have context to pop back from, we may have\n          // gotten that context AFTER having falling off a rule.\n          // Make sure we track that we are now out of context.\n\n          c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n          this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n        }\n\n        return;\n      } else if (fullCtx) {\n        // reached end of start rule\n        configs.add(config, this.mergeCache);\n        return;\n      } else {\n        // else if we have no context info, just chase follow links (if greedy)\n        if (this.debug) {\n          console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n        }\n      }\n    }\n\n    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n  } // Do the actual work of walking epsilon edges//\n\n\n  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    const p = config.state; // optimization\n\n    if (!p.epsilonOnlyTransitions) {\n      configs.add(config, this.mergeCache); // make sure to not return here, because EOF transitions can act as\n      // both epsilon transitions and non-epsilon transitions.\n    }\n\n    for (let i = 0; i < p.transitions.length; i++) {\n      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;\n      const t = p.transitions[i];\n      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n\n      if (c !== null) {\n        let newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n          // target fell off end of rule; mark resulting c as having dipped into outer context\n          // We can't get here if incoming config was rule stop and we had context\n          // track how far we dip into outer context.  Might\n          // come in handy and we avoid evaluating context dependent\n          // preds if this is > 0.\n          if (this._dfa !== null && this._dfa.precedenceDfa) {\n            if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n              c.precedenceFilterSuppressed = true;\n            }\n          }\n\n          c.reachesIntoOuterContext += 1;\n\n          if (closureBusy.add(c) !== c) {\n            // avoid infinite recursion for right-recursive rules\n            continue;\n          }\n\n          configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\n          newDepth -= 1;\n\n          if (this.debug) {\n            console.log(\"dips into outer ctx: \" + c);\n          }\n        } else {\n          if (!t.isEpsilon && closureBusy.add(c) !== c) {\n            // avoid infinite recursion for EOF* and EOF+\n            continue;\n          }\n\n          if (t instanceof RuleTransition) {\n            // latch when newDepth goes negative - once we step out of the entry context we can't return\n            if (newDepth >= 0) {\n              newDepth += 1;\n            }\n          }\n        }\n\n        this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n      }\n    }\n  }\n\n  canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n    // return False\n    const p = config.state; // First check to see if we are in StarLoopEntryState generated during\n    // left-recursion elimination. For efficiency, also check if\n    // the context has an empty stack case. If so, it would mean\n    // global FOLLOW so we can't perform optimization\n    // Are we the special loop entry/exit state? or SLL wildcard\n\n    if (p.stateType !== ATNState.STAR_LOOP_ENTRY) return false;\n    if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath()) return false; // Require all return states to return back to the same rule that p is in.\n\n    const numCtxs = config.context.length;\n\n    for (let i = 0; i < numCtxs; i++) {\n      // for each stack context\n      const returnState = this.atn.states[config.context.getReturnState(i)];\n      if (returnState.ruleIndex !== p.ruleIndex) return false;\n    }\n\n    const decisionStartState = p.transitions[0].target;\n    const blockEndStateNum = decisionStartState.endState.stateNumber;\n    const blockEndState = this.atn.states[blockEndStateNum]; // Verify that the top of each stack context leads to loop entry/exit\n    // state through epsilon edges and w/o leaving rule.\n\n    for (let i = 0; i < numCtxs; i++) {\n      // for each stack context\n      const returnStateNumber = config.context.getReturnState(i);\n      const returnState = this.atn.states[returnStateNumber]; // all states must have single outgoing epsilon edge\n\n      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) return false; // Look for prefix op case like 'not expr', (' type ')' expr\n\n      const returnStateTarget = returnState.transitions[0].target;\n      if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p) continue; // Look for 'expr op expr' or case where expr's return state is block end\n      // of (...)* internal block; the block end points to loop back\n      // which points to p but we don't need to check that\n\n      if (returnState === blockEndState) continue; // Look for ternary expr ? expr : expr. The return state points at block end,\n      // which points at loop entry state\n\n      if (returnStateTarget === blockEndState) continue; // Look for complex prefix 'between expr and expr' case where 2nd expr's\n      // return state points at block end state of (...)* internal block\n\n      if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) continue; // anything else ain't conforming\n\n      return false;\n    }\n\n    return true;\n  }\n\n  getRuleName(index) {\n    if (this.parser !== null && index >= 0) {\n      return this.parser.ruleNames[index];\n    } else {\n      return \"<rule \" + index + \">\";\n    }\n  }\n\n  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n    switch (t.serializationType) {\n      case Transition.RULE:\n        return this.ruleTransition(config, t);\n\n      case Transition.PRECEDENCE:\n        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n\n      case Transition.PREDICATE:\n        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n\n      case Transition.ACTION:\n        return this.actionTransition(config, t);\n\n      case Transition.EPSILON:\n        return new ATNConfig({\n          state: t.target\n        }, config);\n\n      case Transition.ATOM:\n      case Transition.RANGE:\n      case Transition.SET:\n        // EOF transitions act like epsilon transitions after the first EOF\n        // transition is traversed\n        if (treatEofAsEpsilon) {\n          if (t.matches(Token.EOF, 0, 1)) {\n            return new ATNConfig({\n              state: t.target\n            }, config);\n          }\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n  }\n\n  actionTransition(config, t) {\n    if (this.debug) {\n      const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n      console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n    }\n\n    return new ATNConfig({\n      state: t.target\n    }, config);\n  }\n\n  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n    if (this.debug) {\n      console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n\n      if (this.parser !== null) {\n        console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n      }\n    }\n\n    let c = null;\n\n    if (collectPredicates && inContext) {\n      if (fullCtx) {\n        // In full context mode, we can evaluate predicates on-the-fly\n        // during closure, which dramatically reduces the size of\n        // the config sets. It also obviates the need to test predicates\n        // later during conflict resolution.\n        const currentPosition = this._input.index;\n\n        this._input.seek(this._startIndex);\n\n        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n\n        this._input.seek(currentPosition);\n\n        if (predSucceeds) {\n          c = new ATNConfig({\n            state: pt.target\n          }, config); // no pred context\n        }\n      } else {\n        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n        c = new ATNConfig({\n          state: pt.target,\n          semanticContext: newSemCtx\n        }, config);\n      }\n    } else {\n      c = new ATNConfig({\n        state: pt.target\n      }, config);\n    }\n\n    if (this.debug) {\n      console.log(\"config from pred transition=\" + c);\n    }\n\n    return c;\n  }\n\n  predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n    if (this.debug) {\n      console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n\n      if (this.parser !== null) {\n        console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n      }\n    }\n\n    let c = null;\n\n    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {\n      if (fullCtx) {\n        // In full context mode, we can evaluate predicates on-the-fly\n        // during closure, which dramatically reduces the size of\n        // the config sets. It also obviates the need to test predicates\n        // later during conflict resolution.\n        const currentPosition = this._input.index;\n\n        this._input.seek(this._startIndex);\n\n        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n\n        this._input.seek(currentPosition);\n\n        if (predSucceeds) {\n          c = new ATNConfig({\n            state: pt.target\n          }, config); // no pred context\n        }\n      } else {\n        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n        c = new ATNConfig({\n          state: pt.target,\n          semanticContext: newSemCtx\n        }, config);\n      }\n    } else {\n      c = new ATNConfig({\n        state: pt.target\n      }, config);\n    }\n\n    if (this.debug) {\n      console.log(\"config from pred transition=\" + c);\n    }\n\n    return c;\n  }\n\n  ruleTransition(config, t) {\n    if (this.debug) {\n      console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n    }\n\n    const returnState = t.followState;\n    const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n    return new ATNConfig({\n      state: t.target,\n      context: newContext\n    }, config);\n  }\n\n  getConflictingAlts(configs) {\n    const altsets = PredictionMode.getConflictingAltSubsets(configs);\n    return PredictionMode.getAlts(altsets);\n  }\n  /**\n   * Sam pointed out a problem with the previous definition, v3, of\n   * ambiguous states. If we have another state associated with conflicting\n   * alternatives, we should keep going. For example, the following grammar\n   *\n   * s : (ID | ID ID?) ';' ;\n   *\n   * When the ATN simulation reaches the state before ';', it has a DFA\n   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n   * because alternative to has another way to continue, via [6|2|[]].\n   * The key is that we have a single state that has config's only associated\n   * with a single alternative, 2, and crucially the state transitions\n   * among the configurations are all non-epsilon transitions. That means\n   * we don't consider any conflicts that include alternative 2. So, we\n   * ignore the conflict between alts 1 and 2. We ignore a set of\n   * conflicting alts when there is an intersection with an alternative\n   * associated with a single alt state in the state&rarr;config-list map.\n   *\n   * It's also the case that we might have two conflicting configurations but\n   * also a 3rd nonconflicting configuration for a different alternative:\n   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n   *\n   * a : A | A | A B ;\n   *\n   * After matching input A, we reach the stop state for rule A, state 1.\n   * State 8 is the state right before B. Clearly alternatives 1 and 2\n   * conflict and no amount of further lookahead will separate the two.\n   * However, alternative 3 will be able to continue and so we do not\n   * stop working on this state. In the previous example, we're concerned\n   * with states associated with the conflicting alternatives. Here alt\n   * 3 is not associated with the conflicting configs, but since we can continue\n   * looking for input reasonably, I don't declare the state done. We\n   * ignore a set of conflicting alts when we have an alternative\n   * that we still need to pursue\n   */\n\n\n  getConflictingAltsOrUniqueAlt(configs) {\n    let conflictingAlts = null;\n\n    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n      conflictingAlts = new BitSet();\n      conflictingAlts.add(configs.uniqueAlt);\n    } else {\n      conflictingAlts = configs.conflictingAlts;\n    }\n\n    return conflictingAlts;\n  }\n\n  getTokenName(t) {\n    if (t === Token.EOF) {\n      return \"EOF\";\n    }\n\n    if (this.parser !== null && this.parser.literalNames !== null) {\n      if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n        console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n        console.log(\"\" + this.parser.getInputStream().getTokens());\n      } else {\n        const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n        return name + \"<\" + t + \">\";\n      }\n    }\n\n    return \"\" + t;\n  }\n\n  getLookaheadName(input) {\n    return this.getTokenName(input.LA(1));\n  }\n  /**\n   * Used for debugging in adaptivePredict around execATN but I cut\n   * it out for clarity now that alg. works well. We can leave this\n   * \"dead\" code for a bit\n   */\n\n\n  dumpDeadEndConfigs(nvae) {\n    console.log(\"dead end configs: \");\n    const decs = nvae.getDeadEndConfigs();\n\n    for (let i = 0; i < decs.length; i++) {\n      const c = decs[i];\n      let trans = \"no edges\";\n\n      if (c.state.transitions.length > 0) {\n        const t = c.state.transitions[0];\n\n        if (t instanceof AtomTransition) {\n          trans = \"Atom \" + this.getTokenName(t.label);\n        } else if (t instanceof SetTransition) {\n          const neg = t instanceof NotSetTransition;\n          trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n        }\n      }\n\n      console.error(c.toString(this.parser, true) + \":\" + trans);\n    }\n  }\n\n  noViableAlt(input, outerContext, configs, startIndex) {\n    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n  }\n\n  getUniqueAlt(configs) {\n    let alt = ATN.INVALID_ALT_NUMBER;\n\n    for (let i = 0; i < configs.items.length; i++) {\n      const c = configs.items[i];\n\n      if (alt === ATN.INVALID_ALT_NUMBER) {\n        alt = c.alt; // found first alt\n      } else if (c.alt !== alt) {\n        return ATN.INVALID_ALT_NUMBER;\n      }\n    }\n\n    return alt;\n  }\n  /**\n   * Add an edge to the DFA, if possible. This method calls\n   * {@link //addDFAState} to ensure the {@code to} state is present in the\n   * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n   * range of edges that can be represented in the DFA tables, this method\n   * returns without adding the edge to the DFA.\n   *\n   * <p>If {@code to} is {@code null}, this method returns {@code null}.\n   * Otherwise, this method returns the {@link DFAState} returned by calling\n   * {@link //addDFAState} for the {@code to} state.</p>\n   *\n   * @param dfa The DFA\n   * @param from_ The source state for the edge\n   * @param t The input symbol\n   * @param to The target state for the edge\n   *\n   * @return If {@code to} is {@code null}, this method returns {@code null};\n   * otherwise this method returns the result of calling {@link //addDFAState}\n   * on {@code to}\n   */\n\n\n  addDFAEdge(dfa, from_, t, to) {\n    if (this.debug) {\n      console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n    }\n\n    if (to === null) {\n      return null;\n    }\n\n    to = this.addDFAState(dfa, to); // used existing if possible not incoming\n\n    if (from_ === null || t < -1 || t > this.atn.maxTokenType) {\n      return to;\n    }\n\n    if (from_.edges === null) {\n      from_.edges = [];\n    }\n\n    from_.edges[t + 1] = to; // connect\n\n    if (this.debug) {\n      const literalNames = this.parser === null ? null : this.parser.literalNames;\n      const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;\n      console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n    }\n\n    return to;\n  }\n  /**\n   * Add state {@code D} to the DFA if it is not already present, and return\n   * the actual instance stored in the DFA. If a state equivalent to {@code D}\n   * is already in the DFA, the existing state is returned. Otherwise this\n   * method returns {@code D} after adding it to the DFA.\n   *\n   * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n   * does not change the DFA.</p>\n   *\n   * @param dfa The dfa\n   * @param D The DFA state to add\n   * @return The state stored in the DFA. This will be either the existing\n   * state if {@code D} is already in the DFA, or {@code D} itself if the\n   * state was not already present\n   */\n\n\n  addDFAState(dfa, D) {\n    if (D === ATNSimulator.ERROR) {\n      return D;\n    }\n\n    const existing = dfa.states.get(D);\n\n    if (existing !== null) {\n      return existing;\n    }\n\n    D.stateNumber = dfa.states.length;\n\n    if (!D.configs.readOnly) {\n      D.configs.optimizeConfigs(this);\n      D.configs.setReadonly(true);\n    }\n\n    dfa.states.add(D);\n\n    if (this.debug) {\n      console.log(\"adding new DFA state: \" + D);\n    }\n\n    return D;\n  }\n\n  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n    if (this.debug || this.retry_debug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n\n    if (this.parser !== null) {\n      this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n    }\n  }\n\n  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n    if (this.debug || this.retry_debug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n\n    if (this.parser !== null) {\n      this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n    }\n  } // If context sensitive parsing, we know it's ambiguity not conflict//\n\n\n  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n    if (this.debug || this.retry_debug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n    }\n\n    if (this.parser !== null) {\n      this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n  }\n\n}\n\nmodule.exports = ParserATNSimulator;","map":{"version":3,"sources":["/home/mario/Desktop/ChessLion/client/node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js"],"names":["Utils","require","Set","BitSet","DoubleDict","ATN","ATNState","RuleStopState","ATNConfig","ATNConfigSet","Token","DFAState","PredPrediction","ATNSimulator","PredictionMode","RuleContext","ParserRuleContext","SemanticContext","PredictionContext","Interval","Transition","SetTransition","NotSetTransition","RuleTransition","ActionTransition","NoViableAltException","SingletonPredictionContext","predictionContextFromRuleContext","ParserATNSimulator","constructor","parser","atn","decisionToDFA","sharedContextCache","predictionMode","LL","_input","_startIndex","_outerContext","_dfa","mergeCache","debug","debug_closure","debug_add","debug_list_atn_decisions","dfa_debug","retry_debug","reset","adaptivePredict","input","decision","outerContext","console","log","getLookaheadName","LT","line","column","index","dfa","m","mark","s0","precedenceDfa","getPrecedenceStartState","getPrecedence","EMPTY","toString","ruleNames","fullCtx","s0_closure","computeStartState","atnStartState","configs","applyPrecedenceFilter","addDFAState","setPrecedenceStartState","alt","execATN","literalNames","symbolicNames","seek","release","startIndex","previousD","t","LA","D","getExistingTargetState","computeTargetState","ERROR","e","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","INVALID_ALT_NUMBER","requiresFullContext","SLL","conflictingAlts","predicates","conflictIndex","evalSemanticContext","length","minValue","reportAttemptingFullContext","execATNWithFullContext","isAcceptState","prediction","stopIndex","alts","reportAmbiguity","EOF","consume","edges","reach","computeReachSet","addDFAEdge","predictedAlt","getUniqueAlt","altSubSets","getConflictingAltSubsets","arrayToString","allSubsetsConflict","getConflictingAlts","uniqueAlt","hasSLLConflictTerminatingPrediction","hasSemanticContext","predicateDFAState","getDecisionState","dfaState","decisionState","nalts","transitions","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","previous","resolvesToJustOneViableAlt","LL_EXACT_AMBIG_DETECTION","allSubsetsEqual","getSingleViableAlt","reportContextSensitivity","closure","intermediate","skippedStopStates","i","items","c","getTokenName","state","push","j","trans","target","getReachableTarget","cfg","add","closureBusy","treatEofAsEpsilon","k","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","l","lookToEndOfRule","allConfigsInRuleStopStates","result","config","epsilonOnlyTransitions","nextTokens","contains","EPSILON","endOfRuleState","ruleToStopState","ruleIndex","p","ctx","initialContext","context","statesFromAlt1","configSet","updatedContext","semanticContext","evalPrecedence","stateNumber","precedenceFilterSuppressed","equals","ttype","matches","maxTokenType","ambigAlts","orContext","nPredAlts","pred","NONE","pairs","containsPredicate","cfgs","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","reachesIntoOuterContext","hasEmptyPath","indexOf","Math","min","apply","succeeded","failed","predicateEvaluationResult","evaluate","predPredictions","complete","predictions","pair","collectPredicates","initialDepth","closureCheckingStopState","depth","isEmpty","getReturnState","EMPTY_RETURN_STATE","getRuleName","closure_","returnState","states","newContext","getParent","parms","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","getEpsilonTarget","newDepth","outermostPrecedenceReturn","dipsIntoOuterContext","isEpsilon","stateType","STAR_LOOP_ENTRY","isPrecedenceDecision","numCtxs","decisionStartState","blockEndStateNum","endState","blockEndState","returnStateNumber","returnStateTarget","BLOCK_END","inContext","serializationType","RULE","ruleTransition","PRECEDENCE","precedenceTransition","PREDICATE","predTransition","ACTION","actionTransition","ATOM","RANGE","SET","actionIndex","pt","precedence","getRuleInvocationStack","currentPosition","predSucceeds","getPredicate","newSemCtx","andContext","predIndex","isCtxDependent","followState","create","altsets","getAlts","getInputStream","getTokens","name","dumpDeadEndConfigs","nvae","decs","getDeadEndConfigs","AtomTransition","label","neg","set","error","get","from_","to","existing","readOnly","optimizeConfigs","setReadonly","interval","getTokenStream","getText","getErrorListenerDispatch","exact","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,YAAD,CAArB;;AACA,MAAM;AAACC,EAAAA,GAAD;AAAMC,EAAAA,MAAN;AAAcC,EAAAA;AAAd,IAA4BJ,KAAlC;;AAEA,MAAMK,GAAG,GAAGJ,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAM;AAACK,EAAAA,QAAD;AAAWC,EAAAA;AAAX,IAA4BN,OAAO,CAAC,YAAD,CAAzC;;AAEA,MAAM;AAACO,EAAAA;AAAD,IAAcP,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAM;AAACQ,EAAAA;AAAD,IAAiBR,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAM;AAACS,EAAAA;AAAD,IAAUT,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAM;AAACU,EAAAA,QAAD;AAAWC,EAAAA;AAAX,IAA6BX,OAAO,CAAC,mBAAD,CAA1C;;AACA,MAAMY,YAAY,GAAGZ,OAAO,CAAC,gBAAD,CAA5B;;AACA,MAAMa,cAAc,GAAGb,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAMc,WAAW,GAAGd,OAAO,CAAC,kBAAD,CAA3B;;AACA,MAAMe,iBAAiB,GAAGf,OAAO,CAAC,wBAAD,CAAjC;;AACA,MAAM;AAACgB,EAAAA;AAAD,IAAoBhB,OAAO,CAAC,mBAAD,CAAjC;;AACA,MAAM;AAACiB,EAAAA;AAAD,IAAsBjB,OAAO,CAAC,wBAAD,CAAnC;;AACA,MAAM;AAACkB,EAAAA;AAAD,IAAalB,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAM;AAACmB,EAAAA,UAAD;AAAaC,EAAAA,aAAb;AAA4BC,EAAAA,gBAA5B;AAA8CC,EAAAA,cAA9C;AAA8DC,EAAAA;AAA9D,IAAkFvB,OAAO,CAAC,cAAD,CAA/F;;AACA,MAAM;AAACwB,EAAAA;AAAD,IAAyBxB,OAAO,CAAC,mBAAD,CAAtC;;AACA,MAAM;AAACyB,EAAAA,0BAAD;AAA6BC,EAAAA;AAA7B,IAAiE1B,OAAO,CAAC,wBAAD,CAA9E;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM2B,kBAAN,SAAiCf,YAAjC,CAA8C;AAC1CgB,EAAAA,WAAW,CAACC,MAAD,EAASC,GAAT,EAAcC,aAAd,EAA6BC,kBAA7B,EAAiD;AACxD,UAAMF,GAAN,EAAWE,kBAAX;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","sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Set, BitSet, DoubleDict} = Utils;\n\nconst ATN = require('./ATN');\nconst {ATNState, RuleStopState} = require('./ATNState');\n\nconst {ATNConfig} = require('./ATNConfig');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {Token} = require('./../Token');\nconst {DFAState, PredPrediction} = require('./../dfa/DFAState');\nconst ATNSimulator = require('./ATNSimulator');\nconst PredictionMode = require('./PredictionMode');\nconst RuleContext = require('./../RuleContext');\nconst ParserRuleContext = require('./../ParserRuleContext');\nconst {SemanticContext} = require('./SemanticContext');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {Interval} = require('./../IntervalSet');\nconst {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require('./Transition');\nconst {NoViableAltException} = require('./../error/Errors');\nconst {SingletonPredictionContext, predictionContextFromRuleContext} = require('./../PredictionContext');\n\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\nclass ParserATNSimulator extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n        super(atn, sharedContextCache);\n        this.parser = parser;\n        this.decisionToDFA = decisionToDFA;\n        // SLL, LL, or LL + exact ambig detection?//\n        this.predictionMode = PredictionMode.LL;\n        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n        this._input = null;\n        this._startIndex = 0;\n        this._outerContext = null;\n        this._dfa = null;\n        /**\n         * Each prediction operation uses a cache for merge of prediction contexts.\n         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n         *  isn't synchronized but we're ok since two threads shouldn't reuse same\n         *  parser/atnsim object because it can only handle one input at a time.\n         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n         *  also be examined during cache lookup.\n         */\n        this.mergeCache = null;\n        this.debug = false;\n        this.debug_closure = false;\n        this.debug_add = false;\n        this.debug_list_atn_decisions = false;\n        this.dfa_debug = false;\n        this.retry_debug = false;\n    }\n\n    reset() {}\n\n    adaptivePredict(input, decision, outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"adaptivePredict decision \" + decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \" line \" + input.LT(1).line + \":\" +\n                                   input.LT(1).column);\n        }\n        this._input = input;\n        this._startIndex = input.index;\n        this._outerContext = outerContext;\n\n        const dfa = this.decisionToDFA[decision];\n        this._dfa = dfa;\n        const m = input.mark();\n        const index = input.index;\n\n        // Now we are certain to have a specific decision's DFA\n        // But, do we still need an initial state?\n        try {\n            let s0;\n            if (dfa.precedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            } else {\n                // the start state for a \"regular\" DFA is just s0\n                s0 = dfa.s0;\n            }\n            if (s0===null) {\n                if (outerContext===null) {\n                    outerContext = RuleContext.EMPTY;\n                }\n                if (this.debug || this.debug_list_atn_decisions) {\n                    console.log(\"predictATN decision \" + dfa.decision +\n                                       \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                       \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                }\n\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n                if( dfa.precedenceDfa) {\n                    // If this is a precedence DFA, we use applyPrecedenceFilter\n                    // to convert the computed start state to a precedence start\n                    // state. We then use DFA.setPrecedenceStartState to set the\n                    // appropriate start state for the precedence level rather\n                    // than simply setting DFA.s0.\n                    //\n                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (this.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));\n            }\n            return alt;\n        } finally {\n            this._dfa = null;\n            this.mergeCache = null; // wack cache after each prediction\n            input.seek(index);\n            input.release(m);\n        }\n    }\n\n    /**\n     * Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *       if the set is empty, there is no viable alternative for current symbol\n     *       does the state uniquely predict an alternative?\n     *       does the state have a conflict that would prevent us from\n     *         putting it on the work list?\n     *\n     * We also have some key operations to do:\n     *       add an edge from previous DFA state to potentially new DFA state, D,\n     *         upon current symbol but only if adding to work list, which means in all\n     *         cases except no viable alternative (and possibly non-greedy decisions?)\n     *       collecting predicates and adding semantic context to DFA accept states\n     *       adding rule context to context-sensitive DFA accept states\n     *       consuming an input symbol\n     *       reporting a conflict\n     *       reporting an ambiguity\n     *       reporting a context sensitivity\n     *       reporting insufficient predicates\n     *\n     * cover these cases:\n     *    dead end\n     *    single alt\n     *    single alt + preds\n     *    conflict\n     *    conflict + preds\n     *\n     */\n    execATN(dfa, s0, input, startIndex, outerContext ) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        }\n        let alt;\n        let previousD = s0;\n\n        if (this.debug) {\n            console.log(\"s0 = \" + s0);\n        }\n        let t = input.LA(1);\n        while(true) { // while more work\n            let D = this.getExistingTargetState(previousD, t);\n            if(D===null) {\n                D = this.computeTargetState(dfa, previousD, t);\n            }\n            if(D===ATNSimulator.ERROR) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for SLL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n                let conflictingAlts = null;\n                if (D.predicates!==null) {\n                    if (this.debug) {\n                        console.log(\"DFA state has preds in DFA sim LL failover\");\n                    }\n                    const conflictIndex = input.index;\n                    if(conflictIndex !== startIndex) {\n                        input.seek(startIndex);\n                    }\n                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                    if (conflictingAlts.length===1) {\n                        if(this.debug) {\n                            console.log(\"Full LL avoided\");\n                        }\n                        return conflictingAlts.minValue();\n                    }\n                    if (conflictIndex !== startIndex) {\n                        // restore the index so reporting the fallback to full\n                        // context occurs with the index at the correct spot\n                        input.seek(conflictIndex);\n                    }\n                }\n                if (this.dfa_debug) {\n                    console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n                }\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (D.isAcceptState) {\n                if (D.predicates===null) {\n                    return D.prediction;\n                }\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (alts.length===0) {\n                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                } else if (alts.length===1) {\n                    return alts.minValue();\n                } else {\n                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                    return alts.minValue();\n                }\n            }\n            previousD = D;\n\n            if (t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns {@code null}.\n     *\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     * @return The existing target DFA state for the given input symbol\n     * {@code t}, or {@code null} if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(previousD, t) {\n        const edges = previousD.edges;\n        if (edges===null) {\n            return null;\n        } else {\n            return edges[t + 1] || null;\n        }\n    }\n\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa The DFA\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     *\n     * @return The computed target DFA state for the given input symbol\n     * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n     * returns {@link //ERROR\n     */\n    computeTargetState(dfa, previousD, t) {\n       const reach = this.computeReachSet(previousD.configs, t, false);\n        if(reach===null) {\n            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n            return ATNSimulator.ERROR;\n        }\n        // create new target state; we'll add to DFA after it's complete\n        let D = new DFAState(null, reach);\n\n        const predictedAlt = this.getUniqueAlt(reach);\n\n        if (this.debug) {\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                        /*\", previous=\" + previousD.configs + */\n                        \", configs=\" + reach +\n                        \", predict=\" + predictedAlt +\n                        \", allSubsetsConflict=\" +\n                        PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                        this.getConflictingAlts(reach));\n        }\n        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n            // NO CONFLICT, UNIQUELY PREDICTED ALT\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            // MORE THAN ONE VIABLE ALTERNATIVE\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            // in SLL-only mode, we will stop at this state and return the minimum alt\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.minValue();\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if( D.predicates!==null) {\n                D.prediction = ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        // all adds to dfa are done after we've created full D state\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n\n    predicateDFAState(dfaState, decisionState) {\n        // We need to test all predicates, even in DFA states that\n        // uniquely predict alternative.\n        const nalts = decisionState.transitions.length;\n        // Update DFA so reach becomes accept state with (predicate,alt)\n        // pairs if preds found for conflicting alts\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n        if (altToPred!==null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n        } else {\n            // There are preds in configs but they might go away\n            // when OR'd together like {p}? || NONE == NONE. If neither\n            // alt has preds, resolve to min alt\n            dfaState.prediction = altsToCollectPredsFrom.minValue();\n        }\n    }\n\n// comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, // how far we got before failing over\n                                         s0,\n                                         input,\n                                         startIndex,\n                                         outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATNWithFullContext \"+s0);\n        }\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        while (true) { // while more work\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach===null) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for LL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            if(this.debug) {\n                console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                      PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n            }\n            reach.uniqueAlt = this.getUniqueAlt(reach);\n            // unique prediction?\n            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                    break;\n                }\n            } else {\n                // In exact ambiguity mode, we never try to terminate early.\n                // Just keeps scarfing until we know what the conflict is\n                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                    foundExactAmbig = true;\n                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                    break;\n                }\n                // else there are multiple non-conflicting subsets or\n                // we're not sure what the ambiguity is yet.\n                // So, keep going.\n            }\n            previous = reach;\n            if( t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        // If the configuration set uniquely predicts an alternative,\n        // without conflict, then we know that it's a full LL decision\n        // not SLL.\n        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        // We do not check predicates here because we have checked them\n        // on-the-fly when doing full context prediction.\n\n        //\n        // In non-exact ambiguity detection mode, we might\tactually be able to\n        // detect an exact ambiguity, but I'm not going to spend the cycles\n        // needed to check. We only emit ambiguity warnings in exact ambiguity\n        // mode.\n        //\n        // For example, we might know that we have conflicting configurations.\n        // But, that does not mean that there is no way forward without a\n        // conflict. It's possible to have nonconflicting alt subsets as in:\n\n        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n        // from\n        //\n        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n        //\n        // In this case, (17,1,[5 $]) indicates there is some next sequence that\n        // would resolve this without conflict to alternative 1. Any other viable\n        // next sequence, however, is associated with a conflict.  We stop\n        // looking for input because no amount of further lookahead will alter\n        // the fact that we should predict alternative 1.  We just can't say for\n        // sure that there is an ambiguity without looking further.\n\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n        return predictedAlt;\n    }\n\n    computeReachSet(closure, t, fullCtx) {\n        if (this.debug) {\n            console.log(\"in computeReachSet, starting closure: \" + closure);\n        }\n        if( this.mergeCache===null) {\n            this.mergeCache = new DoubleDict();\n        }\n        const intermediate = new ATNConfigSet(fullCtx);\n\n        // Configurations already in a rule stop state indicate reaching the end\n        // of the decision rule (local context) or end of the start rule (full\n        // context). Once reached, these configurations are never updated by a\n        // closure operation, so they are handled separately for the performance\n        // advantage of having a smaller intermediate set when calling closure.\n        //\n        // For full-context reach operations, separate handling is required to\n        // ensure that the alternative matching the longest overall sequence is\n        // chosen when multiple such configurations can match the input.\n\n        let skippedStopStates = null;\n\n        // First figure out where we can reach on input t\n        for (let i=0; i<closure.items.length;i++) {\n            const c = closure.items[i];\n            if(this.debug) {\n                console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            }\n            if (c.state instanceof RuleStopState) {\n                if (fullCtx || t === Token.EOF) {\n                    if (skippedStopStates===null) {\n                        skippedStopStates = [];\n                    }\n                    skippedStopStates.push(c);\n                    if(this.debug_add) {\n                        console.log(\"added \" + c + \" to skippedStopStates\");\n                    }\n                }\n                continue;\n            }\n            for(let j=0;j<c.state.transitions.length;j++) {\n                const trans = c.state.transitions[j];\n                const target = this.getReachableTarget(trans, t);\n                if (target!==null) {\n                    const cfg = new ATNConfig({state:target}, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if(this.debug_add) {\n                        console.log(\"added \" + cfg + \" to intermediate\");\n                    }\n                }\n            }\n        }\n        // Now figure out where the reach operation can take us...\n        let reach = null;\n\n        // This block optimizes the reach operation for intermediate sets which\n        // trivially indicate a termination state for the overall\n        // adaptivePredict operation.\n        //\n        // The conditions assume that intermediate\n        // contains all configurations relevant to the reach set, but this\n        // condition is not true when one or more configurations have been\n        // withheld in skippedStopStates, or when the current symbol is EOF.\n        //\n        if (skippedStopStates===null && t!==Token.EOF) {\n            if (intermediate.items.length===1) {\n                // Don't pursue the closure if there is just one state.\n                // It can only have one alternative; just add to result\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            }\n        }\n        // If the reach set could not be trivially determined, perform a closure\n        // operation on the intermediate set to compute its initial value.\n        //\n        if (reach===null) {\n            reach = new ATNConfigSet(fullCtx);\n            const closureBusy = new Set();\n            const treatEofAsEpsilon = t === Token.EOF;\n            for (let k=0; k<intermediate.items.length;k++) {\n                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n            }\n        }\n        if (t === Token.EOF) {\n            // After consuming EOF no additional input is possible, so we are\n            // only interested in configurations which reached the end of the\n            // decision rule (local context) or end of the start rule (full\n            // context). Update reach to contain only these configurations. This\n            // handles both explicit EOF transitions in the grammar and implicit\n            // EOF transitions following the end of the decision or start rule.\n            //\n            // When reach==intermediate, no closure operation was performed. In\n            // this case, removeAllConfigsNotInRuleStopState needs to check for\n            // reachable rule stop states as well as configurations already in\n            // a rule stop state.\n            //\n            // This is handled before the configurations in skippedStopStates,\n            // because any configurations potentially added from that list are\n            // already guaranteed to meet this condition whether or not it's\n            // required.\n            //\n            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        }\n        // If skippedStopStates!==null, then it contains at least one\n        // configuration. For full-context reach operations, these\n        // configurations reached the end of the start rule, in which case we\n        // only add them back to reach if no configuration during the current\n        // closure operation reached such a state. This ensures adaptivePredict\n        // chooses an alternative matching the longest overall sequence when\n        // multiple alternatives are viable.\n        //\n        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n            for (let l=0; l<skippedStopStates.length;l++) {\n                reach.add(skippedStopStates[l], this.mergeCache);\n            }\n        }\n        if (reach.items.length===0) {\n            return null;\n        } else {\n            return reach;\n        }\n    }\n\n    /**\n     * Return a configuration set containing only the configurations from\n     * {@code configs} which are in a {@link RuleStopState}. If all\n     * configurations in {@code configs} are already in a rule stop state, this\n     * method simply returns {@code configs}.\n     *\n     * <p>When {@code lookToEndOfRule} is true, this method uses\n     * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n     * not already in a rule stop state to see if a rule stop state is reachable\n     * from the configuration via epsilon-only transitions.</p>\n     *\n     * @param configs the configuration set to update\n     * @param lookToEndOfRule when true, this method checks for rule stop states\n     * reachable by epsilon-only transitions from each configuration in\n     * {@code configs}.\n     *\n     * @return {@code configs} if all configurations in {@code configs} are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from {@code configs} which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        const result = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length;i++) {\n            const config = configs.items[i];\n            if (config.state instanceof RuleStopState) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains(Token.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n\n    computeStartState(p, ctx, fullCtx) {\n        // always at least the implicit call to start rule\n        const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n        const configs = new ATNConfigSet(fullCtx);\n        for(let i=0;i<p.transitions.length;i++) {\n            const target = p.transitions[i].target;\n            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n            const closureBusy = new Set();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n\n    /**\n     * This method transforms the start state computed by\n     * {@link //computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * <ol>\n     * <li>Evaluate the precedence predicates for each configuration using\n     * {@link SemanticContext//evalPrecedence}.</li>\n     * <li>Remove all configurations which predict an alternative greater than\n     * 1, for which another configuration that predicts alternative 1 is in the\n     * same ATN state with the same prediction context. This transformation is\n     * valid for the following reasons:\n     * <ul>\n     * <li>The closure block cannot contain any epsilon transitions which bypass\n     * the body of the closure, so all states reachable via alternative 1 are\n     * part of the precedence alternatives of the transformed left-recursive\n     * rule.</li>\n     * <li>The \"primary\" portion of a left recursive rule cannot contain an\n     * epsilon transition, so the only way an alternative other than 1 can exist\n     * in a state that is also reachable via alternative 1 is by nesting calls\n     * to the left-recursive rule, with the outer calls not being at the\n     * preferred precedence level.</li>\n     * </ul>\n     * </li>\n     * </ol>\n     *\n     * <p>\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     * </p>\n     * <code>\n     * <pre>\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * </pre>\n     * </code>\n     * <p>\n     * If the above grammar, the ATN state immediately before the token\n     * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * {@code statement}. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to {@code prog} (and then back in to {@code statement}\n     * from being eliminated by the filter.\n     * </p>\n     *\n     * @param configs The configuration set computed by\n     * {@link //computeStartState} as the start state for the DFA.\n     * @return The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser//getPrecedence})\n     */\n    applyPrecedenceFilter(configs) {\n        let config;\n        const statesFromAlt1 = [];\n        const configSet = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n            if (updatedContext===null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n            } else {\n                configSet.add(config, this.mergeCache);\n            }\n        }\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            // In the future, this elimination step could be updated to also\n            // filter the prediction context for alternatives predicting alt>1\n            // (basically a graph subtraction algorithm).\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context!==null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        } else {\n            return null;\n        }\n    }\n\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        // altToPred starts as an array of all null contexts. The entry at index i\n        // corresponds to alternative i. altToPred[i] may have one of three values:\n        //   1. null: no ATNConfig c is found such that c.alt==i\n        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n        //      alt i has at least one unpredicated config.\n        //   3. Non-NONE Semantic Context: There exists at least one, and for all\n        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n        //\n        // From this, it is clear that NONE||anything==NONE.\n        //\n        let altToPred = [];\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if(ambigAlts.contains( c.alt )) {\n                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i =1;i< nalts+1;i++) {\n            const pred = altToPred[i] || null;\n            if (pred===null) {\n                altToPred[i] = SemanticContext.NONE;\n            } else if (pred !== SemanticContext.NONE) {\n                nPredAlts += 1;\n            }\n        }\n        // nonambig alts are null in altToPred\n        if (nPredAlts===0) {\n            altToPred = null;\n        }\n        if (this.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n        }\n        return altToPred;\n    }\n\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for (let i=1; i<altToPred.length;i++) {\n            const pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            if( ambigAlts!==null && ambigAlts.contains( i )) {\n                pairs.push(new PredPrediction(pred, i));\n            }\n            if (pred !== SemanticContext.NONE) {\n                containsPredicate = true;\n            }\n        }\n        if (! containsPredicate) {\n            return null;\n        }\n        return pairs;\n    }\n\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link //ERROR} state was reached during ATN simulation.\n     *\n     * <p>\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.</p>\n     *\n     * <ul>\n     * <li>If a syntactically valid path or paths reach the end of the decision rule and\n     * they are semantically valid if predicated, return the min associated alt.</li>\n     * <li>Else, if a semantically invalid but syntactically valid path exist\n     * or paths exist, return the minimum associated alt.\n     * </li>\n     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n     * </ul>\n     *\n     * <p>\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * the parser. Specifically, this could occur if the <em>only</em> configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link //adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     * </p>\n     *\n     * @param configs The ATN configurations which were valid immediately before\n     * the {@link //ERROR} state was reached\n     * @param outerContext The is the \\gamma_0 initial parser context from the paper\n     * or the parser stack at the instant before prediction commences.\n     *\n     * @return The value to return from {@link //adaptivePredict}, or\n     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link //adaptivePredict} should report an error instead\n     */\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = cfgs[0];\n        const semInvalidConfigs = cfgs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n            return alt;\n        }\n        // Is there a syntactically valid path with a failed pred?\n        if (semInvalidConfigs.items.length>0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n                return alt;\n            }\n        }\n        return ATN.INVALID_ALT_NUMBER;\n    }\n\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n                if(alts.indexOf(c.alt)<0) {\n                    alts.push(c.alt);\n                }\n            }\n        }\n        if (alts.length===0) {\n            return ATN.INVALID_ALT_NUMBER;\n        } else {\n            return Math.min.apply(null, alts);\n        }\n    }\n\n    /**\n     * Walk the list of configurations and split them according to\n     * those that have preds evaluating to true/false.  If no pred, assume\n     * true pred and include in succeeded set.  Returns Pair of sets.\n     *\n     * Create a new set so as not to alter the incoming parameter.\n     *\n     * Assumption: the input stream has been restored to the starting point\n     * prediction, which is where predicates need to evaluate.*/\n    splitAccordingToSemanticValidity( configs, outerContext) {\n        const succeeded = new ATNConfigSet(configs.fullCtx);\n        const failed = new ATNConfigSet(configs.fullCtx);\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.semanticContext !== SemanticContext.NONE) {\n                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n                if (predicateEvaluationResult) {\n                    succeeded.add(c);\n                } else {\n                    failed.add(c);\n                }\n            } else {\n                succeeded.add(c);\n            }\n        }\n        return [succeeded, failed];\n    }\n\n    /**\n     * Look through a list of predicate/alt pairs, returning alts for the\n     * pairs that win. A {@code NONE} predicate indicates an alt containing an\n     * unpredicated config which behaves as \"always true.\" If !complete\n     * then we stop at the first predicate that evaluates to true. This\n     * includes pairs with null predicates.\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new BitSet();\n        for(let i=0;i<predPredictions.length;i++) {\n            const pair = predPredictions[i];\n            if (pair.pred === SemanticContext.NONE) {\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (this.debug || this.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            }\n            if (predicateEvaluationResult) {\n                if (this.debug || this.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (this.debug || this.debug_closure) {\n            console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n            // console.log(\"configs(\" + configs.toString() + \")\");\n            if(config.reachesIntoOuterContext>50) {\n                throw \"problem\";\n            }\n        }\n        if (config.state instanceof RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            // run thru all possible stack tops in ctx\n            if (! config.context.isEmpty()) {\n                for (let i =0; i<config.context.length; i++) {\n                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                            continue;\n                        } else {\n                            // we have no context info, just chase follow links (if greedy)\n                            if (this.debug) {\n                                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            }\n                            this.closure_(config, configs, closureBusy, collectPredicates,\n                                     fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i); // \"pop\" return state\n                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                    const c = new ATNConfig(parms, null);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having falling off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if( fullCtx) {\n                // reached end of start rule\n                configs.add(config, this.mergeCache);\n                return;\n            } else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (this.debug) {\n                    console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n            }\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        // optimization\n        if (! p.epsilonOnlyTransitions) {\n            configs.add(config, this.mergeCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n        }\n        for(let i = 0;i<p.transitions.length; i++) {\n            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n                continue;\n\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c!==null) {\n                let newDepth = depth;\n                if ( config.state instanceof RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this._dfa !== null && this._dfa.precedenceDfa) {\n                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                            c.precedenceFilterSuppressed = true;\n                        }\n                    }\n\n                    c.reachesIntoOuterContext += 1;\n                    if (closureBusy.add(c)!==c) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                    newDepth -= 1;\n                    if (this.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                } else {\n                    if (!t.isEpsilon && closureBusy.add(c)!==c){\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                    if (t instanceof RuleTransition) {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth += 1;\n                        }\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        // return False\n        const p = config.state;\n        // First check to see if we are in StarLoopEntryState generated during\n        // left-recursion elimination. For efficiency, also check if\n        // the context has an empty stack case. If so, it would mean\n        // global FOLLOW so we can't perform optimization\n        // Are we the special loop entry/exit state? or SLL wildcard\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)\n            return false;\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n               config.context.isEmpty() || config.context.hasEmptyPath())\n            return false;\n\n        // Require all return states to return back to the same rule that p is in.\n        const numCtxs = config.context.length;\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex)\n                return false;\n        }\n\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n\n        // Verify that the top of each stack context leads to loop entry/exit\n        // state through epsilon edges and w/o leaving rule.\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            // all states must have single outgoing epsilon edge\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n                return false;\n\n            // Look for prefix op case like 'not expr', (' type ')' expr\n            const returnStateTarget = returnState.transitions[0].target;\n            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )\n                continue;\n\n            // Look for 'expr op expr' or case where expr's return state is block end\n            // of (...)* internal block; the block end points to loop back\n            // which points to p but we don't need to check that\n            if ( returnState === blockEndState )\n                continue;\n\n            // Look for ternary expr ? expr : expr. The return state points at block end,\n            // which points at loop entry state\n            if ( returnStateTarget === blockEndState )\n                continue;\n\n            // Look for complex prefix 'between expr and expr' case where 2nd expr's\n            // return state points at block end state of (...)* internal block\n            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1\n                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n                continue;\n\n            // anything else ain't conforming\n            return false;\n        }\n        return true;\n    }\n\n    getRuleName(index) {\n        if (this.parser!==null && index>=0) {\n            return this.parser.ruleNames[index];\n        } else {\n            return \"<rule \" + index + \">\";\n        }\n    }\n\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.serializationType) {\n        case Transition.RULE:\n            return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n            return this.actionTransition(config, t);\n        case Transition.EPSILON:\n            return new ATNConfig({state:t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n            // EOF transitions act like epsilon transitions after the first EOF\n            // transition is traversed\n            if (treatEofAsEpsilon) {\n                if (t.matches(Token.EOF, 0, 1)) {\n                    return new ATNConfig({state: t.target}, config);\n                }\n            }\n            return null;\n        default:\n            return null;\n        }\n    }\n\n    actionTransition(config, t) {\n        if (this.debug) {\n            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n        }\n        return new ATNConfig({state:t.target}, config);\n    }\n\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                    pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                    \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    ruleTransition(config, t) {\n        if (this.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        }\n        const returnState = t.followState;\n        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n        return new ATNConfig({state:t.target, context:newContext}, config );\n    }\n\n    getConflictingAlts(configs) {\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.getAlts(altsets);\n    }\n\n    /**\n     * Sam pointed out a problem with the previous definition, v3, of\n     * ambiguous states. If we have another state associated with conflicting\n     * alternatives, we should keep going. For example, the following grammar\n     *\n     * s : (ID | ID ID?) ';' ;\n     *\n     * When the ATN simulation reaches the state before ';', it has a DFA\n     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n     * because alternative to has another way to continue, via [6|2|[]].\n     * The key is that we have a single state that has config's only associated\n     * with a single alternative, 2, and crucially the state transitions\n     * among the configurations are all non-epsilon transitions. That means\n     * we don't consider any conflicts that include alternative 2. So, we\n     * ignore the conflict between alts 1 and 2. We ignore a set of\n     * conflicting alts when there is an intersection with an alternative\n     * associated with a single alt state in the state&rarr;config-list map.\n     *\n     * It's also the case that we might have two conflicting configurations but\n     * also a 3rd nonconflicting configuration for a different alternative:\n     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n     *\n     * a : A | A | A B ;\n     *\n     * After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not\n     * stop working on this state. In the previous example, we're concerned\n     * with states associated with the conflicting alternatives. Here alt\n     * 3 is not associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, I don't declare the state done. We\n     * ignore a set of conflicting alts when we have an alternative\n     * that we still need to pursue\n     */\n    getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts = null;\n        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet();\n            conflictingAlts.add(configs.uniqueAlt);\n        } else {\n            conflictingAlts = configs.conflictingAlts;\n        }\n        return conflictingAlts;\n    }\n\n    getTokenName(t) {\n        if (t===Token.EOF) {\n            return \"EOF\";\n        }\n        if( this.parser!==null && this.parser.literalNames!==null) {\n            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n                console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n                console.log(\"\" + this.parser.getInputStream().getTokens());\n            } else {\n                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n                return name + \"<\" + t + \">\";\n            }\n        }\n        return \"\" + t;\n    }\n\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n\n    /**\n     * Used for debugging in adaptivePredict around execATN but I cut\n     * it out for clarity now that alg. works well. We can leave this\n     * \"dead\" code for a bit\n     */\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        const decs = nvae.getDeadEndConfigs();\n        for(let i=0; i<decs.length; i++) {\n            const c = decs[i];\n            let trans = \"no edges\";\n            if (c.state.transitions.length>0) {\n                const t = c.state.transitions[0];\n                if (t instanceof AtomTransition) {\n                    trans = \"Atom \"+ this.getTokenName(t.label);\n                } else if (t instanceof SetTransition) {\n                    const neg = (t instanceof NotSetTransition);\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n\n    getUniqueAlt(configs) {\n        let alt = ATN.INVALID_ALT_NUMBER;\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (alt === ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt // found first alt\n            } else if( c.alt!==alt) {\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n\n    /**\n     * Add an edge to the DFA, if possible. This method calls\n     * {@link //addDFAState} to ensure the {@code to} state is present in the\n     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n     * range of edges that can be represented in the DFA tables, this method\n     * returns without adding the edge to the DFA.\n     *\n     * <p>If {@code to} is {@code null}, this method returns {@code null}.\n     * Otherwise, this method returns the {@link DFAState} returned by calling\n     * {@link //addDFAState} for the {@code to} state.</p>\n     *\n     * @param dfa The DFA\n     * @param from_ The source state for the edge\n     * @param t The input symbol\n     * @param to The target state for the edge\n     *\n     * @return If {@code to} is {@code null}, this method returns {@code null};\n     * otherwise this method returns the result of calling {@link //addDFAState}\n     * on {@code to}\n     */\n    addDFAEdge(dfa, from_, t, to) {\n        if( this.debug) {\n            console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        if (to===null) {\n            return null;\n        }\n        to = this.addDFAState(dfa, to); // used existing if possible not incoming\n        if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n            return to;\n        }\n        if (from_.edges===null) {\n            from_.edges = [];\n        }\n        from_.edges[t+1] = to; // connect\n\n        if (this.debug) {\n            const literalNames = this.parser===null ? null : this.parser.literalNames;\n            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n            console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n        }\n        return to;\n    }\n\n    /**\n     * Add state {@code D} to the DFA if it is not already present, and return\n     * the actual instance stored in the DFA. If a state equivalent to {@code D}\n     * is already in the DFA, the existing state is returned. Otherwise this\n     * method returns {@code D} after adding it to the DFA.\n     *\n     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n     * does not change the DFA.</p>\n     *\n     * @param dfa The dfa\n     * @param D The DFA state to add\n     * @return The state stored in the DFA. This will be either the existing\n     * state if {@code D} is already in the DFA, or {@code D} itself if the\n     * state was not already present\n     */\n    addDFAState(dfa, D) {\n        if (D === ATNSimulator.ERROR) {\n            return D;\n        }\n        const existing = dfa.states.get(D);\n        if(existing!==null) {\n            return existing;\n        }\n        D.stateNumber = dfa.states.length;\n        if (! D.configs.readOnly) {\n            D.configs.optimizeConfigs(this);\n            D.configs.setReadonly(true);\n        }\n        dfa.states.add(D);\n        if (this.debug) {\n            console.log(\"adding new DFA state: \" + D);\n        }\n        return D;\n    }\n\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        }\n    }\n\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n        }\n    }\n\n    // If context sensitive parsing, we know it's ambiguity not conflict//\n    reportAmbiguity(dfa, D, startIndex, stopIndex,\n                                   exact, ambigAlts, configs ) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n    }\n}\n\nmodule.exports = ParserATNSimulator;\n"]},"metadata":{},"sourceType":"script"}